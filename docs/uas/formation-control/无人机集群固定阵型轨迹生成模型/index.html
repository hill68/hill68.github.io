<!doctype html><html lang=zh-cn dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.147.3"><meta name=generator content="Relearn 7.6.1+4407b4364ab6f7477f7671fbd20c0494bade40ee"><meta name=description content="生成集群中每个无人机形成固定阵型的期望轨迹"><meta name=author content="你的名字"><meta name=twitter:card content="summary"><meta name=twitter:title content="无人机集群固定阵型轨迹生成模型 :: FlitSoft Docs"><meta name=twitter:description content="生成集群中每个无人机形成固定阵型的期望轨迹"><meta property="og:url" content="https://hill68.github.io/uas/formation-control/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E5%9B%BA%E5%AE%9A%E9%98%B5%E5%9E%8B%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/index.html"><meta property="og:site_name" content="FlitSoft Docs"><meta property="og:title" content="无人机集群固定阵型轨迹生成模型 :: FlitSoft Docs"><meta property="og:description" content="生成集群中每个无人机形成固定阵型的期望轨迹"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="UAS"><meta property="article:published_time" content="2025-05-21T17:07:50+08:00"><meta property="article:modified_time" content="2025-05-21T17:07:50+08:00"><meta itemprop=name content="无人机集群固定阵型轨迹生成模型 :: FlitSoft Docs"><meta itemprop=description content="生成集群中每个无人机形成固定阵型的期望轨迹"><meta itemprop=datePublished content="2025-05-21T17:07:50+08:00"><meta itemprop=dateModified content="2025-05-21T17:07:50+08:00"><meta itemprop=wordCount content="4275"><title>无人机集群固定阵型轨迹生成模型 :: FlitSoft Docs</title>
<link href=/images/logo.png?1750251247 rel=icon type=image/png><link href=/fonts/fontawesome/css/fontawesome-all.min.css?1750251247 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/fonts/fontawesome/css/fontawesome-all.min.css?1750251247 rel=stylesheet></noscript><link href=/css/perfect-scrollbar/perfect-scrollbar.min.css?1750251247 rel=stylesheet><link href=/css/theme.min.css?1750251247 rel=stylesheet><link href=/css/format-html.min.css?1750251247 rel=stylesheet id=R-format-style><link href=/css/auto-complete/auto-complete.min.css?1750251247 rel=stylesheet><script src=/js/auto-complete/auto-complete.min.js?1750251247 defer></script><script src=/js/lunr/lunr.min.js?1750251247 defer></script><script src=/js/lunr/lunr.stemmer.support.min.js?1750251247 defer></script><script src=/js/lunr/lunr.multi.min.js?1750251247 defer></script><script src=/js/lunr/lunr.zh.min.js?1750251247 defer></script><script src=/js/search.min.js?1750251247 defer></script><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/uas/formation-control/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E5%9B%BA%E5%AE%9A%E9%98%B5%E5%9E%8B%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/index.html",window.relearn.relBasePath="../../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://hill68.github.io",window.relearn.contentLangs=["zh"],window.relearn.index_js_url="/searchindex.en.js?1750251247",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!1,window.relearn.enableBlockCodeWrap=!0,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.relearn.themevariants=["zen-light","zen-dark"],window.relearn.customvariantname="my-custom-variant",window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant(),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/css/custom.css?1750251247 rel=stylesheet></head><body class="mobile-support html" data-url=/uas/formation-control/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E5%9B%BA%E5%AE%9A%E9%98%B5%E5%9E%8B%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/index.html><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div><div class="topbar-button topbar-button-toc" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title="Table of Contents (CTRL+ALT+t)"><i class="fa-fw fas fa-list-alt"></i></button><div class=topbar-content><div class=topbar-content-wrapper><nav class=TableOfContents><ul><li><a href=#1-数学模型>1. 数学模型</a><ul><li><a href=#11-主要变量定义>1.1 主要变量定义</a></li><li><a href=#12-动态约束扩展可选>1.2 动态约束扩展（可选）</a></li></ul></li><li><a href=#2-模型实现流程>2. 模型实现流程</a><ul><li><a href=#21-模型框架>2.1 模型框架</a></li><li><a href=#22-伪代码示例>2.2 伪代码示例</a></li></ul></li><li><a href=#3-模型说明>3. 模型说明</a></li><li><a href=#4-c代码实现参考>4. C++代码实现参考</a><ul><li><a href=#41-chatgpt-o3-mini-high>4.1 ChatGPT o3-mini-high</a></li><li><a href=#42-claude-35-sonnet>4.2 Claude 3.5 Sonnet</a></li></ul></li><li><a href=#附录1-轨迹跟踪实现参考示例>附录1. 轨迹跟踪实现参考示例</a><ul><li><a href=#1-按步进仿真的基本流程>1. 按步进仿真的基本流程</a></li><li><a href=#2-chatgpt-o3-mini-high-示例代码c>2. ChatGPT o3-mini-high 示例代码（C++）</a></li><li><a href=#3-claude-35-sonnet-示例代码c>3. Claude 3.5 Sonnet 示例代码（C++）</a></li></ul></li><li><a href=#附录2-阵型过渡过程中需注意的问题>附录2. 阵型过渡过程中需注意的问题</a><ul><li><a href=#1-任务分配与目标匹配>1. 任务分配与目标匹配</a></li><li><a href=#2-过渡轨迹生成>2. 过渡轨迹生成</a></li><li><a href=#3-碰撞避免策略>3. 碰撞避免策略</a></li><li><a href=#4-在线调整与反馈控制>4. 在线调整与反馈控制</a></li></ul></li><li><a href=#附录3-阵型变换过程中保证跟踪前方的轨迹点>附录3. 阵型变换过程中保证跟踪前方的轨迹点</a><ul><li><a href=#1-总体思路>1 总体思路</a></li><li><a href=#2-具体实施步骤>2. 具体实施步骤</a></li><li><a href=#3-示例实现c伪代码>3. 示例实现（C++伪代码）</a></li></ul></li><li><a href=#附录4-移动平均滤波器>附录4. 移动平均滤波器</a><ul><li><a href=#1-基本原理>1. 基本原理</a></li><li><a href=#2-数学模型和频率响应>2. 数学模型和频率响应</a></li><li><a href=#3-windowsize-的选取>3. windowSize 的选取</a></li><li><a href=#4-优点与缺点>4. 优点与缺点</a></li><li><a href=#5-应用场景>5. 应用场景</a></li><li><a href=#6-c-代码示例>6. C++ 代码示例</a></li></ul></li></ul></nav></div></div></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/index.html><span itemprop=name>FlitSoft Docs</span></a><meta itemprop=position content="1">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/uas/index.html><span itemprop=name>UAS</span></a><meta itemprop=position content="2">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><a itemprop=item href=/uas/formation-control/index.html><span itemprop=name>Formation Control</span></a><meta itemprop=position content="3">&nbsp;>&nbsp;</li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>无人机集群固定阵型轨迹生成模型</span><meta itemprop=position content="4"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/uas/formation-control/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%BC%96%E9%98%9F%E9%A3%9E%E8%A1%8C/index.html title="基于非线性模型预测控制的无人机编队飞行 (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/uas/formation-control/%E5%9B%BA%E5%AE%9A%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%98%B5%E5%9E%8B%E5%8F%98%E6%8D%A2%E8%BF%87%E6%B8%A1%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/index.html title="固定翼无人机阵型变换过渡轨迹生成 (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div><div class="topbar-button topbar-button-more" data-content-empty=hide data-width-s=show data-width-m=show data-width-l=show><button class=topbar-control onclick=toggleTopbarFlyout(this) type=button title=More><i class="fa-fw fas fa-ellipsis-v"></i></button><div class=topbar-content><div class=topbar-content-wrapper><div class="topbar-area topbar-area-more" data-area=more></div></div></div></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable uas" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=无人机集群固定阵型轨迹生成模型>无人机集群固定阵型轨迹生成模型</h1><p>版本：v2.0</p><h2 id=1-数学模型>1. 数学模型</h2><h3 id=11-主要变量定义>1.1 主要变量定义</h3><ul><li><p><strong>领航机状态</strong></p><ul><li>$ P_L(t) = \begin{bmatrix} x_L(t) \\ y_L(t) \end{bmatrix} $：领航机在全局坐标下的位置（可以是离散时间点序列或连续函数）。</li><li>$ \theta(t) $：领航机的航向角。</li></ul></li><li><p><strong>旋转矩阵</strong><br>为将局部偏移转换为全局坐标，定义旋转矩阵：</p>$$
R(\theta(t)) = \begin{bmatrix}
\cos \theta(t) & -\sin \theta(t) \\
  \sin \theta(t) & \cos \theta(t)
  \end{bmatrix}.
 $$</li><li><p><strong>局部偏移向量</strong><br>对于每个跟随 UAV $i$，在领航机局部坐标系中预先设计一个相对偏移向量：</p>$$
\Delta_i = \begin{bmatrix} \Delta_{i,x} \\ \Delta_{i,y} \end{bmatrix}.
$$<ul><li><p>对于<strong>线型阵型</strong>，可定义：</p>$$
\Delta_i = \begin{bmatrix} 0 \\ i \times d \end{bmatrix} \quad \text{或} \quad \Delta_i = \begin{bmatrix} i \times d_x \\ i \times d_y \end{bmatrix},
$$<p>其中 $d$（或 $d_x, d_y$）为预设间隔，正负号决定侧边。</p></li><li><p>对于<strong>楔形阵型</strong>（左右对称）：</p>$$
\Delta_{i,\text{左}} = \begin{bmatrix} i\,d_x \\ i\,d_y \end{bmatrix}, \quad
\Delta_{i,\text{右}} = \begin{bmatrix} i\,d_x \\ -i\,d_y \end{bmatrix}, \quad i=1,2,\ldots
$$</li></ul></li><li><p><strong>跟随 UAV 全局期望位置</strong><br>根据领航机的位置与航向，以及局部偏移，得到 UAV $i$ 的全局期望位置：</p>$$
P_i(t) = P_L(t) + R\big(\theta(t)\big) \Delta_i.
$$</li></ul><h3 id=12-动态约束扩展可选>1.2 动态约束扩展（可选）</h3><p>如果需要考虑 UAV 的运动学与动力学限制，可引入 UAV 的状态变量和动力学模型。以简单的平面运动模型为例：</p><ul><li>UAV $i$ 状态：$ X_i = \begin{bmatrix} x_i,\, y_i,\, \theta_i,\, v_i \end{bmatrix}^\top $</li><li>动力学模型：
$$
\begin{cases}
\dot{x}_i = v_i \cos \theta_i, \\
\dot{y}_i = v_i \sin \theta_i, \\
\dot{\theta}_i = u_i,
\end{cases}
$$
其中 $u_i$ 为控制输入（转向角速率）。设计合适的跟踪控制器，使得 UAV $i$ 能够跟踪参考轨迹 $P_i(t)$ 并满足转弯半径、加速度等约束。</li></ul><hr><h2 id=2-模型实现流程>2. 模型实现流程</h2><h3 id=21-模型框架>2.1 模型框架</h3><ol><li><p><strong>输入数据</strong></p><ul><li>领航机轨迹 $ P_L(t) $ 和航向 $ \theta(t) $。</li><li>阵型参数（类型、无人机数量、间距参数等）。</li></ul></li><li><p><strong>局部偏移生成</strong><br>根据阵型参数，为每个 UAV $i$ 计算局部偏移 $ \Delta_i $。<br>例如：</p><ul><li>线型阵型：$\Delta_i = \begin{bmatrix} 0 \\ i \times d \end{bmatrix}$</li><li>楔形阵型：根据左右分支分别计算 $\Delta_{i,\text{左}}$ 与 $\Delta_{i,\text{右}}$。</li></ul></li><li><p><strong>全局坐标转换</strong><br>对于每个 UAV $i$ 在每个时刻 $t$，计算全局期望位置：</p>$$
P_i(t) = P_L(t) + R\big(\theta(t)\big) \Delta_i.
$$</li><li><p><strong>轨迹平滑与动态可行性处理</strong></p><ul><li>对直接计算出的离散轨迹进行平滑处理（如样条插值、Bézier 曲线拟合等）。</li><li>根据 UAV 的运动学和动力学约束，通过轨迹优化或闭环控制器进行修正与跟踪。</li></ul></li><li><p><strong>输出</strong><br>生成所有 UAV 的期望轨迹，用于下层路径跟踪或控制器执行。</p></li></ol><h3 id=22-伪代码示例>2.2 伪代码示例</h3><p>下面的伪代码描述了整体流程，便于模型理解与实现：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 假设已获得领航机轨迹数据 leader_traj: list of (x, y, theta) 对</span>
</span></span><span style=display:flex><span><span style=color:#75715e># formation_params 包含阵型类型和相关间隔参数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>compute_rotation_matrix</span>(theta):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [[cos(theta), <span style=color:#f92672>-</span>sin(theta)],
</span></span><span style=display:flex><span>            [sin(theta),  cos(theta)]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>formation_offset</span>(i, formation_params, branch<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;center&#39;</span>):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    根据阵型参数计算第 i 架 UAV 的局部偏移。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    branch 参数用于楔形阵型：&#39;left&#39; 或 &#39;right&#39; 表示左右分支，
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#39;center&#39; 可用于线型或单边阵型。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> formation_params[<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;line&#39;</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 示例：所有 UAV 沿一侧，间隔 d</span>
</span></span><span style=display:flex><span>        d <span style=color:#f92672>=</span> formation_params[<span style=color:#e6db74>&#39;d&#39;</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>0</span>, i <span style=color:#f92672>*</span> d]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> formation_params[<span style=color:#e6db74>&#39;type&#39;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;wedge&#39;</span>:
</span></span><span style=display:flex><span>        d_x <span style=color:#f92672>=</span> formation_params[<span style=color:#e6db74>&#39;d_x&#39;</span>]
</span></span><span style=display:flex><span>        d_y <span style=color:#f92672>=</span> formation_params[<span style=color:#e6db74>&#39;d_y&#39;</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;left&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [i <span style=color:#f92672>*</span> d_x, i <span style=color:#f92672>*</span> d_y]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;right&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [i <span style=color:#f92672>*</span> d_x, <span style=color:#f92672>-</span>i <span style=color:#f92672>*</span> d_y]
</span></span><span style=display:flex><span>    <span style=color:#75715e># 可扩展其他阵型</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>smooth_trajectory</span>(traj):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 根据需求对轨迹进行平滑处理</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 例如使用样条曲线拟合</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traj  <span style=color:#75715e># 此处为占位函数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 主函数：生成所有 UAV 的期望轨迹</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_formation_trajectories</span>(leader_traj, formation_params, num_followers):
</span></span><span style=display:flex><span>    formation_trajs <span style=color:#f92672>=</span> {i: [] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, num_followers<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (x_L, y_L, theta) <span style=color:#f92672>in</span> leader_traj:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 计算旋转矩阵</span>
</span></span><span style=display:flex><span>        R <span style=color:#f92672>=</span> compute_rotation_matrix(theta)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># 遍历所有 UAV</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, num_followers<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#75715e># 根据阵型类型确定局部偏移，此处以线型为例，</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 若为楔形阵型，则需要区分左右分支</span>
</span></span><span style=display:flex><span>            Delta <span style=color:#f92672>=</span> formation_offset(i, formation_params, branch<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;center&#39;</span>)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e># 全局坐标转换：P_follower = P_leader + R * Delta</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 这里假设 R 与 Delta 均为列表或数组，进行矩阵向量乘法</span>
</span></span><span style=display:flex><span>            P_follower <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>                x_L <span style=color:#f92672>+</span> R[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> Delta[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> R[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> Delta[<span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>                y_L <span style=color:#f92672>+</span> R[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> Delta[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> R[<span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> Delta[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            formation_trajs[i]<span style=color:#f92672>.</span>append(P_follower)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 对每个 UAV 的轨迹进行平滑处理</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> formation_trajs:
</span></span><span style=display:flex><span>        formation_trajs[i] <span style=color:#f92672>=</span> smooth_trajectory(formation_trajs[i])
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> formation_trajs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 示例调用</span>
</span></span><span style=display:flex><span>leader_traj <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#75715e># (x, y, theta) 序列，实际数据由传感器或规划模块提供</span>
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    (<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e># ... 更多数据</span>
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>formation_params <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;type&#39;</span>: <span style=color:#e6db74>&#39;line&#39;</span>, <span style=color:#e6db74>&#39;d&#39;</span>: <span style=color:#ae81ff>5.0</span>}  <span style=color:#75715e># 线型阵型，每架 UAV 间隔 5 单位</span>
</span></span><span style=display:flex><span>num_followers <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>formation_trajectories <span style=color:#f92672>=</span> generate_formation_trajectories(leader_traj, formation_params, num_followers)</span></span></code></pre></div><hr><h2 id=3-模型说明>3. 模型说明</h2><ul><li><p><strong>模型通用性</strong><br>该模型统一采用“领航机轨迹 + 局部偏移”思想，不论阵型如何变化（线型、楔形、甚至更复杂的阵型），只需要在局部坐标系中设计合适的 $\Delta_i$ 即可。</p></li><li><p><strong>扩展性</strong><br>该模型可以方便地扩展至考虑 UAV 的运动学约束、路径平滑处理、实时反馈控制等问题，使得生成的期望轨迹既具备几何队形要求，又满足 UAV 的动态性能。</p></li><li><p><strong>实现细节</strong><br>程序员在实际实现时，可根据具体平台和需求替换平滑算法、矩阵运算库、控制器设计部分等，同时可结合实际采样时间离散化处理。</p></li></ul><hr><h2 id=4-c代码实现参考>4. C++代码实现参考</h2><h3 id=41-chatgpt-o3-mini-high>4.1 ChatGPT o3-mini-high</h3><p>下面给出 C++ 代码示例，将上述数学模型封装为一个类，便于集成到已有的无人机集群控制系统中。代码中定义了基本数据结构（位置、姿态、阵型参数等）、旋转操作、局部偏移计算以及生成全局期望轨迹的流程。同时，针对不同阵型（线型与楔形）给出不同的局部偏移计算方法。可以根据需要进一步扩展平滑处理或加入 UAV 的动态约束。</p><p>下面是完整示例代码：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------------- 数据结构定义 --------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 用于表示平面位置点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 表示无人机的位姿（位置和航向角）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Pose</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> theta; <span style=color:#75715e>// 航向角（弧度制）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 枚举不同的阵型类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationType</span> {
</span></span><span style=display:flex><span>    LINE,   <span style=color:#75715e>// 线型阵型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WEDGE   <span style=color:#75715e>// 楔形阵型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 阵型参数定义
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FormationParameters</span> {
</span></span><span style=display:flex><span>    FormationType type;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 线型阵型参数：两架 UAV 间的固定间隔（沿局部 y 轴方向）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> d;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 楔形阵型参数：沿航向方向间隔 d_x 及横向间隔 d_y
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> d_x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> d_y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------------- FormationGenerator 类 --------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @brief 生成跟随 UAV 的期望轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 利用领航机轨迹和阵型参数，在每个时刻计算每架跟随 UAV 的全局期望位置。
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationGenerator</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @brief 构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param leaderTrajectory 领航机轨迹（每个时刻的位姿）
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param formationParams 阵型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param numFollowers 跟随 UAV 数量
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    FormationGenerator(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Pose<span style=color:#f92672>&gt;&amp;</span> leaderTrajectory,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> FormationParameters<span style=color:#f92672>&amp;</span> formationParams,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>int</span> numFollowers)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> leaderTrajectory_(leaderTrajectory),
</span></span><span style=display:flex><span>          formationParams_(formationParams),
</span></span><span style=display:flex><span>          numFollowers_(numFollowers) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @brief 生成所有跟随 UAV 的轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 每个 UAV 的轨迹，外层 vector 下标对应 UAV 序号（从 0 开始），内层 vector 为轨迹点序列
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&gt;</span> generate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Pose<span style=color:#f92672>&gt;</span> leaderTrajectory_;
</span></span><span style=display:flex><span>    FormationParameters formationParams_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> numFollowers_;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @brief 对二维向量 (dx, dy) 根据角度 theta 进行旋转
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param dx 原向量 x 分量
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param dy 原向量 y 分量
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param theta 旋转角度（弧度制）
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 旋转后的向量
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    Point <span style=color:#a6e22e>rotatePoint</span>(<span style=color:#66d9ef>double</span> dx, <span style=color:#66d9ef>double</span> dy, <span style=color:#66d9ef>double</span> theta) {
</span></span><span style=display:flex><span>        Point rotated;
</span></span><span style=display:flex><span>        rotated.x <span style=color:#f92672>=</span> dx <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>cos(theta) <span style=color:#f92672>-</span> dy <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>sin(theta);
</span></span><span style=display:flex><span>        rotated.y <span style=color:#f92672>=</span> dx <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>sin(theta) <span style=color:#f92672>+</span> dy <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>cos(theta);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rotated;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @brief 根据阵型参数计算局部偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 对于线型阵型，所有 UAV 沿固定侧边（这里假设在局部 y 正方向）排列；
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 对于楔形阵型，则根据左右分支分别计算偏移。
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param followerIndex 当前 UAV 的编号（从 1 开始，线型阵型时直接使用；楔形阵型时用来计算排名）
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param branch 对于楔形阵型，“left”表示左侧分支，“right”表示右侧分支；线型阵型时可以忽略此参数
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 局部坐标系中的偏移向量
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    Point <span style=color:#a6e22e>computeLocalOffset</span>(<span style=color:#66d9ef>int</span> followerIndex, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> branch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;center&#34;</span>) {
</span></span><span style=display:flex><span>        Point offset{<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (formationParams_.type <span style=color:#f92672>==</span> FormationType<span style=color:#f92672>::</span>LINE) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 线型阵型：假设所有 UAV 沿局部 y 方向正侧边排列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            offset.x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>            offset.y <span style=color:#f92672>=</span> followerIndex <span style=color:#f92672>*</span> formationParams_.d;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (formationParams_.type <span style=color:#f92672>==</span> FormationType<span style=color:#f92672>::</span>WEDGE) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 楔形阵型：分别计算左右分支的局部偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;left&#34;</span>) {
</span></span><span style=display:flex><span>                offset.x <span style=color:#f92672>=</span> followerIndex <span style=color:#f92672>*</span> formationParams_.d_x;
</span></span><span style=display:flex><span>                offset.y <span style=color:#f92672>=</span> followerIndex <span style=color:#f92672>*</span> formationParams_.d_y;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;right&#34;</span>) {
</span></span><span style=display:flex><span>                offset.x <span style=color:#f92672>=</span> followerIndex <span style=color:#f92672>*</span> formationParams_.d_x;
</span></span><span style=display:flex><span>                offset.y <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>followerIndex <span style=color:#f92672>*</span> formationParams_.d_y;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> offset;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @brief 对生成的轨迹进行平滑处理
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * 目前为占位函数，可根据需要替换为样条、Bézier 曲线等算法
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param traj 原始轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return 平滑后的轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> smoothTrajectory(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&amp;</span> traj) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处直接返回原始轨迹，可根据实际需求实现平滑算法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> traj;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------------- FormationGenerator 方法实现 --------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&gt;</span> FormationGenerator<span style=color:#f92672>::</span>generate() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化每架跟随 UAV 的轨迹（编号从 0 到 numFollowers_-1）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&gt;</span> formationTrajectories(numFollowers_);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对领航机轨迹中的每个时刻，计算所有跟随 UAV 的期望位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> leaderPose : leaderTrajectory_) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于每架 UAV
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numFollowers_; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            Point localOffset;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (formationParams_.type <span style=color:#f92672>==</span> FormationType<span style=color:#f92672>::</span>WEDGE) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 对于楔形阵型，常采用左右对称的方式
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 例如：将 UAV 分为左右两支，按照索引交替分配
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 此处计算时，用 (i/2 + 1) 作为该分支中的排名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>int</span> rank <span style=color:#f92672>=</span> i <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>string branch <span style=color:#f92672>=</span> (i <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;left&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;right&#34;</span>;
</span></span><span style=display:flex><span>                localOffset <span style=color:#f92672>=</span> computeLocalOffset(rank, branch);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 对于线型阵型，直接使用 UAV 编号（从 1 开始）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                localOffset <span style=color:#f92672>=</span> computeLocalOffset(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;center&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 将局部偏移转换到全局坐标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Point rotated <span style=color:#f92672>=</span> rotatePoint(localOffset.x, localOffset.y, leaderPose.theta);
</span></span><span style=display:flex><span>            Point globalPos;
</span></span><span style=display:flex><span>            globalPos.x <span style=color:#f92672>=</span> leaderPose.x <span style=color:#f92672>+</span> rotated.x;
</span></span><span style=display:flex><span>            globalPos.y <span style=color:#f92672>=</span> leaderPose.y <span style=color:#f92672>+</span> rotated.y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            formationTrajectories[i].push_back(globalPos);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对每架 UAV 的轨迹进行平滑处理（如有需要）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> traj : formationTrajectories) {
</span></span><span style=display:flex><span>        traj <span style=color:#f92672>=</span> smoothTrajectory(traj);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> formationTrajectories;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------------- 示例主函数 --------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 示例：构造领航机轨迹数据（假设每个时刻的位姿信息）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Pose<span style=color:#f92672>&gt;</span> leaderTrajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>10.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>20.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>30.0</span>, <span style=color:#ae81ff>0.0</span>, M_PI <span style=color:#f92672>/</span> <span style=color:#ae81ff>6</span>},  <span style=color:#75715e>// 转弯示例，航向变为 30 度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {<span style=color:#ae81ff>40.0</span>, <span style=color:#ae81ff>5.0</span>, M_PI <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ... 可根据实际情况扩展数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 示例1：线型阵型，间隔 5.0 个单位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    FormationParameters lineParams;
</span></span><span style=display:flex><span>    lineParams.type <span style=color:#f92672>=</span> FormationType<span style=color:#f92672>::</span>LINE;
</span></span><span style=display:flex><span>    lineParams.d <span style=color:#f92672>=</span> <span style=color:#ae81ff>5.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 例如，3 架跟随 UAV
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> numFollowers <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    FormationGenerator lineFormationGenerator(leaderTrajectory, lineParams, numFollowers);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> lineTrajectories <span style=color:#f92672>=</span> lineFormationGenerator.generate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;线型阵型生成的跟随 UAV 轨迹：&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numFollowers; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UAV &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; 轨迹:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> pt : lineTrajectories[i]) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> pt.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pt.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;) &#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 示例2：楔形阵型，设置 d_x = 3.0, d_y = 2.0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    FormationParameters wedgeParams;
</span></span><span style=display:flex><span>    wedgeParams.type <span style=color:#f92672>=</span> FormationType<span style=color:#f92672>::</span>WEDGE;
</span></span><span style=display:flex><span>    wedgeParams.d_x <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>;
</span></span><span style=display:flex><span>    wedgeParams.d_y <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    FormationGenerator wedgeFormationGenerator(leaderTrajectory, wedgeParams, numFollowers);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> wedgeTrajectories <span style=color:#f92672>=</span> wedgeFormationGenerator.generate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>楔形阵型生成的跟随 UAV 轨迹：&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> numFollowers; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;UAV &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; 轨迹:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> pt : wedgeTrajectories[i]) {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> pt.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> pt.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;) &#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><hr><h4 id=代码说明>代码说明</h4><ol><li><p><strong>数据结构定义</strong></p><ul><li><code>Point</code> 与 <code>Pose</code> 分别用于表示二维点和带航向角的位姿。</li><li><code>FormationParameters</code> 中包含了两种阵型的相关参数（线型仅用 <code>d</code>；楔形则需要 <code>d_x</code> 和 <code>d_y</code>）。</li></ul></li><li><p><strong>FormationGenerator 类</strong></p><ul><li>构造时输入领航机轨迹、阵型参数和跟随 UAV 数量。</li><li>在 <code>generate()</code> 方法中，遍历每个时刻的领航机位姿，然后对每架跟随 UAV 根据不同阵型计算局部偏移，通过旋转转换到全局坐标系，最终生成每架 UAV 的轨迹。</li></ul></li><li><p><strong>阵型处理</strong></p><ul><li>线型阵型直接按照 UAV 编号（从 1 开始）在局部 y 方向设置偏移；</li><li>楔形阵型则采用左右分支（通过交替分配）的方式，使用 <code>(i/2+1)</code> 作为分支内的排名计算偏移。</li></ul></li><li><p><strong>扩展与集成</strong></p><ul><li>平滑函数 <code>smoothTrajectory</code> 目前为占位函数，可根据具体需求替换为样条或 Bézier 曲线等算法；</li><li>该模块化代码设计便于嵌入到已有的无人机集群控制模型中，并可根据需求进一步扩展（如加入 UAV 的运动学约束、实时控制等）。</li></ul></li></ol><p>以上代码可方便地将生成队形轨迹的模块与其它控制、规划模块进行集成，从而实现多架 UAV 协同飞行的功能。</p><h3 id=42-claude-35-sonnet>4.2 Claude 3.5 Sonnet</h3><p>以下为完整的C++代码实现：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// formation_control.hpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Eigen/Dense&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> uav {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 基础数据结构
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point2D</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Point2D(<span style=color:#66d9ef>double</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>double</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>:</span> x(x), y(y) {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Point2D <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> Point2D<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Point2D</span>(x <span style=color:#f92672>+</span> other.x, y <span style=color:#f92672>+</span> other.y);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UAVState</span> {
</span></span><span style=display:flex><span>    Point2D position;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> heading;  <span style=color:#75715e>// theta
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> velocity;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    UAVState(<span style=color:#66d9ef>const</span> Point2D<span style=color:#f92672>&amp;</span> pos <span style=color:#f92672>=</span> Point2D(), 
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>double</span> h <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>             <span style=color:#66d9ef>double</span> v <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> position(pos), heading(h), velocity(v) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 阵型类型枚举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationType</span> {
</span></span><span style=display:flex><span>    LINE,
</span></span><span style=display:flex><span>    WEDGE,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可扩展其他阵型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 阵型参数基类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationParams</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>FormationParams() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 线型阵型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LineFormationParams</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> FormationParams {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> spacing;  <span style=color:#75715e>// UAV间距
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>LineFormationParams</span>(<span style=color:#66d9ef>double</span> d) <span style=color:#f92672>:</span> spacing(d) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 楔形阵型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WedgeFormationParams</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> FormationParams {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dx;  <span style=color:#75715e>// 纵向间距
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> dy;  <span style=color:#75715e>// 横向间距
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    WedgeFormationParams(<span style=color:#66d9ef>double</span> dx, <span style=color:#66d9ef>double</span> dy) 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> dx(dx), dy(dy) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 旋转矩阵计算类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RotationMatrix</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Eigen<span style=color:#f92672>::</span>Matrix2d compute(<span style=color:#66d9ef>double</span> theta) {
</span></span><span style=display:flex><span>        Eigen<span style=color:#f92672>::</span>Matrix2d R;
</span></span><span style=display:flex><span>        R <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>cos(theta), <span style=color:#f92672>-</span>std<span style=color:#f92672>::</span>sin(theta),
</span></span><span style=display:flex><span>             std<span style=color:#f92672>::</span>sin(theta),  std<span style=color:#f92672>::</span>cos(theta);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> R;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 局部偏移计算类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationOffset</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Point2D compute(<span style=color:#66d9ef>int</span> uavIndex, 
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> FormationType<span style=color:#f92672>&amp;</span> type,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>FormationParams<span style=color:#f92672>&gt;&amp;</span> params,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> branch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;center&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (type) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> FormationType<span style=color:#f92672>::</span>LINE:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> computeLineOffset(uavIndex, 
</span></span><span style=display:flex><span>                    std<span style=color:#f92672>::</span>static_pointer_cast<span style=color:#f92672>&lt;</span>LineFormationParams<span style=color:#f92672>&gt;</span>(params));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> FormationType<span style=color:#f92672>::</span>WEDGE:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> computeWedgeOffset(uavIndex, 
</span></span><span style=display:flex><span>                    std<span style=color:#f92672>::</span>static_pointer_cast<span style=color:#f92672>&lt;</span>WedgeFormationParams<span style=color:#f92672>&gt;</span>(params),
</span></span><span style=display:flex><span>                    branch);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Point2D(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Point2D computeLineOffset(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> uavIndex, 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>LineFormationParams<span style=color:#f92672>&gt;&amp;</span> params) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Point2D</span>(<span style=color:#ae81ff>0</span>, uavIndex <span style=color:#f92672>*</span> params<span style=color:#f92672>-&gt;</span>spacing);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Point2D <span style=color:#a6e22e>computeWedgeOffset</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> uavIndex,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>WedgeFormationParams<span style=color:#f92672>&gt;&amp;</span> params,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> branch) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;left&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Point2D(uavIndex <span style=color:#f92672>*</span> params<span style=color:#f92672>-&gt;</span>dx, uavIndex <span style=color:#f92672>*</span> params<span style=color:#f92672>-&gt;</span>dy);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (branch <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;right&#34;</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> Point2D(uavIndex <span style=color:#f92672>*</span> params<span style=color:#f92672>-&gt;</span>dx, <span style=color:#f92672>-</span>uavIndex <span style=color:#f92672>*</span> params<span style=color:#f92672>-&gt;</span>dy);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Point2D(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 轨迹平滑器接口
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TrajectorySmoothing</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> smooth(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> rawTrajectory) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>TrajectorySmoothing() <span style=color:#f92672>=</span> <span style=color:#66d9ef>default</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 简单的轨迹平滑器实现（可扩展）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleSmoothing</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> TrajectorySmoothing {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> smooth(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> rawTrajectory) <span style=color:#66d9ef>override</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里可以实现具体的平滑算法，如样条插值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> rawTrajectory;  <span style=color:#75715e>// 当前仅返回原轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 队形控制器主类
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FormationController</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    FormationController(
</span></span><span style=display:flex><span>        FormationType type,
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>FormationParams<span style=color:#f92672>&gt;</span> params,
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TrajectorySmoothing<span style=color:#f92672>&gt;</span> smoother)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> formationType(type)
</span></span><span style=display:flex><span>        , formationParams(params)
</span></span><span style=display:flex><span>        , trajectorySmoother(smoother) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&gt;</span> generateFormationTrajectories(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> leaderTrajectory,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numFollowers) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&gt;</span> formationTrajs;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 为每个跟随者初始化轨迹容器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> numFollowers; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            formationTrajs[i] <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算每个时间点的队形位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> leaderState : leaderTrajectory) {
</span></span><span style=display:flex><span>            Eigen<span style=color:#f92672>::</span>Matrix2d R <span style=color:#f92672>=</span> RotationMatrix<span style=color:#f92672>::</span>compute(leaderState.heading);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> numFollowers; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 计算局部偏移
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Point2D localOffset <span style=color:#f92672>=</span> FormationOffset<span style=color:#f92672>::</span>compute(
</span></span><span style=display:flex><span>                    i, formationType, formationParams);
</span></span><span style=display:flex><span>                    
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 转换到全局坐标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Eigen<span style=color:#f92672>::</span>Vector2d localOffsetVec(localOffset.x, localOffset.y);
</span></span><span style=display:flex><span>                Eigen<span style=color:#f92672>::</span>Vector2d globalOffset <span style=color:#f92672>=</span> R <span style=color:#f92672>*</span> localOffsetVec;
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 计算跟随者位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Point2D <span style=color:#a6e22e>followerPos</span>(
</span></span><span style=display:flex><span>                    leaderState.position.x <span style=color:#f92672>+</span> globalOffset(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>                    leaderState.position.y <span style=color:#f92672>+</span> globalOffset(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 创建跟随者状态并添加到轨迹中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                UAVState <span style=color:#a6e22e>followerState</span>(
</span></span><span style=display:flex><span>                    followerPos,
</span></span><span style=display:flex><span>                    leaderState.heading,
</span></span><span style=display:flex><span>                    leaderState.velocity
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>                formationTrajs[i].push_back(followerState);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对所有轨迹进行平滑处理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> [uavId, trajectory] <span style=color:#f92672>:</span> formationTrajs) {
</span></span><span style=display:flex><span>            trajectory <span style=color:#f92672>=</span> trajectorySmoother<span style=color:#f92672>-&gt;</span>smooth(trajectory);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> formationTrajs;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    FormationType formationType;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>FormationParams<span style=color:#f92672>&gt;</span> formationParams;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>TrajectorySmoothing<span style=color:#f92672>&gt;</span> trajectorySmoother;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// namespace uav
</span></span></span></code></pre></div><h4 id=代码说明-1>代码说明</h4><ol><li><p><strong>模块化设计</strong>：</p><ul><li>使用命名空间<code>uav</code>隔离所有相关类和结构</li><li>每个主要组件都被设计为独立的类</li><li>使用继承和多态支持不同的阵型参数和平滑算法</li></ul></li><li><p><strong>关键组件</strong>：</p><ul><li><code>Point2D</code>和<code>UAVState</code>：基础数据结构</li><li><code>FormationType</code>和<code>FormationParams</code>：阵型配置</li><li><code>RotationMatrix</code>：旋转矩阵计算</li><li><code>FormationOffset</code>：局部偏移计算</li><li><code>TrajectorySmoothing</code>：轨迹平滑接口</li><li><code>FormationController</code>：主控制器类</li></ul></li><li><p><strong>扩展性考虑</strong>：</p><ul><li>可以轻松添加新的阵型类型</li><li>可以实现不同的轨迹平滑算法</li><li>使用智能指针管理对象生命周期</li></ul></li><li><p><strong>使用示例</strong>：</p></li></ol><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> uav;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建线型阵型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> lineParams <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>LineFormationParams<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>5.0</span>);  <span style=color:#75715e>// 5.0米间距
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建轨迹平滑器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>auto</span> smoother <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>SimpleSmoothing<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建队形控制器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>FormationController <span style=color:#a6e22e>controller</span>(
</span></span><span style=display:flex><span>    FormationType<span style=color:#f92672>::</span>LINE,
</span></span><span style=display:flex><span>    lineParams,
</span></span><span style=display:flex><span>    smoother
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 准备领航机轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> leaderTrajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    UAVState(Point2D(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>20</span>),  <span style=color:#75715e>// 位置(0,0)，航向0，速度20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UAVState(Point2D(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>), M_PI<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>20</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 更多轨迹点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 生成编队轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> numFollowers <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> formationTrajectories <span style=color:#f92672>=</span> controller.generateFormationTrajectories(
</span></span><span style=display:flex><span>    leaderTrajectory,
</span></span><span style=display:flex><span>    numFollowers
</span></span><span style=display:flex><span>);</span></span></code></pre></div><p>要将这个代码集成到现有系统中，你需要：</p><ol><li>将代码放入适当的头文件和源文件中</li><li>确保你的项目中包含了Eigen库</li><li>根据需要实现具体的轨迹平滑算法</li><li>根据实际需求扩展其他阵型类型</li></ol><p>这个实现保持了原始数学模型的结构，同时提供了良好的面向对象封装和扩展性。你可以根据具体需求进行进一步的定制和优化。</p><h2 id=附录1-轨迹跟踪实现参考示例>附录1. 轨迹跟踪实现参考示例</h2><p>下面按步进仿真方式，使轨迹跟踪模型能够实时跟踪生成的期望轨迹。核心思想是：在每个仿真时间步内，根据当前 UAV 状态与期望轨迹（由上一个模块生成）的参考点计算误差，然后利用控制器（例如 PID、纯跟踪算法 Pure Pursuit、MPC 等）计算控制指令，再利用 UAV 的运动学或动力学模型对状态进行更新。下面给出一个简单示例，说明如何实现这一流程。</p><hr><h3 id=1-按步进仿真的基本流程>1. 按步进仿真的基本流程</h3><ol><li><p><strong>初始化</strong></p><ul><li>定义仿真参数：总仿真时间 $T$ 和步长 $dt$；</li><li>初始化 UAV 当前状态（位置、航向角、速度等）；</li><li>导入或生成参考轨迹（生成的队形轨迹），通常为一系列带时间标签的轨迹点。</li></ul></li><li><p><strong>主仿真循环</strong><br>在每个时间步 $t$ 内，执行以下步骤：</p><ul><li><strong>（a）查找参考点</strong><br>根据当前仿真时间 $t$ 从参考轨迹中提取或插值得到期望状态（位置、航向角等）。</li><li><strong>（b）计算误差</strong><br>对比 UAV 当前状态和参考状态，计算位置误差、航向误差等。</li><li><strong>（c）控制器计算</strong><br>将误差输入控制器，生成控制命令（例如航向角速率、油门指令或其他控制变量）。</li><li><strong>（d）状态更新</strong><br>根据 UAV 的运动学/动力学模型（例如简单的 kinematic 模型或更复杂的动力学模型），使用离散积分方法（如欧拉积分或 Runge-Kutta 方法）更新 UAV 的状态。</li><li><strong>（e）记录数据</strong><br>保存 UAV 当前状态、控制命令以及误差信息，便于后续分析和可视化。</li></ul></li><li><p><strong>仿真结束</strong><br>当仿真时间达到预设时间后结束，并输出仿真数据或轨迹图以便评估跟踪效果。</p></li></ol><hr><h3 id=2-chatgpt-o3-mini-high-示例代码c>2. ChatGPT o3-mini-high 示例代码（C++）</h3><p>下面给出一个简化的 C++ 示例代码，该代码展示了如何在仿真主循环中让一个简单的 PID 跟踪控制器跟踪参考轨迹。注意：代码中的 UAV 动力学模型采用简单的平面运动 kinematic 模型，实际应用中可能需要更复杂的模型。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------- 数据结构定义 --------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// UAV 状态（位置、航向角、速度）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UAVState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> theta; <span style=color:#75715e>// 航向角（弧度）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> v;     <span style=color:#75715e>// 速度（假设保持恒定或可控制）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 期望轨迹点（含时间标签）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TrajectoryPoint</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> t;     <span style=color:#75715e>// 时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> theta; <span style=color:#75715e>// 期望航向角（可选）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------- PID 控制器 --------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PIDController</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    PIDController(<span style=color:#66d9ef>double</span> kp, <span style=color:#66d9ef>double</span> ki, <span style=color:#66d9ef>double</span> kd)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> kp_(kp), ki_(ki), kd_(kd), prevError_(<span style=color:#ae81ff>0.0</span>), integral_(<span style=color:#ae81ff>0.0</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 输入误差，输出控制命令（例如：航向角速率或角度修正）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>compute</span>(<span style=color:#66d9ef>double</span> error, <span style=color:#66d9ef>double</span> dt) {
</span></span><span style=display:flex><span>        integral_ <span style=color:#f92672>+=</span> error <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> derivative <span style=color:#f92672>=</span> (error <span style=color:#f92672>-</span> prevError_) <span style=color:#f92672>/</span> dt;
</span></span><span style=display:flex><span>        prevError_ <span style=color:#f92672>=</span> error;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> kp_ <span style=color:#f92672>*</span> error <span style=color:#f92672>+</span> ki_ <span style=color:#f92672>*</span> integral_ <span style=color:#f92672>+</span> kd_ <span style=color:#f92672>*</span> derivative;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> kp_, ki_, kd_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> prevError_;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> integral_;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------- 辅助函数 --------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 将角度差归一化到 [-pi, pi]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>normalizeAngle</span>(<span style=color:#66d9ef>double</span> angle) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (angle <span style=color:#f92672>&gt;</span> M_PI)
</span></span><span style=display:flex><span>        angle <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> M_PI;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (angle <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>M_PI)
</span></span><span style=display:flex><span>        angle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> M_PI;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> angle;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 根据当前 UAV 状态和期望轨迹点，计算航向角误差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>computeHeadingError</span>(<span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> current, <span style=color:#66d9ef>const</span> TrajectoryPoint<span style=color:#f92672>&amp;</span> desired) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算从当前点指向参考点的角度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> desiredTheta <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>atan2(desired.y <span style=color:#f92672>-</span> current.y, desired.x <span style=color:#f92672>-</span> current.x);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> error <span style=color:#f92672>=</span> normalizeAngle(desiredTheta <span style=color:#f92672>-</span> current.theta);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> error;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 简单的 UAV 状态更新函数（基于 kinematic 模型）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>UAVState <span style=color:#a6e22e>updateState</span>(<span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> current, <span style=color:#66d9ef>double</span> controlCommand, <span style=color:#66d9ef>double</span> dt) {
</span></span><span style=display:flex><span>    UAVState next <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 假设 controlCommand 为航向角速率控制输入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    next.theta <span style=color:#f92672>+=</span> controlCommand <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>    next.theta <span style=color:#f92672>=</span> normalizeAngle(next.theta);
</span></span><span style=display:flex><span>    next.x <span style=color:#f92672>+=</span> current.v <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>cos(next.theta) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>    next.y <span style=color:#f92672>+=</span> current.v <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>sin(next.theta) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> next;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// -------------------- 主仿真程序 --------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 1. 初始化仿真参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> simulationTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>; <span style=color:#75715e>// 总仿真时间（秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> dt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.1</span>;              <span style=color:#75715e>// 时间步长（秒）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> currentTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. 初始化 UAV 状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UAVState uav <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>5.0</span>}; <span style=color:#75715e>// 初始位置 (0,0), 航向 0, 速度 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. 定义参考轨迹（生成的轨迹）——示例数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>TrajectoryPoint<span style=color:#f92672>&gt;</span> refTrajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>4.0</span>, <span style=color:#ae81ff>4.0</span>, <span style=color:#ae81ff>4.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>6.0</span>, <span style=color:#ae81ff>6.0</span>, <span style=color:#ae81ff>6.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>8.0</span>, <span style=color:#ae81ff>8.0</span>, <span style=color:#ae81ff>8.0</span>, <span style=color:#ae81ff>0.0</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>10.0</span>, <span style=color:#ae81ff>10.0</span>, <span style=color:#ae81ff>10.0</span>, <span style=color:#ae81ff>0.0</span>}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 4. 初始化 PID 控制器参数（调试时根据需要调整）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    PIDController pid(<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 5. 仿真主循环（按步进运行）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (currentTime <span style=color:#f92672>&lt;=</span> simulationTime) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.1 根据当前时间获取参考轨迹点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 此处简单选取离当前时间最近的点（可改为线性插值）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        TrajectoryPoint desired <span style=color:#f92672>=</span> refTrajectory.back();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> point : refTrajectory) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (point.t <span style=color:#f92672>&gt;=</span> currentTime) {
</span></span><span style=display:flex><span>                desired <span style=color:#f92672>=</span> point;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.2 计算跟踪误差（这里以航向角误差为例）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> headingError <span style=color:#f92672>=</span> computeHeadingError(uav, desired);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.3 控制器计算，输出控制命令（例如航向角速率）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> controlCommand <span style=color:#f92672>=</span> pid.compute(headingError, dt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.4 更新 UAV 状态（状态更新函数可以根据 UAV 动力学进行扩展）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        uav <span style=color:#f92672>=</span> updateState(uav, controlCommand, dt);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.5 输出当前状态与参考信息，便于观察跟踪效果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Time: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> currentTime
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | UAV: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.theta <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | Ref: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> desired.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> desired.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | Heading Error: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> headingError
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 5.6 更新时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        currentTime <span style=color:#f92672>+=</span> dt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><hr><h4 id=代码说明-2>代码说明</h4><ul><li><p><strong>数据结构</strong></p><ul><li><code>UAVState</code> 定义了无人机当前的状态信息；</li><li><code>TrajectoryPoint</code> 包含参考轨迹点和对应的时间标签（实际应用中可以更精细，如包含速度、加速度等）。</li></ul></li><li><p><strong>控制器部分</strong></p><ul><li>使用一个简单的 PID 控制器计算航向角误差，从而生成控制指令。</li><li>这里的误差采用当前 UAV 指向参考点的期望航向角与实际航向角的差值。</li></ul></li><li><p><strong>状态更新</strong></p><ul><li><code>updateState</code> 函数基于简单的平面运动 kinematic 模型，利用欧拉积分方法更新状态。</li><li>在实际应用中，可根据 UAV 的动力学特性采用更精确的积分方法。</li></ul></li><li><p><strong>仿真循环</strong></p><ul><li>在每个时间步中，从参考轨迹中找到当前时间对应的期望状态（这里采用最简单的方法，实际可采用插值）；</li><li>计算误差、得到控制命令，再更新状态。整个过程按 dt 进行迭代，完成仿真。</li></ul></li></ul><hr><h4 id=实际集成注意事项>实际集成注意事项</h4><ul><li><p><strong>轨迹插值</strong><br>如果生成的参考轨迹时间间隔较大，建议采用线性或样条插值，获得更平滑的期望状态。</p></li><li><p><strong>控制器选择</strong><br>根据 UAV 的动力学和任务需求，可以选择更为复杂的控制器（如 MPC、纯跟踪算法 Pure Pursuit、Backstepping 等）。</p></li><li><p><strong>模型匹配</strong><br>跟踪模型应与 UAV 实际动态特性相匹配，在仿真中可能需要考虑加速度、侧向动力学等因素。</p></li><li><p><strong>实时性</strong><br>当将该模型集成到实际无人机控制系统时，要确保控制器计算和状态更新能够满足实时要求。</p></li></ul><hr><p>通过以上步骤和示例代码，可以在仿真程序中，使轨迹跟踪模型实时跟踪生成的参考轨迹，从而验证和优化 UAV 队形飞行控制策略。</p><h3 id=3-claude-35-sonnet-示例代码c>3. Claude 3.5 Sonnet 示例代码（C++）</h3><p>以下为Claude 3.5 Sonnet生成的的轨迹跟踪控制器C++代码，用于仿真环境中跟踪上述生成的编队轨迹。</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>// trajectory_tracking.hpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Eigen/Dense&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;formation_control.hpp&#34;</span><span style=color:#75715e>  </span><span style=color:#75715e>// 引用之前的编队控制代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> uav {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// UAV动力学模型参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UAVDynamicsParams</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> max_velocity;        <span style=color:#75715e>// 最大速度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> min_velocity;        <span style=color:#75715e>// 最小速度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> max_acceleration;    <span style=color:#75715e>// 最大加速度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> max_yaw_rate;       <span style=color:#75715e>// 最大偏航角速率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> control_frequency;   <span style=color:#75715e>// 控制频率 (Hz)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    UAVDynamicsParams(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> maxV <span style=color:#f92672>=</span> <span style=color:#ae81ff>30.0</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> minV <span style=color:#f92672>=</span> <span style=color:#ae81ff>15.0</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> maxA <span style=color:#f92672>=</span> <span style=color:#ae81ff>5.0</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> maxYaw <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> freq <span style=color:#f92672>=</span> <span style=color:#ae81ff>50.0</span>
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>:</span> max_velocity(maxV),
</span></span><span style=display:flex><span>        min_velocity(minV),
</span></span><span style=display:flex><span>        max_acceleration(maxA),
</span></span><span style=display:flex><span>        max_yaw_rate(maxYaw),
</span></span><span style=display:flex><span>        control_frequency(freq) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 轨迹跟踪控制器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TrajectoryTracker</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TrajectoryTracker(<span style=color:#66d9ef>const</span> UAVDynamicsParams<span style=color:#f92672>&amp;</span> params)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> dynamics_params(params)
</span></span><span style=display:flex><span>        , dt(<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> params.control_frequency)
</span></span><span style=display:flex><span>        , current_index(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// PID控制器增益
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        pid_gains <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>2.0</span>,  <span style=color:#75715e>// Kp for heading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>0.1</span>,  <span style=color:#75715e>// Ki for heading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>0.5</span>,  <span style=color:#75715e>// Kd for heading
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>1.0</span>,  <span style=color:#75715e>// Kp for velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>0.1</span>,  <span style=color:#75715e>// Ki for velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>0.2</span>   <span style=color:#75715e>// Kd for velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置目标轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setTrajectory</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> trajectory) {
</span></span><span style=display:flex><span>        reference_trajectory <span style=color:#f92672>=</span> trajectory;
</span></span><span style=display:flex><span>        current_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        resetPIDErrors();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新UAV状态（单步仿真）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UAVState <span style=color:#a6e22e>updateState</span>(<span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> current_state) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current_index <span style=color:#f92672>&gt;=</span> reference_trajectory.size()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> current_state;  <span style=color:#75715e>// 轨迹已完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取参考状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> reference <span style=color:#f92672>=</span> reference_trajectory[current_index];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算误差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> dx <span style=color:#f92672>=</span> reference.position.x <span style=color:#f92672>-</span> current_state.position.x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> dy <span style=color:#f92672>=</span> reference.position.y <span style=color:#f92672>-</span> current_state.position.y;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> distance_error <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>sqrt(dx <span style=color:#f92672>*</span> dx <span style=color:#f92672>+</span> dy <span style=color:#f92672>*</span> dy);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算期望航向角
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> desired_heading <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>atan2(dy, dx);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> heading_error <span style=color:#f92672>=</span> normalizeAngle(desired_heading <span style=color:#f92672>-</span> current_state.heading);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新PID误差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        updatePIDErrors(heading_error, distance_error);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算控制输入
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> yaw_rate <span style=color:#f92672>=</span> computeHeadingControl();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> velocity <span style=color:#f92672>=</span> computeVelocityControl(distance_error);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 应用动力学约束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        yaw_rate <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>clamp(yaw_rate, 
</span></span><span style=display:flex><span>            <span style=color:#f92672>-</span>dynamics_params.max_yaw_rate,
</span></span><span style=display:flex><span>            dynamics_params.max_yaw_rate);
</span></span><span style=display:flex><span>        velocity <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>clamp(velocity,
</span></span><span style=display:flex><span>            dynamics_params.min_velocity,
</span></span><span style=display:flex><span>            dynamics_params.max_velocity);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 更新状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        UAVState new_state;
</span></span><span style=display:flex><span>        new_state.heading <span style=color:#f92672>=</span> normalizeAngle(
</span></span><span style=display:flex><span>            current_state.heading <span style=color:#f92672>+</span> yaw_rate <span style=color:#f92672>*</span> dt);
</span></span><span style=display:flex><span>        new_state.velocity <span style=color:#f92672>=</span> velocity;
</span></span><span style=display:flex><span>        new_state.position.x <span style=color:#f92672>=</span> current_state.position.x <span style=color:#f92672>+</span> 
</span></span><span style=display:flex><span>            velocity <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>cos(new_state.heading) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        new_state.position.y <span style=color:#f92672>=</span> current_state.position.y <span style=color:#f92672>+</span> 
</span></span><span style=display:flex><span>            velocity <span style=color:#f92672>*</span> std<span style=color:#f92672>::</span>sin(new_state.heading) <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查是否需要切换到下一个轨迹点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (distance_error <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1.0</span>) {  <span style=color:#75715e>// 1.0米阈值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            current_index<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> new_state;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    UAVDynamicsParams dynamics_params;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> reference_trajectory;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> pid_gains;  <span style=color:#75715e>// [Kp_h, Ki_h, Kd_h, Kp_v, Ki_v, Kd_v]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dt;
</span></span><span style=display:flex><span>    size_t current_index;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// PID控制器状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> heading_error_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> heading_error_prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> velocity_error_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> velocity_error_prev <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    } pid_state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>resetPIDErrors</span>() {
</span></span><span style=display:flex><span>        pid_state <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updatePIDErrors</span>(<span style=color:#66d9ef>double</span> heading_error, <span style=color:#66d9ef>double</span> distance_error) {
</span></span><span style=display:flex><span>        pid_state.heading_error_sum <span style=color:#f92672>+=</span> heading_error <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>        pid_state.velocity_error_sum <span style=color:#f92672>+=</span> distance_error <span style=color:#f92672>*</span> dt;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>computeHeadingControl</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> p_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> normalizeAngle(
</span></span><span style=display:flex><span>            reference_trajectory[current_index].heading <span style=color:#f92672>-</span> 
</span></span><span style=display:flex><span>            pid_state.heading_error_prev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> i_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> pid_state.heading_error_sum;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>*</span> (normalizeAngle(
</span></span><span style=display:flex><span>            reference_trajectory[current_index].heading <span style=color:#f92672>-</span> 
</span></span><span style=display:flex><span>            pid_state.heading_error_prev) <span style=color:#f92672>/</span> dt);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> p_term <span style=color:#f92672>+</span> i_term <span style=color:#f92672>+</span> d_term;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>computeVelocityControl</span>(<span style=color:#66d9ef>double</span> distance_error) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> p_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>*</span> distance_error;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> i_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>4</span>] <span style=color:#f92672>*</span> pid_state.velocity_error_sum;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d_term <span style=color:#f92672>=</span> pid_gains[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span>            (distance_error <span style=color:#f92672>-</span> pid_state.velocity_error_prev) <span style=color:#f92672>/</span> dt;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> reference_trajectory[current_index].velocity <span style=color:#f92672>+</span> 
</span></span><span style=display:flex><span>            p_term <span style=color:#f92672>+</span> i_term <span style=color:#f92672>+</span> d_term;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将角度归一化到[-π, π]范围
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>normalizeAngle</span>(<span style=color:#66d9ef>double</span> angle) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (angle <span style=color:#f92672>&gt;</span> M_PI) angle <span style=color:#f92672>-=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> M_PI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (angle <span style=color:#f92672>&lt;</span> <span style=color:#f92672>-</span>M_PI) angle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> M_PI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> angle;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 仿真管理器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimulationManager</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    SimulationManager(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> UAVDynamicsParams<span style=color:#f92672>&amp;</span> params,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> leader_trajectory,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> num_followers)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> dynamics_params(params)
</span></span><span style=display:flex><span>        , num_uavs(num_followers <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)  <span style=color:#75715e>// 包括领航机
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 创建编队控制器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> formation_params <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>LineFormationParams<span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>5.0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> smoother <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>SimpleSmoothing<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>        formation_controller <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>FormationController<span style=color:#f92672>&gt;</span>(
</span></span><span style=display:flex><span>            FormationType<span style=color:#f92672>::</span>LINE,
</span></span><span style=display:flex><span>            formation_params,
</span></span><span style=display:flex><span>            smoother
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 生成编队轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> formation_trajectories <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>            formation_controller<span style=color:#f92672>-&gt;</span>generateFormationTrajectories(
</span></span><span style=display:flex><span>                leader_trajectory,
</span></span><span style=display:flex><span>                num_followers
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 为每个UAV创建轨迹跟踪器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        trackers.push_back(std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>TrajectoryTracker<span style=color:#f92672>&gt;</span>(params));
</span></span><span style=display:flex><span>        trackers[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-&gt;</span>setTrajectory(leader_trajectory);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> num_followers; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            trackers.push_back(std<span style=color:#f92672>::</span>make_unique<span style=color:#f92672>&lt;</span>TrajectoryTracker<span style=color:#f92672>&gt;</span>(params));
</span></span><span style=display:flex><span>            trackers[i]<span style=color:#f92672>-&gt;</span>setTrajectory(formation_trajectories[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 初始化UAV状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        current_states.resize(num_uavs);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_uavs; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                current_states[i] <span style=color:#f92672>=</span> leader_trajectory[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                current_states[i] <span style=color:#f92672>=</span> formation_trajectories[i][<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 单步仿真
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stepSimulation</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> num_uavs; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            current_states[i] <span style=color:#f92672>=</span> trackers[i]<span style=color:#f92672>-&gt;</span>updateState(current_states[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前所有UAV状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;&amp;</span> getCurrentStates() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> current_states;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    UAVDynamicsParams dynamics_params;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> num_uavs;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>FormationController<span style=color:#f92672>&gt;</span> formation_controller;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>unique_ptr<span style=color:#f92672>&lt;</span>TrajectoryTracker<span style=color:#f92672>&gt;&gt;</span> trackers;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> current_states;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// namespace uav
</span></span></span></code></pre></div><h4 id=代码说明-3>代码说明</h4><p>这个实现提供了完整的轨迹跟踪功能。主要包含以下组件：</p><ol><li><p><strong>TrajectoryTracker类</strong>：</p><ul><li>实现PID控制的轨迹跟踪器</li><li>考虑了无人机动力学约束</li><li>提供航向角和速度控制</li><li>支持实时状态更新</li></ul></li><li><p><strong>SimulationManager类</strong>：</p><ul><li>管理整个仿真过程</li><li>集成编队控制和轨迹跟踪</li><li>提供统一的仿真步进接口</li></ul></li></ol><h4 id=使用示例>使用示例</h4><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> uav;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建动力学参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>UAVDynamicsParams <span style=color:#a6e22e>params</span>(
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>30.0</span>,  <span style=color:#f92672>//</span> <span style=color:#960050;background-color:#1e0010>最大速度</span> (m<span style=color:#f92672>/</span>s)
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>15.0</span>,  <span style=color:#75715e>// 最小速度 (m/s)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>5.0</span>,   <span style=color:#75715e>// 最大加速度 (m/s^2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0.5</span>,   <span style=color:#75715e>// 最大偏航角速率 (rad/s)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>50.0</span>   <span style=color:#75715e>// 控制频率 (Hz)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建领航机轨迹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>UAVState<span style=color:#f92672>&gt;</span> leader_trajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    UAVState(Point2D(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>20</span>),
</span></span><span style=display:flex><span>    UAVState(Point2D(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>0</span>), <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>20</span>),
</span></span><span style=display:flex><span>    UAVState(Point2D(<span style=color:#ae81ff>200</span>, <span style=color:#ae81ff>50</span>), M_PI<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>20</span>),
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... 更多轨迹点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 创建仿真管理器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>SimulationManager <span style=color:#a6e22e>sim</span>(params, leader_trajectory, <span style=color:#ae81ff>3</span>);  <span style=color:#75715e>// 3个跟随者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 仿真主循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> sim_time <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> sim_duration <span style=color:#f92672>=</span> <span style=color:#ae81ff>100.0</span>;  <span style=color:#75715e>// 仿真100秒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (sim_time <span style=color:#f92672>&lt;</span> sim_duration) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新仿真
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sim.stepSimulation();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> states <span style=color:#f92672>=</span> sim.getCurrentStates();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 可以在这里添加可视化或数据记录代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> state : states) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Position: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> state.position.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> 
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> state.position.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    sim_time <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> params.control_frequency;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>该实现的特点：</p><ol><li><p><strong>模块化设计</strong>：</p><ul><li>轨迹跟踪和仿真管理分离</li><li>便于集成到更大的系统中</li></ul></li><li><p><strong>完整的控制流程</strong>：</p><ul><li>包含PID控制器</li><li>考虑动力学约束</li><li>支持连续轨迹跟踪</li></ul></li><li><p><strong>可扩展性</strong>：</p><ul><li>可以轻松添加新的控制算法</li><li>支持不同的编队形式</li><li>可以集成其他动力学模型</li></ul></li><li><p><strong>仿真友好</strong>：</p><ul><li>支持步进式仿真</li><li>便于数据记录和可视化</li><li>支持多机协同仿真</li></ul></li></ol><p>要根据具体需求使用这个代码，你可能需要：</p><ol><li>调整PID控制器参数</li><li>添加具体的可视化代码</li><li>根据实际无人机性能修改动力学参数</li><li>添加数据记录和分析功能</li></ol><h2 id=附录2-阵型过渡过程中需注意的问题>附录2. 阵型过渡过程中需注意的问题</h2><p>在阵型变换过程中，要实现高效过渡并尽量避免碰撞，通常需要从规划、协调、以及实时调整等多个层面考虑。</p><p>在阵型变换过程中，为了高效实现过渡并尽量避免碰撞，建议采取以下综合策略：</p><ol><li><strong>最优任务分配</strong>：合理分配每架 UAV 的目标位置，避免路径交叉。</li><li><strong>平滑、时间参数化的轨迹规划</strong>：利用曲线规划方法生成连续且满足 UAV 动力学要求的轨迹，并在时间上合理错开 UAV 的通过时刻。</li><li><strong>碰撞约束与局部避碰</strong>：在全局规划中融入碰撞约束，并设置局部避碰机制应对意外情况。</li><li><strong>分布式协调与实时反馈</strong>：通过 UAV 间信息共享和实时控制，确保在过渡过程中各 UAV 能够协同调整，维持安全距离。</li></ol><p>采用上述方法可以有效降低阵型变换过程中 UAV 路径交叉和碰撞的风险，同时兼顾变换效率，适应动态变化的任务需求。</p><hr><h3 id=1-任务分配与目标匹配>1. 任务分配与目标匹配</h3><ul><li><p><strong>目标分配优化</strong><br>在变换开始前，可以采用最优匹配算法（如匈牙利算法）为每架 UAV 分配目标位置，确保总行程最短且避免交叉路径。这样可以减少 UAV 间路径交叉和冲突的可能性。</p></li><li><p><strong>考虑队形间相对顺序</strong><br>保持 UAV 在队形内的相对顺序，减少路径交叉。例如，可以固定部分 UAV 的相对位置，仅让少数 UAV 调整位置，从而降低整体碰撞风险。</p></li></ul><hr><h3 id=2-过渡轨迹生成>2. 过渡轨迹生成</h3><ul><li><p><strong>平滑轨迹规划</strong><br>利用样条曲线、Bézier 曲线或者多项式轨迹规划方法，在初始和目标位置之间生成连续、光滑的过渡轨迹。平滑轨迹有助于满足 UAV 的动力学约束（如最小转弯半径）并减少急剧变换。</p></li><li><p><strong>时间参数化</strong><br>为每个 UAV 的过渡轨迹增加时间标记，使得 UAV 在不同时间段通过各自的过渡区域。通过时间同步控制，协调各 UAV 的速度和加速度，降低在同一区域同时出现的风险。</p></li><li><p><strong>分段规划与缓冲区域</strong><br>可以将过渡过程划分为多个阶段，每个阶段先完成局部队形调整，且在关键转折点设置缓冲区域，给 UAV 足够的时间和空间避开临近 UAV。</p></li></ul><hr><h3 id=3-碰撞避免策略>3. 碰撞避免策略</h3><ul><li><p><strong>优化中加入碰撞约束</strong><br>在轨迹规划的优化问题中，引入 UAV 间最小安全距离作为约束条件。利用诸如序列二次规划（SQP）、模型预测控制（MPC）等方法，将碰撞约束融入全局轨迹规划中，生成满足动态约束且避免碰撞的轨迹。</p></li><li><p><strong>局部避碰机制</strong><br>在 UAV 实际飞行中，可实时监测 UAV 间距离，当检测到潜在碰撞风险时，触发局部避碰策略（如小幅偏离、减速或暂停），保证 UAV 在短时间内不进入危险区域。<br>这种局部避碰可以基于传感器反馈和简单的控制规则实现，也可以采用基于人工势场的方法进行动态调整。</p></li><li><p><strong>分布式协调规划</strong><br>每架 UAV 根据自身状态和邻近 UAV 的信息进行局部轨迹调整，并通过通信协调形成一致的全局变换。分布式方法能提高鲁棒性和响应速度，特别适用于大规模 UAV 队形。</p></li></ul><hr><h3 id=4-在线调整与反馈控制>4. 在线调整与反馈控制</h3><ul><li><p><strong>实时反馈机制</strong><br>在 UAV 跟踪预定过渡轨迹时，利用实时状态反馈对轨迹进行动态修正。结合预测模型，当检测到轨迹偏离或潜在碰撞时，及时调整控制命令以恢复安全状态。</p></li><li><p><strong>速度与加速度调控</strong><br>根据过渡区域内 UAV 密度及环境风险，适时降低速度或调整加速度，为轨迹变换留出更多冗余时间，降低因速度过快导致的碰撞风险。</p></li></ul><hr><h2 id=附录3-阵型变换过程中保证跟踪前方的轨迹点>附录3. 阵型变换过程中保证跟踪前方的轨迹点</h2><p>通过在轨迹规划阶段设计正向偏置，并在 UAV 跟踪控制中采用前瞻参考点选择算法（结合距离和几何判断），可以有效保证阵型过渡过程中每架固定翼 UAV 的期望轨迹点始终位于前进方向前，从而满足固定翼 UAV 的飞行动态要求，并降低因目标点选择不当引起的跟踪误差或碰撞风险。</p><p>下面给出的实施方案，旨在确保在阵型过渡过程中，每架固定翼 UAV 的期望轨迹点始终位于其前进方向前，而不是后方。方案分为以下几个步骤：</p><hr><h3 id=1-总体思路>1 总体思路</h3><ol><li><p><strong>轨迹规划时的正向设计</strong></p><ul><li><strong>生成平滑过渡轨迹</strong>：在生成从初始（横排）到目标（楔形）状态的平滑轨迹时，采用局部坐标系，其中 x 轴代表 UAV 前进方向，保证轨迹点在局部坐标系中 x 坐标单调递增。</li><li><strong>预留前向偏置</strong>：在规划过程中，对每个 UAV 的轨迹施加正向偏置，确保轨迹整体延伸于 UAV 前方。</li></ul></li><li><p><strong>前瞻（Lookahead）参考点选择</strong></p><ul><li><strong>前瞻距离设定</strong>：定义一个合适的前瞻距离 $ L $（例如 10～20 米），保证 UAV 跟踪时总是选择距离当前位置大于 $ L $ 的参考点。</li><li><strong>几何判断</strong>：在实时跟踪时，利用当前 UAV 状态计算其前进方向（通常通过当前航向角得到前向单位向量 $\vec{v}=(\cos\theta,\sin\theta)$），然后从预先规划好的轨迹中选取满足：<ul><li>距离当前 UAV 位置大于 $ L $，以及</li><li>向量 $ \vec{w}= $（候选点位置 $-$ UAV 当前位置）的点积 $ \vec{v}\cdot\vec{w} > 0 $（确保候选点在 UAV 前方）<br>的轨迹点作为参考点。</li></ul></li></ul></li><li><p><strong>实时检测与调整</strong></p><ul><li><strong>动态监控</strong>：在每个仿真时间步内，实时检测当前参考点是否满足“在前方”条件；</li><li><strong>调整策略</strong>：若发现参考点因 UAV 状态变化而落入后方，则重新从轨迹中搜索合适的前瞻参考点，或对轨迹做局部插值修正。</li></ul></li></ol><hr><h3 id=2-具体实施步骤>2. 具体实施步骤</h3><h4 id=21-轨迹规划阶段>2.1 轨迹规划阶段</h4><ul><li><p><strong>规划平滑曲线</strong><br>利用样条曲线、Bézier 曲线或多项式插值技术，在 UAV 的局部坐标系（x 为前进方向）中生成从初始点到目标点的平滑轨迹，确保每个轨迹点的 x 分量单调增加。这样在全局转换后，轨迹自然呈现出沿 UAV 前进方向延伸的特性。</p></li><li><p><strong>全局坐标转换</strong><br>在每个时刻，将局部轨迹点转换为全局坐标：</p>$$
P_{\text{global}} = P_{\text{UAV}} + R(\theta) \cdot P_{\text{local}},
$$<p>其中 $R(\theta)$ 为旋转矩阵，将局部 x 轴对齐到 UAV 当前航向。</p></li></ul><h4 id=22-跟踪阶段实时选择参考点>2.2 跟踪阶段（实时选择参考点）</h4><p>在仿真或实际飞行中，每个 UAV 按如下步骤进行实时参考点选择：</p><ol><li><p><strong>获取 UAV 当前状态</strong><br>包括位置 $P$ 和航向角 $\theta$。</p></li><li><p><strong>计算 UAV 前进方向向量</strong><br>设：</p>$$
\vec{v} = (\cos\theta,\, \sin\theta).
$$</li><li><p><strong>沿轨迹搜索候选点</strong><br>遍历预先生成的轨迹点集合，对每个候选点 $ Q $：</p><ul><li><p>计算向量差：</p>$$
\vec{w} = Q - P.
$$</li><li><p>计算距离 $ d = \|\vec{w}\| $ 和点积 $ \vec{v}\cdot\vec{w} $。</p></li><li><p>如果满足：</p><ul><li>$ d \ge L $（满足前瞻距离），</li><li>且 $ \vec{v}\cdot\vec{w} > 0 $（确保候选点在 UAV 前方），</li></ul><p>则将 $ Q $ 作为合适的参考点。</p></li></ul></li><li><p><strong>选择最优候选点</strong><br>若有多个满足条件的点，可选距离刚好大于 $ L $ 的第一个点，或者通过插值方式获得一个平滑的目标参考点。</p></li><li><p><strong>实时反馈与控制</strong><br>参考点确定后，将其作为期望位置传给跟踪控制器，进行误差计算和控制指令生成。若检测到当前参考点不再满足条件（例如 UAV 误差较大导致参考点在后方），则立即重新选择或动态更新。</p></li></ol><hr><h3 id=3-示例实现c伪代码>3. 示例实现（C++伪代码）</h3><p>下面给出一个简单的 C++ 伪代码，说明如何从预先生成的轨迹中选取前方参考点：</p><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义二维点结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义 UAV 状态结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UAVState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> theta; <span style=color:#75715e>// 航向角（弧度）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 计算两点之间欧氏距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>distance</span>(<span style=color:#66d9ef>const</span> Point<span style=color:#f92672>&amp;</span> p1, <span style=color:#66d9ef>const</span> Point<span style=color:#f92672>&amp;</span> p2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>sqrt((p1.x <span style=color:#f92672>-</span> p2.x)<span style=color:#f92672>*</span>(p1.x <span style=color:#f92672>-</span> p2.x) <span style=color:#f92672>+</span> (p1.y <span style=color:#f92672>-</span> p2.y)<span style=color:#f92672>*</span>(p1.y <span style=color:#f92672>-</span> p2.y));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 选择参考点函数：从轨迹中选择一个既满足前瞻距离又在前方的点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Point <span style=color:#a6e22e>selectReferencePoint</span>(<span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> current, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&amp;</span> trajectory, <span style=color:#66d9ef>double</span> lookaheadDistance) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// UAV 当前位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Point currentPos{ current.x, current.y };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算 UAV 的前向单位向量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Point forward{ std<span style=color:#f92672>::</span>cos(current.theta), std<span style=color:#f92672>::</span>sin(current.theta) };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历轨迹点，选择第一个满足条件的点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> candidate : trajectory) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算候选点相对于当前的位置差
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point diff { candidate.x <span style=color:#f92672>-</span> currentPos.x, candidate.y <span style=color:#f92672>-</span> currentPos.y };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d <span style=color:#f92672>=</span> distance(candidate, currentPos);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算点积，判断候选点是否在前方
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> dot <span style=color:#f92672>=</span> forward.x <span style=color:#f92672>*</span> diff.x <span style=color:#f92672>+</span> forward.y <span style=color:#f92672>*</span> diff.y;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (d <span style=color:#f92672>&gt;=</span> lookaheadDistance <span style=color:#f92672>&amp;&amp;</span> dot <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 找到合适的参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> candidate;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果没有找到合适的点，返回轨迹末尾点（或根据实际需求进行其他处理）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> trajectory.back();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 示例主函数：演示在每个时间步如何选择参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 假设已生成的平滑过渡轨迹（全局坐标），可以通过规划模块获得
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> trajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>}, {<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>}, {<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>15</span>}, {<span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>20</span>}, {<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>25</span>}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 仿真参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> lookaheadDistance <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>; <span style=color:#75715e>// 前瞻距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 模拟 UAV 初始状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UAVState uav <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>}; <span style=color:#75715e>// 初始位置 (0,0)，航向 0 弧度（正向 x 轴）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 仿真循环（这里只做简单模拟）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; step <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>step) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 假设 UAV 状态由控制器更新，这里做简单线性前进模拟
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        uav.x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>5</span>; <span style=color:#75715e>// 每步前进 5 单位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 例如保持航向不变，实际可通过控制器调整
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 选择参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point refPoint <span style=color:#f92672>=</span> selectReferencePoint(uav, trajectory, lookaheadDistance);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 输出当前状态和参考点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Step &#34;</span> <span style=color:#f92672>&lt;&lt;</span> step <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | UAV Position: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | Reference Point: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> refPoint.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> refPoint.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处调用控制器：计算误差、生成控制命令，并更新 UAV 状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h5 id=代码说明-4>代码说明</h5><ul><li><strong>轨迹生成模块</strong>：应保证规划出的轨迹在 UAV 局部坐标系中 x 轴单调递增，这样全局转换后，大部分轨迹点自然在 UAV 前方。</li><li><strong>前瞻策略</strong>：在 <code>selectReferencePoint</code> 函数中，通过距离和点积判断确保选择的点位于 UAV 前方且满足前瞻距离要求。</li><li><strong>实时更新</strong>：在仿真循环或飞行控制系统中，每个控制周期都调用参考点选择函数，确保 UAV 始终获取合适的期望轨迹点。</li></ul><hr><h2 id=附录4-移动平均滤波器>附录4. 移动平均滤波器</h2><p>移动平均滤波器（Moving Average Filter, MA Filter）是一种简单而常用的数字滤波方法，其主要原理在于对连续的数值序列进行局部平均，从而减少数据中的随机噪声和高频成分，起到了低通滤波和信号平滑的作用，保留信号的低频趋势。它简单高效，易于实现，适用于实时数据处理，但需要注意信号延迟和可能的过度平滑问题。</p><hr><h3 id=1-基本原理>1. 基本原理</h3><ul><li><p><strong>数据平滑</strong>：<br>移动平均滤波器通过计算当前数据点及其相邻数据点的平均值，平滑掉数据中的短期波动。例如，给定一个离散时间序列 $ \{x(n)\} $，如果采用窗口大小为 $ N $（一般为奇数）的移动平均滤波器，则滤波后的输出 $ y(n) $ 通常定义为：</p>$$
y(n) = \frac{1}{N}\sum_{k=-M}^{M} x(n+k) \quad \text{其中} \quad N=2M+1,
$$<p>也可以采用只考虑过去的 $ N $ 个数据点的形式：</p>$$
y(n) = \frac{1}{N}\sum_{k=0}^{N-1} x(n-k).
$$<p>这种方法通过对局部窗口内的多个数据求平均，从而抑制随机噪声和突变，使得输出信号更加平滑和连续。</p></li><li><p><strong>低通滤波</strong>：<br>移动平均滤波器实际上是一种低通滤波器，其频率响应类似于一个 sinc 函数。低频成分（信号的主要趋势）能够较好地保留，而高频成分（噪声或快速波动）则被衰减掉。这是因为相邻数据中的高频成分在平均过程中相互抵消，从而达到平滑效果。</p></li></ul><hr><h3 id=2-数学模型和频率响应>2. 数学模型和频率响应</h3><ul><li><p><strong>数学模型</strong>：<br>以对称窗口为例，假设滤波器的冲激响应为：</p>$$
h(k) = \frac{1}{N}, \quad k = -M, \ldots, M.
$$<p>则滤波器的输出为：</p>$$
y(n) = \sum_{k=-M}^{M} h(k)x(n+k) = \frac{1}{N}\sum_{k=-M}^{M} x(n+k).
$$<p>这是一个有限脉冲响应（FIR）滤波器，其所有系数均为常数 $1/N$。</p></li><li><p><strong>频率响应</strong>：<br>对该 FIR 滤波器做离散时间傅里叶变换（DTFT），可以得到其频率响应 $ H(e^{j\omega}) $：</p>$$
H(e^{j\omega}) = \frac{1}{N}\sum_{k=-M}^{M} e^{-j\omega k} = \frac{1}{N} \cdot \frac{\sin\left(\frac{N\omega}{2}\right)}{\sin\left(\frac{\omega}{2}\right)} e^{-j\omega M}.
$$<p>从中可以看出，其幅度响应呈现出类似 sinc 函数的形状，对低频信号通过较多，而对高频信号则起到衰减作用。</p></li></ul><h3 id=3-windowsize-的选取>3. windowSize 的选取</h3><p>在移动平均滤波器中，<strong>windowSize</strong>（窗口大小）表示在计算每个滤波输出时所包含的连续数据点个数。也就是说，对于一个离散信号，滤波器会在当前位置周围选取一个窗口内的多个样本，然后计算这些样本的平均值作为当前输出值。</p><h4 id=windowsize-的含义>windowSize 的含义</h4><ul><li><p><strong>平滑程度</strong>：<br>窗口越大，滤波器会整合更多数据点，从而使得输出信号更加平滑，能够更有效地抑制高频噪声。但同时，过大的窗口可能会使得信号细节丢失，导致响应滞后。</p></li><li><p><strong>延迟效应</strong>：<br>由于滤波器需要利用窗口内的数据计算平均值，当窗口较大时，会引入更明显的延迟。这在实时控制中可能是一个需要考虑的问题。</p></li><li><p><strong>频率特性</strong>：<br>移动平均滤波器本质上是一个低通滤波器。窗口大小越大，其低通特性越明显，即能够更强地抑制高频成分；窗口较小时，截止频率较高，滤波效果相对较弱。</p></li></ul><h4 id=windowsize-的取值参考>windowSize 的取值参考</h4><ol><li><p><strong>根据信号特性和噪声水平</strong>：</p><ul><li>如果原始数据噪声较大，可以选择较大的 windowSize 以获得更平滑的输出。</li><li>如果数据变化较快、需要捕捉细节，则应选用较小的 windowSize。</li></ul></li><li><p><strong>与采样率有关</strong>：</p><ul><li>采样率较高时，窗口中包含的数据点更多，通常可以适当增大 windowSize 来平滑噪声，但需要注意不要过大以免引起过多延迟。</li><li>采样率较低时，windowSize 一般取较小值，避免数据过度平均导致信号失真。</li></ul></li><li><p><strong>经验值建议</strong>：</p><ul><li>对于简单应用，常见的取值为 3、5、7 或 9 等奇数。奇数的好处在于能保证窗口中心对称，减少相位失真。</li><li>实际应用中，可以先尝试 windowSize = 3 或 5，然后观察滤波后的信号平滑效果与响应速度是否满足需求，再进行调整。</li></ul></li><li><p><strong>仿真和实验调试</strong>：</p><ul><li>最终的 windowSize 需要结合具体应用进行调试，可以通过仿真或实验获得最佳平衡点。例如，在无人机轨迹平滑中，如果目标是去除噪声并保持足够的响应速度，可以从 windowSize = 3 开始测试，然后根据平滑效果和系统响应延迟逐步调整到合适的值。</li></ul></li></ol><h4 id=总结>总结</h4><ul><li><strong>windowSize</strong> 表示计算平均值时所包含的数据点数，决定了滤波器的平滑程度与延迟效应。</li><li>取值需要在信号平滑与动态响应之间取得平衡：<ul><li>较大 windowSize → 平滑效果好、延迟增大、细节可能丢失；</li><li>较小 windowSize → 平滑效果弱、细节保留、噪声可能未完全滤除。</li></ul></li><li>常用经验值为 3、5、7 等，并建议结合采样率和实际系统需求，通过仿真和实验确定最佳值。</li></ul><p>根据以上参考和实际场景进行调整，可以获得既满足噪声抑制需求又不会过多引入延迟的滤波效果。</p><hr><h3 id=4-优点与缺点>4. 优点与缺点</h3><ul><li><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：算法只需要对固定窗口内的数据求和并除以窗口长度，计算量小，易于实现。</li><li><strong>线性相位特性</strong>：移动平均滤波器属于对称 FIR 滤波器，因此具有线性相位特性，不会引入相位失真，保持信号波形的形状。</li><li><strong>实时性好</strong>：适合于实时数据处理和在线平滑。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>信号延迟</strong>：由于滤波器需要利用未来或过去的数据进行平均，会产生一定的延迟，可能导致响应滞后。</li><li><strong>频率选择性较差</strong>：移动平均滤波器的截止特性较为宽松，不能精确分离某个频段内的信号和噪声，对某些应用场合可能不够理想。</li><li><strong>平滑过度</strong>：如果窗口尺寸选得过大，可能会导致信号细节丢失，过度平滑。</li></ul></li></ul><hr><h3 id=5-应用场景>5. 应用场景</h3><p>移动平均滤波器广泛应用于：</p><ul><li>信号噪声抑制（例如传感器数据、股票价格平滑）</li><li>图像处理中的降噪</li><li>数值数据平滑，提取数据的总体趋势</li></ul><p>在无人机轨迹规划中，利用移动平均滤波器对离散规划的轨迹点进行平滑处理，可以消除因离散采样产生的不连续性和抖动，使得轨迹更加平滑且符合固定翼 UAV 的飞行动态要求。</p><hr><h3 id=6-c-代码示例>6. C++ 代码示例</h3><p>下面给出一个完整的 C++ 示例，该示例在之前轨迹生成和前瞻参考点选择的基础上，增加了一个简单的轨迹平滑算法（利用移动平均滤波器）对原始轨迹进行平滑处理，确保生成的轨迹平滑且连续。平滑后的轨迹再用于实时选择前方参考点，保证 UAV 始终跟踪前方轨迹点。</p><p>以下代码包含三个部分：</p><ol><li>数据结构定义及辅助函数（距离计算）；</li><li>平滑算法函数 <code>smoothTrajectory</code>（采用移动平均滤波）；</li><li>前瞻参考点选择函数 <code>selectReferencePoint</code> 与仿真主循环示例。</li></ol><hr><div class="highlight wrap-code" dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------- 数据结构定义 ----------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 表示二维点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 表示 UAV 状态（位置及航向角）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>UAVState</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> theta; <span style=color:#75715e>// 航向角（弧度制）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------- 辅助函数 ----------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/// 计算两点之间的欧氏距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>distance</span>(<span style=color:#66d9ef>const</span> Point<span style=color:#f92672>&amp;</span> p1, <span style=color:#66d9ef>const</span> Point<span style=color:#f92672>&amp;</span> p2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>sqrt((p1.x <span style=color:#f92672>-</span> p2.x) <span style=color:#f92672>*</span> (p1.x <span style=color:#f92672>-</span> p2.x) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                     (p1.y <span style=color:#f92672>-</span> p2.y) <span style=color:#f92672>*</span> (p1.y <span style=color:#f92672>-</span> p2.y));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------- 轨迹平滑算法 ----------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    使用简单的移动平均滤波器对原始轨迹进行平滑处理。  
</span></span></span><span style=display:flex><span><span style=color:#75715e>    参数 windowSize 为滤波窗口大小（建议取奇数），窗口内所有点的均值作为当前平滑后的点。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> smoothTrajectory(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&amp;</span> trajectory, <span style=color:#66d9ef>int</span> windowSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> smoothed;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> trajectory.size();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> smoothed;
</span></span><span style=display:flex><span>    smoothed.resize(n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> halfWindow <span style=color:#f92672>=</span> windowSize <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> sumX <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>, sumY <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算窗口内点的均值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> start <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0</span>, i <span style=color:#f92672>-</span> halfWindow);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> end   <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, i <span style=color:#f92672>+</span> halfWindow);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> start; j <span style=color:#f92672>&lt;=</span> end; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            sumX <span style=color:#f92672>+=</span> trajectory[j].x;
</span></span><span style=display:flex><span>            sumY <span style=color:#f92672>+=</span> trajectory[j].y;
</span></span><span style=display:flex><span>            count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        smoothed[i].x <span style=color:#f92672>=</span> sumX <span style=color:#f92672>/</span> count;
</span></span><span style=display:flex><span>        smoothed[i].y <span style=color:#f92672>=</span> sumY <span style=color:#f92672>/</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> smoothed;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------- 前瞻参考点选择函数 ----------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    从给定轨迹中选择一个满足前瞻距离且位于 UAV 当前航向前的点作为参考点。
</span></span></span><span style=display:flex><span><span style=color:#75715e>    条件：候选点与 UAV 之间的距离大于 lookaheadDistance，
</span></span></span><span style=display:flex><span><span style=color:#75715e>          且候选点相对于 UAV 当前位置在前进方向上（点积大于零）。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>Point <span style=color:#a6e22e>selectReferencePoint</span>(<span style=color:#66d9ef>const</span> UAVState<span style=color:#f92672>&amp;</span> current, <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;&amp;</span> trajectory, <span style=color:#66d9ef>double</span> lookaheadDistance) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// UAV 当前的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Point currentPos { current.x, current.y };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算 UAV 前进方向（单位向量）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Point forward { std<span style=color:#f92672>::</span>cos(current.theta), std<span style=color:#f92672>::</span>sin(current.theta) };
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历轨迹点，选择第一个满足条件的候选点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> candidate : trajectory) {
</span></span><span style=display:flex><span>        Point diff { candidate.x <span style=color:#f92672>-</span> currentPos.x, candidate.y <span style=color:#f92672>-</span> currentPos.y };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> d <span style=color:#f92672>=</span> distance(candidate, currentPos);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> dot <span style=color:#f92672>=</span> forward.x <span style=color:#f92672>*</span> diff.x <span style=color:#f92672>+</span> forward.y <span style=color:#f92672>*</span> diff.y;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (d <span style=color:#f92672>&gt;=</span> lookaheadDistance <span style=color:#f92672>&amp;&amp;</span> dot <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> candidate;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若未找到合适点，则返回轨迹最后一个点（或根据实际情况进行其他处理）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> trajectory.back();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ---------------------- 主函数 ----------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 原始轨迹（例如从横排到楔形阵型转换过程中的规划轨迹，单位为全局坐标）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> rawTrajectory <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>}, {<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>10</span>}, {<span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>15</span>}, {<span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>20</span>}, {<span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>25</span>},
</span></span><span style=display:flex><span>        {<span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>30</span>}, {<span style=color:#ae81ff>70</span>, <span style=color:#ae81ff>35</span>}, {<span style=color:#ae81ff>80</span>, <span style=color:#ae81ff>40</span>}, {<span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>45</span>}, {<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>50</span>}
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 对原始轨迹进行平滑处理（窗口大小可根据实际需要调整）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Point<span style=color:#f92672>&gt;</span> trajectory <span style=color:#f92672>=</span> smoothTrajectory(rawTrajectory, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 仿真中设定的前瞻距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>double</span> lookaheadDistance <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化 UAV 状态：初始位置 (0, 0)，航向 0 弧度（正向 x 轴）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UAVState uav {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 简单仿真循环：模拟 UAV 沿 x 方向前进，并选择合适的参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> step <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; step <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>step) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 模拟 UAV 前进：每个时间步沿 x 轴前进 5 个单位（实际系统中由控制器更新状态）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        uav.x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 选择当前时刻的参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Point refPoint <span style=color:#f92672>=</span> selectReferencePoint(uav, trajectory, lookaheadDistance);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 输出当前 UAV 状态和选取的参考点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Step &#34;</span> <span style=color:#f92672>&lt;&lt;</span> step <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | UAV Position: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> uav.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)&#34;</span>
</span></span><span style=display:flex><span>                  <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; | Reference Point: (&#34;</span> <span style=color:#f92672>&lt;&lt;</span> refPoint.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, &#34;</span> <span style=color:#f92672>&lt;&lt;</span> refPoint.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 此处可调用跟踪控制器，将 refPoint 作为目标进行误差计算和控制指令生成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><hr><h4 id=代码说明-5>代码说明</h4><ol><li><p><strong>轨迹平滑部分</strong></p><ul><li>函数 <code>smoothTrajectory</code> 对输入的原始轨迹进行移动平均平滑，消除因离散采样产生的噪声和不连续性。</li><li>通过调整 <code>windowSize</code> 参数可以控制平滑程度（窗口越大，平滑效果越明显，但会使轨迹滞后）。</li></ul></li><li><p><strong>前瞻参考点选择</strong></p><ul><li>函数 <code>selectReferencePoint</code> 利用 UAV 当前状态和航向，结合平滑后的轨迹数据，选择距离当前 UAV 位置大于 <code>lookaheadDistance</code> 且位于前进方向上的第一个轨迹点作为目标点。</li></ul></li><li><p><strong>集成与实时控制</strong></p><ul><li>在主函数中，先对规划的原始轨迹进行平滑处理，再在仿真循环中不断选取参考点并输出（实际系统中应结合 UAV 的状态更新与控制器）。</li></ul></li></ol><p>通过这种方法，不仅能获得平滑连续的过渡轨迹，还能确保在实时跟踪中 UAV 始终参考前方的目标轨迹点，满足固定翼 UAV 的飞行动态要求，并降低碰撞风险。</p><footer class=footline><i class='fa-fw fas fa-calendar'></i> 2025-05-21</footer></article></div></main></div><aside id=R-sidebar class=default-animation><div id=R-header-topbar class=default-animation></div><div id=R-header-wrapper class=default-animation><div id=R-header class=default-animation><a id=R-logo href=/index.html><img src=/images/logo.png alt="FlitSoft Docs" style=width:80px;height:auto></a></div><search><form action=/search/index.html method=get><div class="searchbox default-animation"><button class=search-detail type=submit title="Search (CTRL+ALT+f)"><i class="fas fa-search"></i></button>
<label class=a11y-only for=R-search-by>Search</label>
<input data-search-input id=R-search-by name=search-by class=search-by type=search placeholder=Search...>
<button class=search-clear type=button data-search-clear title="Clear search"><i class="fas fa-times" title="Clear search"></i></button></div></form></search></div><div id=R-homelinks class=default-animation><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-homelinks"><ul class="space collapsible-menu"></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-headercontrols"><ul></ul></div><div class="R-menu-divider default-animation"><hr class=padding></div></div><div id=R-content-wrapper class=highlightable><div class="R-sidebarmenu R-shortcutmenu-main"><ul class="enlarge morespace collapsible-menu"><li class=parent data-nav-id=/uas/index.html><a class=padding href=/uas/index.html>UAS</a><ul id=R-subsections-50d6e18f3c774adcdf96c62beb3fb9ae class=collapsible-menu><li class=alwaysopen data-nav-id=/uas/fix_wing_uav_flight_sim/index.html><a class=padding href=/uas/fix_wing_uav_flight_sim/index.html>Aerodynamics</a><ul id=R-subsections-7b1f39252932eb84ff7bebd53dbcc7d4 class=collapsible-menu></ul></li><li class=alwaysopen data-nav-id=/uas/path-searching/index.html><a class=padding href=/uas/path-searching/index.html>Path Searching</a><ul id=R-subsections-a2b409e9d066676ed37742c4805a3eb9 class=collapsible-menu></ul></li><li class="parent alwaysopen" data-nav-id=/uas/formation-control/index.html><a class=padding href=/uas/formation-control/index.html>Formation Control</a><ul id=R-subsections-e4f6444dc383e8d177ba6adc0bda1264 class=collapsible-menu><li data-nav-id=/uas/formation-control/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%BC%96%E9%98%9F%E9%A3%9E%E8%A1%8C/index.html><a class=padding href=/uas/formation-control/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E6%8E%A7%E5%88%B6%E7%9A%84%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%BC%96%E9%98%9F%E9%A3%9E%E8%A1%8C/index.html>基于非线性模型预测控制的无人机编队飞行</a></li><li class=active data-nav-id=/uas/formation-control/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E5%9B%BA%E5%AE%9A%E9%98%B5%E5%9E%8B%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/index.html><a class=padding href=/uas/formation-control/%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E5%9B%BA%E5%AE%9A%E9%98%B5%E5%9E%8B%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/index.html>无人机集群固定阵型轨迹生成模型</a></li><li data-nav-id=/uas/formation-control/%E5%9B%BA%E5%AE%9A%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%98%B5%E5%9E%8B%E5%8F%98%E6%8D%A2%E8%BF%87%E6%B8%A1%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/index.html><a class=padding href=/uas/formation-control/%E5%9B%BA%E5%AE%9A%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%98%B5%E5%9E%8B%E5%8F%98%E6%8D%A2%E8%BF%87%E6%B8%A1%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90/index.html>固定翼无人机阵型变换过渡轨迹生成</a></li></ul></li><li class=alwaysopen data-nav-id=/uas/velocity_plan/index.html><a class=padding href=/uas/velocity_plan/index.html>Velocity Planning</a><ul id=R-subsections-60d9350f137676e977a8a40fa195d7e5 class=collapsible-menu></ul></li><li class=alwaysopen data-nav-id=/uas/trajectory_planning/index.html><a class=padding href=/uas/trajectory_planning/index.html>Trajectory Planning</a><ul id=R-subsections-abf2bea1fe96559e28880644014fc77f class=collapsible-menu></ul></li></ul></li><li data-nav-id=/em/index.html><a class=padding href=/em/index.html>EM</a><ul id=R-subsections-5221d921411ef33ede36c0310590339e class=collapsible-menu></ul></li><li data-nav-id=/agi/index.html><a class=padding href=/agi/index.html>AI</a><ul id=R-subsections-b697951847df19851ae8635cac95c15a class=collapsible-menu></ul></li><li data-nav-id=/gaming/index.html><a class=padding href=/gaming/index.html>Gaming</a></li><li data-nav-id=/c2/index.html><a class=padding href=/c2/index.html>C2</a><ul id=R-subsections-e0126222f5f1b52fd67c95ccf5ad1c18 class=collapsible-menu></ul></li><li data-nav-id=/simu/index.html><a class=padding href=/simu/index.html>Simulation</a><ul id=R-subsections-80cfed847676c641fa01f11f3f2904bf class=collapsible-menu></ul></li><li data-nav-id=/visual/index.html><a class=padding href=/visual/index.html>Visualization</a><ul id=R-subsections-080a96fba97ea97926a463e36c9cb108 class=collapsible-menu></ul></li><li data-nav-id=/log/index.html><a class=padding href=/log/index.html>Log</a></li></ul></div><div class="R-sidebarmenu R-shortcutmenu-shortcuts"><ul class="space collapsible-menu"></ul></div><div id=R-footer-margin></div><div class="R-menu-divider default-animation"><hr class=padding></div><div class="R-sidebarmenu R-shortcutmenu-footercontrols"><ul><li class=R-variantswitcher><div class="padding menu-control"><i class="fa-fw fas fa-paint-brush"></i>
<span>&nbsp;</span><div class=control-style><label class=a11y-only for=R-select-variant>Theme</label>
<select id=R-select-variant><option id=R-select-variant-zen-light value=zen-light selected>Zen Light</option><option id=R-select-variant-zen-dark value=zen-dark>Zen Dark</option></select></div><div class=clear></div></div><script>window.relearn.markVariant()</script></li></ul></div><div id=R-footer><p>Built By FlitSoft</p></div></div></aside><script src=/js/clipboard/clipboard.min.js?1750251247 defer></script><script src=/js/perfect-scrollbar/perfect-scrollbar.min.js?1750251247 defer></script><script>window.MathJax=Object.assign(window.MathJax||{},{tex:{inlineMath:[["\\(","\\)"],["$","$"]],displayMath:[["\\[","\\]"],["$$","$$"]]},options:{enableMenu:!1}},JSON.parse("{}"))</script><script id=MathJax-script async src=/js/mathjax/tex-mml-chtml.js?1750251247></script><script src=/js/theme.min.js?1750251247 defer></script></body></html>