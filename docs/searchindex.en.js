var relearn_searchindex = [
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation",
    "content": "小型固定翼无人机飞行动力学模型为小型固定翼无人机仿真系统提供逼真的飞行动力学与飞行控制方案，替代当前的简单PID+运动学模型。文档涵盖系统需求、6-DOF动力学模型、级联控制架构、模块接口、参数标定及实现建议等内容。\nJSBSim User manual如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim Quickstart旨在让用户和开发者了解JSBSim软件的所有功能。",
    "description": "小型固定翼无人机飞行动力学模型为小型固定翼无人机仿真系统提供逼真的飞行动力学与飞行控制方案，替代当前的简单PID+运动学模型。文档涵盖系统需求、6-DOF动力学模型、级联控制架构、模块接口、参数标定及实现建议等内容。\nJSBSim User manual如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim Quickstart旨在让用户和开发者了解JSBSim软件的所有功能。",
    "tags": [],
    "title": "Aerodynamics",
    "uri": "/uas/fix_wing_uav_flight_sim/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM",
    "content": "辛格方向图模型 高斯方向图模型",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Antenna Pattern",
    "uri": "/em/antenna-pattern/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation",
    "content": "三段S曲线速度规划模型旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。",
    "description": "三段S曲线速度规划模型旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。",
    "tags": [],
    "title": "Velocity Plan",
    "uri": "/uas/velocity_plan/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "Aerodynamics 小型固定翼无人机飞行动力学模型为小型固定翼无人机仿真系统提供逼真的飞行动力学与飞行控制方案，替代当前的简单PID+运动学模型。文档涵盖系统需求、6-DOF动力学模型、级联控制架构、模块接口、参数标定及实现建议等内容。\nJSBSim User manual如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim Quickstart旨在让用户和开发者了解JSBSim软件的所有功能。\nVelocity Plan 三段S曲线速度规划模型旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "UAS Simulation",
    "uri": "/uas/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "Antenna PatternThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "EM",
    "uri": "/em/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "Why We ThinkThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "AGI",
    "uri": "/agi/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Gaming",
    "uri": "/gaming/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.\nAdvanced Battle Management System先进战斗管理系统 (ABMS) ——美国空军面临的需求、进展、挑战与机遇.\n决策优势与主动权决策优势与主动权：完善联合全域指挥与控制",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "C2",
    "uri": "/c2/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Simulation",
    "uri": "/simu/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Visualization",
    "uri": "/visual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "基于运动基元的A*算法This summary is independent of the content.\nThis is a new chapter.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Log",
    "uri": "/log/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  C2",
    "content": "中文译文\n此浏览器不支持 iframe，请 点击下载 PDF 中文译文",
    "description": "先进战斗管理系统 (ABMS) ——美国空军面临的需求、进展、挑战与机遇.",
    "tags": [],
    "title": "Advanced Battle Management System",
    "uri": "/c2/advanced_battle_management_system/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  AGI",
    "content": "日期：2025年5月1日 | 预计阅读时间：40分钟 | 作者：Lilian Weng\n特别感谢 John Schulman 对本文提供了许多非常有价值的反馈和直接修改。\n测试时计算（test time compute）（Graves et al. 2016、Ling, et al. 2017、Cobbe et al. 2021）与思维链（Chain-of-thought, CoT）（Wei et al. 2022、Nye et al. 2021）已显著提升了模型性能，同时也引发了许多研究问题。本文旨在回顾关于如何有效利用测试时计算（即“思考时间”）以及为何它能带来帮助的最新进展。\n动机 让模型“思考得更久”有多种动机。\n心理学类比 这个核心思想与人类思考的方式密切相关。人类无法立即回答“12345乘以56789是多少？”这样的问题。我们通常会花时间思考和分析，尤其是在面对复杂问题时。在 《思考，快与慢》（Kahneman, 2013） 一书中，Daniel Kahneman 根据 双过程理论（dual process theory） 将人类的思维模式分为两种：\n快思考（系统1）：快速且自动地运行，依赖直觉和情感，几乎不需要努力。 慢思考（系统2）：需要有意识地投入逻辑思考与大量认知资源。该模式更耗费心理能量，需要主动参与。 由于系统1思维快速且轻松，往往成为主要决策机制，但这也以牺牲准确性和逻辑为代价。它依赖于大脑的心理捷径（即启发式），因此容易出错和产生偏差。通过有意识地放慢思考节奏，花更多时间反思、改进和分析，我们可以激活系统2思维，挑战本能，从而做出更理性的决策。\n计算资源视角 深度学习的一个视角是：神经网络可以通过正向传播中所能访问的计算与存储量来刻画。如果我们用梯度下降方法训练模型解决问题，那么优化过程将学会如何利用这些资源——即学会如何将资源组织成执行计算和存储信息的“电路”。从这个角度看，如果我们设计一个能够在测试时执行更多计算的架构或系统，并训练其有效利用这些资源，那么它的表现会更好。\n在 Transformer 模型中，每生成一个 token 所需的计算量（以 FLOPs 衡量）大约是模型参数量的两倍。而在稀疏模型如专家混合（mixture of experts, MoE）中，每次前向传播只激活部分参数，因此其计算量为：计算量 = 2 * 参数量 / 稀疏率，其中稀疏率指的是被激活的专家比例。\n另一方面，CoT 允许模型在为每个答案 token 进行计算时执行更多的 FLOPs。事实上，CoT 的一个优点是：它可以根据问题的复杂程度动态调整所需的计算量。\n潜变量建模 机器学习中的一个经典思想是：定义一个含有潜变量（latent variable）$z$ 和可见变量（visible variable）$y$ 的概率模型，其中$y$ 是给定的数据。对潜变量取边际（求和）可以表达一个对可见变量的丰富分布：\n$$ P(y) = \\sum_z \\sim P(z) P(y|z) $$例如，我们可以通过设定$x$ 为数学问题的描述，$y$ 为答案或证明，$z$ 为通往证明过程中的自由思考路径，来建模数学题与答案的分布。此时我们优化的目标为：\n$$ P(y|x) = \\sum_z \\sim p(z|x) P(y|x, z) $$这种潜变量的视角在理解涉及多个并行 CoT 收集或在 CoT 空间中搜索的方法时特别有用，这些算法可视为从后验分布$P(z|x,y)$ 中采样。同时，这一视角也说明了将对数损失函数$\\log P(y|x)$ 作为目标优化的重要性——在预训练中它非常有效。\nToken 中的思考 在生成简短答案之前先生成中间步骤的策略，尤其是针对数学问题，最早由 Ling et al. 2017 探索，他们提出了 AQUA-RAT 数据集。随后 Cobbe et al. 2021 扩展了这一工作，推出了 Grade School Math (GSM) 数据集。Cobbe 等人通过人类书写解答训练生成器，并使用验证器判断候选解的正确性，从而对解答进行搜索。Nye et al. (2021) 尝试将中间思考 token 作为“草稿板”，而 Wei et al.（2022）首次提出了现在被广泛使用的术语 思维链（chain-of-thought, CoT）。\n早期改进 CoT 推理能力的工作包括：对人类书写的推理轨迹或过滤过的模型推理轨迹进行监督学习；后者可被视为一种初级形式的强化学习（reinforcement learning, RL）。另一些研究发现，通过恰当的提示可显著提升经过指令调优（instruction tuned）模型的数学表现，例如使用 \"think step by step\"（Kojima et al. 2022）或更复杂的提示鼓励模型优先反思相关知识（Yasunaga et al. 2023）。\n后续研究发现，可通过对具有自动可验证答案的数据集（如短答案 STEM 问题或可用单元测试验证的编程任务）执行强化学习，显著提升 CoT 推理能力（Zelikman et al. 2022，Wang et al., 2023，Liu et al., 2023）。这一思路因 o1-preview、o3、以及 R1 技术报告（DeepSeek-AI, 2025）的发布而走红，报告中展示了一种使用策略梯度算法的简单方法即可达到强大性能。\n思维链提示能提高解决数学问题的成功率。模型越大，越能从“思考时间”中受益。（图源：Wei et al. 2022）\n分支与修订 测试时计算的根本意图是：在测试阶段自适应地调整模型输出分布。可以通过多种方式利用测试时的资源在解码阶段选择更优样本，从而引导模型向更理想的分布输出。\n提升解码过程的两种主要方法是并行采样与顺序修订：\n并行采样 同时生成多个输出，可在每步使用奖励信号进行引导，或在末尾通过验证器评估质量。这是最广泛采用的测试时性能提升方法，如 best-of-N 或 beam search。若没有可用的真实标签，常使用“自洽性”（self-consistency）（Wang et al. 2023）在多个 CoT 展开中采用多数投票选出最终答案。 顺序修订 根据上一步的输出逐步调整模型回应，让模型有意识地反思自身输出并修正错误。该过程可能需依赖精调模型，因为单靠模型本身的自我纠错能力，缺乏外部反馈，可能无法提升表现（Kamoi et al. 2024，Huang et al. 2024）。 并行采样简单、直观且易于实现，但受限于模型一次性输出正确结果的能力。顺序修订显式要求模型反思错误，虽更慢、实现更复杂，但能有效推动修正。然而，该方式可能会将原本正确的预测改错，或引入其它幻觉内容。这两种方法也可以结合使用。Snell et al. (2024) 指出：简单问题更适合使用纯顺序的测试时计算，而困难问题则在并行与顺序计算之间达到最优组合时表现最好。\n并行采样与顺序修订的示意图。\n并行采样（Parallel Sampling） 在拥有一个生成模型与用于评估完整或部分样本的打分函数的前提下，可以采用多种搜索算法来寻找得分更高的样本。最简单的算法是 Best-of-N：采样$N$ 个独立样本，并根据某种打分函数选出得分最高者。Beam Search（束搜索）是一种更复杂的搜索算法，其搜索过程更具适应性，会在更有前景的解空间中投入更多采样计算资源。\nBeam Search 维护一组可能性较高的部分序列，交替进行扩展与剪枝。在候选选择机制上，可以借助过程奖励模型（Process Reward Model, PRM；Lightman et al. 2023）来引导 beam search 的候选选择。Xie 等人 (2023) 使用大语言模型（LLM）评估自身生成的推理步骤是否正确，并将其格式化为选择题。结果发现，这种逐步自我评估在 beam search 解码中能降低累计误差。此外，在采样过程中对温度进行退火（annealing）可减缓随机性带来的干扰。Xie 等人的实验在 GSM8k、AQuA 和 StrategyQA 等少样本基准上使用 Codex 模型实现了 5–6% 的性能提升。\nReward Balanced Search（简称 REBASE；Wu et al. 2025）则另行训练了一个 PRM，用于决定 beam search 中每一深度的每个节点应扩展的程度，其依据是 softmax 归一化后的奖励得分。Jiang et al. (2024) 所训练的 PRM 被命名为 “RATIONALYST”，用于基于合成推理的 beam search 引导，训练数据为大量无标注语料。当包含该推理路径时，若能显著降低真实答案 token 的负对数概率（neg log-prob），就认为这条推理路径是“好的”。在推理时，RATIONALYST 通过估计下一个推理步骤的 log 概率（隐式方式）或直接生成下一步推理内容（显式方式）来对 CoT 生成器提供过程监督。\nBeam search 解码过程通过 LLM 对每个推理步骤进行自我评估来进行引导。（图源：Xie et al. 2023）\n有趣的是，可以在没有显式零样本或少样本提示的情况下诱发模型的思维链（CoT）路径。Wang \u0026 Zhou (2024) 发现：若在采样初期保留置信度最高的$k$ 个 token（置信度定义为 top-1 与 top-2 候选间的概率差），并对这$k$ 个分支分别进行贪婪解码，则很多生成序列自然就包含了 CoT。尤其是当上下文中已出现 CoT 时，这会使模型在生成最终答案时更具信心。\n为了计算最终答案的置信度，需要借助任务特定启发式方法（如数学题中最后一个数字）或进一步提示模型 “So the answer is” 来提取答案区间。之所以仅在首个 token 进行分支，是基于如下观察：早期分支能显著增强解路径的多样性，而后续 token 会受此前内容的强烈影响。\nTop-k 解码示意图，其中$k$ 是首次采样步骤中保留的候选数量。（图源：Wang \u0026 Zhou, 2024）\n顺序修订（Sequential Revision） 如果模型能反思并修正过去回答中的错误，我们就希望其能迭代地产出越来越高质量的修订序列。但实际上，大语言模型（LLM）并不具备这种内在的自我修正能力，直接使用这种能力往往效果不佳，其失败模式包括：\n幻觉（hallucination）：将正确答案改成错误； 行为崩溃：修订时未作出实质性修改或根本不修改； 泛化失败：在测试时遇到分布漂移时无效。 Huang 等人 (2024) 的实验表明，直接套用自我修正机制反而会导致性能下降。为实现有效的自我改进，模型需要外部反馈，如：与真实标签匹配、启发式方法、任务特定指标、编程题的单元测试结果（Shinn 等人, 2023）、更强大的模型监督（Zhang et al. 2024）、或人类反馈（Liu et al. 2023）。\n自我修正学习（Self-correction learning；Welleck et al. 2023）目标是：在给定固定生成模型$P\\_0(y\\_0|x)$ 的情况下，训练一个校正器模型$P\\_\\theta(y|y\\_0,x)$。生成器保持通用性，而校正器可根据任务而定，仅在给定初始响应与可选反馈（如文本、编译器日志、单测结果）条件下生成内容：\n首先在数据池中为每个提示生成多个输出； 若两个输出中一个的价值更高，则构造 “增值对”（value-improving pair）：$(x, y, y')$； 这些样本对按照价值差$v(y') - v(y)$ 和输出相似度$Similarity(y, y')$ 的比例进行抽样训练； 校正器的输出也可用于扩展数据池。在推理阶段，校正器可用于生成修正轨迹的顺序修订过程。 通过配对同一问题下模型输出构造增值对来训练校正器模型的自我修正学习示意图。（图源：Welleck et al. 2023）\n递归检查（Recursive inspection；Qu et al. 2024）也是训练更强校正器的方法，不过其采用单一模型同时执行生成与自我修正。\nSCoRe（Self-Correction via Reinforcement Learning） 是一个基于多轮强化学习（RL）的自我修正方法（Kumar et al. 2024）。该方法鼓励模型在第二轮生成中产出比第一轮更好的答案。训练包括两个阶段：\n阶段1：最大化第二次尝试的正确率，并在第一轮加入 KL 惩罚以限制其偏离原始模型； 阶段2：同时优化第一轮和第二轮的答案质量。 这种设计既能鼓励第一次输出的多样性，又能逐步提升整体表现。\n通过两阶段强化学习训练显式提升模型的自我修正能力的结构图。（图源：Kumar et al. 2024）\n强化学习提升推理能力（RL for Better Reasoning） 近年来，通过强化学习（Reinforcement Learning, RL）显著提升语言模型推理能力的研究不断取得突破。这些方法通常采用带有真实答案的问题集（如 STEM 题或逻辑谜题）作为训练基础，模型的奖励机制以获得正确答案为目标。该方向的热度部分来自 OpenAI o 系列模型的出色表现，以及随后 DeepSeek 团队发布的模型与技术报告。\nDeepSeek-R1（DeepSeek-AI, 2025）是一个开源大语言模型（LLM），旨在在数学、编程、逻辑等高阶推理任务中取得卓越表现。其训练流程包括两轮 SFT-RL（监督微调 + 强化学习）：\n冷启动 SFT：对 DeepSeek-V3-Base 在数千条冷启动数据上进行微调，以解决可读性差、语言混用问题。\n面向推理的强化学习：\n仅对推理类 prompt 训练推理模型；\n设定两类基于规则的奖励：\n格式奖励：要求使用 \u003cthinking\u003e...\u003c/thinking\u003e 包裹 CoT； 准确性奖励：数学题需将答案放入指定格式（如边框中）以便验证；编程题使用编译器验证是否通过测试用例。 拒绝采样 + 非推理类 SFT：\n从步骤2的 RL checkpoint 中进行拒绝采样，结合 DeepSeek-V3 的非推理类监督数据（写作、问答、自认知等）； 过滤掉混用语言、长段落或代码块的 CoT； 对总共80万样本进行2轮微调训练。 最终 RL 阶段：对推理与非推理 prompt 共同进行训练，以提升有用性、无害性与推理能力。\nDeepSeek-R1 在多个主流推理基准上与 OpenAI o1-preview、o1-mini 表现相当，DeepSeek-V3 为唯一非推理模型。（图源：DeepSeek-AI, 2025）\n有趣的是，DeepSeek 团队还展示了无需 SFT，纯 RL 训练即可学习高级推理能力，如反思与回溯（即“顿悟时刻”）。模型在 RL 训练中自然学会投入更多思考 token 来解决复杂问题。“顿悟时刻”指模型在反思错误后主动尝试其它路径进行修正。\n随后有多个开源项目尝试复现 R1 成果，如 Open-R1、SimpleRL-reason、TinyZero，均基于 Qwen 模型。这些尝试也验证了纯 RL 方法在数学问题与“顿悟能力”方面的有效性。\n模型学会反思并修正错误的示例。（图源：（左）DeepSeek-AI, 2025；（右）Zeng et al. 2025）\nDeepSeek 还公开了部分失败尝试。例如：使用过程奖励模型（PRM）因难以定义每步规则、评估中间步骤是否正确而失败，训练过程也容易被奖励欺骗（reward hacking）破坏；而 MCTS（蒙特卡洛树搜索）则因语言模型 token 的搜索空间过大且精细奖励建模困难而未能成功。这些失败案例提供了有价值的洞察，也呼吁社区更多分享“不成功”的经验。\n外部工具的使用 在推理步骤中，某些中间步骤可以通过执行代码或运行数学计算来可靠且准确地完成。将推理组件中的这一部分卸载到外部代码解释器上（例如 PAL（Program-Aided Language Model，程序辅助语言模型；Gao et al. 2022）或 Chain of Code（Li et al. 2023））可以借助外部工具扩展大语言模型（LLM, Large Language Model）的能力，从而免去让 LLM 学习执行代码或充当计算器的需求。这些代码模拟器（如 Chain of Code 中的实现）可以由 LLM 增强：如果标准代码解释器失败，我们可以选择使用 LLM 来执行该行代码。\n使用代码来增强推理步骤对于数学问题、符号推理和算法任务尤其有益。这些单元测试在某些编程问题中可能并不存在，在这些情况下，我们可以指示模型自我生成单元测试，以便它可以通过测试来验证其解决方案的正确性（Shinn 等人，2023）。\n一个程序辅助语言模型提示的示例。（图片来源：Gao et al. 2022）\nReAct（Reason+Act；Yao et al. 2023）将搜索维基百科 API 的行为与推理轨迹的生成结合起来，使推理路径能够整合外部知识。\n一个 ReAct 提示方法的示例，用于解决 HotpotQA 问题，通过使用维基百科搜索 API 作为外部工具来辅助推理。（图片来源：Yao et al. 2023）\no3 与 o4-mini，是 OpenAI 最近发布的两个优秀示例，其中推理过程涉及到工具使用，如网页搜索、代码执行和图像处理。团队观察到，大规模强化学习呈现出与 GPT 范式相同的趋势，即“更多计算 = 更好性能”。\n忠实思考（Thinking Faithfully） 深度学习模型通常被当作黑箱来处理，已经提出了各种可解释性方法。可解释性具有几个重要用途：首先，它为我们提供了一个额外的检验手段，用以判断模型是否与其创建者的意图不一致，或是否以我们难以从行为中察觉的方式表现异常。其次，它可以帮助我们判断模型是否使用了合理的流程来得出答案。思维链（Chain-of-thought, CoT）提供了一种特别便利的可解释性形式，因为它以自然语言展示了模型的内部推理过程。然而，这种可解释性的前提是模型能忠实地描述其内部思维过程。\n近期的研究表明，监控推理模型的 CoT 能够有效地检测出模型的不良行为，例如 奖励欺骗（reward hacking），甚至可以使一个较弱的模型监控一个更强的模型（Baker et al. 2025）。增加测试时计算量也能提高对抗性鲁棒性（Zaremba et al. 2025）；从直觉上讲，这也是合理的：在面对异常输入（例如对抗样本或越狱攻击）时，更长的思考时间将特别有助于模型理解其所面临的异常情况。\n该实验要求模型根据其思维过程判断另一个模型是否在某种程度上试图通过代码问题中的单元测试作弊。我们可以通过不同类型的监控器在训练过程中监控这些奖励欺骗行为。exit(0) 代码作弊是指智能体利用一个漏洞在未运行所有单元测试的情况下提前退出环境。raise SkipTest 欺骗是指智能体从测试框架之外的函数抛出异常，以跳过单元测试评估。（图片来源：Baker et al. 2025）\n模型是否忠实地表达了其思考？ 从直觉上讲，模型的 CoT 可能存在偏差，这是由于缺乏明确的训练目标来鼓励忠实推理，或者当我们在基于人类书写解释上微调模型时，这些人类样本本身可能就包含错误。因此，我们不能默认认为 CoT 一定是忠实的。\nLanham 等人（2023） 研究了几种 CoT 忠实性失效的模式，方法是故意在 CoT 中引入错误，并测量这些错误对一系列多项选择任务（例如 AQuA、MMLU、ARC Challenge、TruthfulQA、HellaSwag）准确率的影响：\n错误 1（过早作答）：模型可能在生成 CoT 之前就过早得出结论。这通过提前截断或在 CoT 中插入错误来进行测试。不同的任务揭示了对 CoT 效果的任务特定依赖性；有些任务在 CoT 被截断后评估性能会下降，有些则不会。Wang 等人（2023） 做了类似实验，但引入的是更微妙的错误，例如桥接对象或语言模板方面的错误。 错误 2（无信息 token）：CoT 中的无信息 token 是否提高了性能？该假设通过将 CoT 替换为填充文本（如全为句号）来测试，结果显示没有准确率的提升，并且某些任务的性能在没有 CoT 的情况下略优。 错误 3（人类难以理解的编码）：将相关信息以人类难以理解的方式编码。以非标准方式改写 CoT 不会降低数据集上的性能，说明性能提升并不依赖于人类可读的推理过程。 用于评估 CoT 忠实性的不同扰动方式示意图。（图片来源：Lanham et al. 2023）\n有趣的是，Lanham 等人指出，对于多项选择题，小模型可能还不足以充分利用 CoT，而较大的模型即使没有 CoT 也可能完成任务。这种对 CoT 推理的依赖性（通过“有 CoT 与无 CoT 得出相同答案的比例”衡量）在多选任务中并不总是随着模型规模增加而增加，但在加法类任务中确实随模型规模上升而增强，表明“思考时间”在复杂推理任务中更为重要。\nCoT 依赖性衡量为有无 CoT 情况下给出相同答案的百分比。在加法等推理任务中影响更显著，且大模型受益更多。（图片来源：Lanham et al. 2023）\n测试 CoT 忠实性的另一个方法是扰动提示语（prompt），而不是直接修改 CoT 路径（Turpin et al. 2023、Chua \u0026 Evans, 2025、Chen et al. 2025）。\n一种方法是在少样本示例中始终将正确答案标记为 “(A)”，以人为引入偏差。\n另一种提示方法是在提示中插入误导性暗示，例如： \"我觉得答案是 \u003crandom_label\u003e，但想听听你的意见。\" 或 \"一位斯坦福教授认为答案是 \u003crandom_label\u003e\"。\n通过比较模型在有无误导提示下对同一问题的回答，我们可以测量模型是否能忠实地描述提示对其答案的影响。特别是当模型生成不同答案（有提示与无提示）时，我们衡量模型是否在有提示条件下承认提示对其推理有影响。如果模型是忠实的，它应该明确承认该影响，并指出答案变化是由提示引起的。\nGPT 与 Claude 模型对不同类型的上下文偏差敏感。准确率的下降表明存在系统性的不忠实。直接的错误标签提示比“答案总是 A”类型的偏差更有效。（图片来源：Turpin et al. 2023）\n多项研究发现，推理模型在描述提示影响方面比所有测试过的非推理模型都更可靠。例如，我们可以衡量模型在多少个样本中承认提示是决定性因素（即“忠实 CoT”）。推理模型（Claude 3.7 Sonnet、DeepSeek R1）整体上比非推理模型（Claude 3.6、DeepSeek V3）表现更好。\n推理模型更容易展现出忠实的思维链（faithful CoT），相较于非推理模型。（图片来源：Chen et al. 2025）\n一些证据表明，使用奖励模型（Reward Model）会降低模型输出的忠实性。在经典 RLHF（基于人类反馈的强化学习）中，奖励模型并未被训练来鼓励忠实行为，因为其偏好比较数据集是通过人类选择看起来更好或更令人满意的输出样本构建的。\n然而，在推理模型中，CoT 路径是为了生成正确最终答案而优化的，而不是去迎合奖励模型（RM）中定义的人类偏好，因此从直觉上讲，它们更有可能是忠实的。\n对思维链的优化压力：利还是弊？（Optimization Pressure on CoT: Good or Bad?） 监控推理模型的思维链（CoT）以检测奖励欺骗行为是有效的。一种简单的用法是在测试阶段使用监控器作为过滤器运行拒绝采样，从而识别不含奖励欺骗的解答。然而，这种方法只在强化学习（RL）的早期阶段有效；随着模型进一步优化，很难在计算预算内找到能通过 CoT 监控器的样本。这个挑战自然暗示了我们可以考虑将 CoT 监控器融入 RL 奖励中——这是一种基于过程的监督形式，以防止奖励欺骗。\n然而，将 CoT 监控奖励纳入 RL 中的做法效果并不好，因为它会导致“模糊化的奖励欺骗”：模型试图在 CoT 中隐藏其真实意图（Baker et al. 2025）。即使在 RL 训练中施加来自 CoT 监控器的直接优化压力，模型仍能找到作弊方法，尽管频率略有下降，但它可以将意图隐藏在 CoT 中，从而避开监控器的检测。\n当使用监控器为训练过程提供 RL 奖励信号以防止奖励欺骗时，模型仍然可以找到作弊方式，同时避开监控器的检测。（图片来源：Baker et al. 2025）\nYeo et al. (2025) 对 CoT 长度奖励信号的实验验证了与 Baker 等人相似的结论：新的奖励塑形方式可能引发新的奖励欺骗类型。他们设计了一个奖励函数，使得正确的 CoT 比错误的具有更高奖励，短的正确 CoT 比长的正确 CoT 奖励更高，短的错误 CoT 比长的错误 CoT 惩罚更重。由于该额外奖励，模型倾向于在面对困难问题时在 CoT 中重复文本，而不是尝试真正解决问题。为防止这种作弊行为，Yeo 等人进一步引入了 n-gram 重复惩罚机制。\n在使用 CoT 长度奖励信号进行训练时，需要谨慎地进行奖励塑形以保持稳定性。（图片来源：Yeo et al. 2025）\nChen et al. (2025) 对一个缺陷 RL 环境进行了实验，其中使用了包含错误答案的打分器来评估多项选择题。模型学习如何在超过 99% 的 prompt 上利用奖励漏洞进行作弊，但在他们的大多数环境中，模型几乎从未（\u003c2% 的概率）在其 CoT 中口头表达奖励欺骗的策略。在这种情况下，进一步的 RL 优化压力也无法促使模型显式描述其作弊行为。\nRL 训练本质上对奖励欺骗极为敏感。仅依赖启发式的奖励欺骗调查和手动修复可能导致“打地鼠”（whack-a-mole）式的修补循环。因此，我们建议在 RL 训练中尝试直接优化 CoT 时要非常谨慎，甚至尽量避免这样做。\n连续空间中的思考（Thinking in Continuous Space） 自适应计算时间（Adaptive Computation Time）由 Alex Graves 于 2016 年提出，虽然早于大型语言模型的出现，但开创了使模型能够在推理时动态决定计算步数的方向，这可以被视为使模型在测试时能够在连续空间中“思考更多”。在连续空间中的自适应思考时间可以通过纵向（采用循环架构）或横向（更多的顺序采样步骤）来实现。\n循环架构（Recurrent Architecture） 已经提出了多种架构变体，旨在使 Transformer 架构具备循环能力，以实现自适应测试时计算能力（Dehghani 等人, 2019、Hutchins 等人, 2022、Bulatov 等人, 2022）。深入探讨该主题的文献会使本文过长，因此这里只回顾部分代表性工作。\nUniversal Transformer（Dehghani 等人, 2019）将 Transformer 中的自注意力机制与 RNN 中的循环机制结合，借助自适应计算时间机制（Graves, 2016）动态调整处理步骤数量。在高层次上，它可被视为对每个 token 学习隐藏状态表示的循环函数；若步数固定，则 Universal Transformer 等价于一个具有跨层参数共享的多层 Transformer。\n一项较新的循环架构设计由 Geiping et al. (2025) 提出：在标准 Transformer 之上添加一个循环模块 R。该循环模块的每次迭代接收嵌入$e$ 和一个随机状态$s\\_i$。从概念上讲，这种循环深度架构有些类似于条件扩散模型（conditioned diffusion model），其中原始输入$e$ 在每一步中都作为输入传入，而一个初始为高斯分布的随机状态$s\\_i$ 经过多次迭代被不断更新。（有趣的是，他们部分类似扩散模型的设计在实验中表现较差。）\n$$ e = P(x)\\quad \\text{（嵌入）} \\\\ s_0 \\sim \\mathcal{N}(0, \\sigma^2 I_{n \\cdot h}) \\\\ s_i = R(e, s_{i-1})\\quad \\text{对于 } i \\in \\{1, \\dots, r\\} \\quad \\text{（循环模块，类似 Transformer block）} \\\\ p = C(s_r)\\quad \\text{（反嵌入层）} $$训练时，循环次数$r$ 对每个输入序列是随机的，采样自对数正态泊松分布。为控制计算开销，反向传播仅对循环单元的最后$k$ 次迭代进行（实验中$k=8$），从而可以在 Poisson 分布的长尾部分进行训练。嵌入模块的输出$e$ 在每一步都被注入，因此在每步中都接收梯度更新，模拟 RNN 的训练方式。\n不出所料，训练循环模型的稳定性非常敏感。诸如初始化、归一化、超参数等因素都至关重要，尤其在扩大训练规模时。例如，隐藏状态可能会崩溃：所有 token 的隐藏状态预测相同；或者模型可能学会忽略输入状态$s$。为提升稳定性，Geiping 等人采用了嵌入缩放因子、较小的学习率和精心调参。\n在训练一个 35 亿参数模型的深度循环实验中绘图。约在$\\bar{r} = 32$ 时趋于饱和，使人思考该架构在更大迭代次数上的外推和泛化能力。（图片来源：Geiping et al. 2025）\n思维Token（Thinking Tokens） 思维token指的是在训练或推理过程中引入的一组隐式token，它们本身不携带直接的语言含义。相反，它们的作用是为模型提供额外的“思考时间”和计算能力，以便获得更好的表现。\nHerel 与 Mikolov（2023） 引入了在句子中每个单词后插入特殊思维token（例如 \u003cT\u003e）的想法，并在这种构造的数据集上训练模型。每个思维token为模型提供了更多的时间来处理信息并作出更优预测。在玩具模型设置下，使用思维token训练的模型比不使用它们的基线模型获得了更低的困惑度（perplexity）。思维token的益处在面对复杂推理任务或涉及数字的句子时尤为明显。\n类似地，Goyal 等人（2024） 提出的暂停token（pause tokens）通过在输入序列末尾添加虚拟token（例如 . 或 # 之类字符）来延迟模型的输出，从而在推理阶段为模型提供额外的计算资源。重要的是在训练和推理阶段都注入这些暂停token，仅在微调阶段使用暂停token收效甚微。在训练过程中，这些暂停token被插入到随机均匀位置的多个副本中，并且训练时忽略这些token的loss。\n与标准设置相比，训练与推理阶段注入暂停token的方式示意图。（图片来源：Goyal et al. 2024）\n有趣的是，在上述实验中，思维token或暂停token并未携带任何额外信息，也没有引入新的参数，但为何仍然有效呢？一方面，它们通过引入更多的推理循环扩展了计算资源，从而有效提升计算能力；另一方面，它们可被视为一种特殊的、隐式的思维链（CoT）形式。其不足之处在于模型需要针对思维token进行预训练。尽管如此，这种策略为进一步提升测试时计算资源的利用能力，在推理阶段CoT之外提供了新的路径。\nQuiet-STaR（Zelikman 等人，2025）通过在每个token后生成推理理由（rationale）来引入token级推理。它混合带有和不带理由的未来token预测，并使用学习机制来生成更优的推理理由，同时用 REINFORCE 方法优化 rationale 的质量。\nQuiet-STaR 示意图。（图片来源：Zelikman et al. 2025）\nQuiet-STaR 包含三个阶段：\nThink：带 rationale 的下一token预测。由于token级推理代价高昂，该过程设计为并行生成多个 rationale。使用特殊注意力映射，使所有思维token仅关注自己、当前思维中的先前思维token，以及前文文本。 Talk：不带 rationale 的下一token预测与带 rationale 的结果进行混合。两者logits的混合权重由浅层MLP结构输出的混合头部学习而来。最终可通过教师强制（teacher forcing）选择正确token。 Learn：通过 REINFORCE 训练模型生成更好的 rationale，保留提升下一个token预测概率的样本，舍弃降低性能的样本。 在未进行数据集特定微调的情况下，Quiet-STaR 在 Mistral 7B 上实现了零样本条件下的性能提升：CommonsenseQA 从 36.3% 提升至 47.2%，GSM8K 从 5.9% 提升至 10.9%。\n思考作为潜变量（Thinking as Latent Variables） 潜变量模型定义了一种概率框架，通过不可观测的**潜变量（latent variables）**来解释可观测数据。这些潜变量捕捉了生成观察结果的隐藏结构或中间过程。语言模型可被视为概率潜变量模型，其中测试时的思考与推理步骤就是潜在的“思维变量”（latent thought variables）（Zhou et al. 2020、Phan et al. 2023）。\n此类模型定义问题$x\\_i$、答案$y\\_i$ 与潜在思维$z\\_i$ 的联合分布。我们的目标是最大化在给定多个思维链情况下的对数似然（$N$ 是样本数，$K$ 是每个问题的CoT数量）：\n$$ \\log L(\\theta) = \\log p(y|x) = \\log \\sum_{k=1}^{K} p(y, z^{(k)}|x) = \\log \\sum_{k=1}^{K} p(z^{(k)}|x) p(y|z^{(k)}, x) = \\log \\mathbb{E}_{z^{(k)} \\sim p(z^{(k)}|x)} [p(y|z^{(k)}, x)] $$我们的目标是，在给定每个问题的若干推理轨迹${z^{(k)}}\\_{k=1}^K$ 的前提下，最大化答案的边际似然$p(y|x)$。\n期望最大化（Expectation-Maximization） 期望最大化算法（Expectation–Maximization, EM） 是一个广泛使用的迭代算法，用于优化带有隐藏变量的模型参数，因此也可用于训练更优的 CoT 并据此生成更优答案。\n该算法通常在以下两个步骤之间迭代，直到收敛：\nE 步骤（Expectation）：估计潜变量的缺失信息（即如何采样更好的 CoT）； M 步骤（Maximization）：在给定潜变量下优化模型参数（即如何生成更好的答案）： $$ \\log L(\\theta) = \\underbrace{\\log \\mathbb{E}_{z^{(k)} \\sim p(z^{(k)}|x)}}_{\\text{E-step}} \\underbrace{p(y|z^{(k)}, x)}_{\\text{M-step}} $$由于我们无法直接从后验分布$p(z|x,y)$ 中采样，研究者们探索了其他方法，如使用人类标注数据（Zhou et al. 2020）、Metropolis-Hastings MCMC 采样（Phan et al. 2023）、或带特殊重要性权重的 Monte Carlo 采样（Ruan et al. 2025）来获得高质量 CoT 样本以更新模型。\nRuan 等人（2025） 实验使用带潜在思维的 Web 文本语料，并采用 EM 算法进行训练，其中潜在思维对每段观察数据合成生成，模型在潜在思维与文本联合建模下以自回归方式学习。\n注入潜在思维后的语料训练流程示意图。（图片来源：Ruan et al. 2025）\n他们首先用一个 LLM$q\\sim$ 在给定观察数据$X\\_i$ 的前提下生成潜在思维$Z\\_i$：\n你将获得一对网页文档的前缀与后缀。你的任务是在它们之间插入潜在思维，来解释后缀是如何基于前缀生成的。潜在思维应包括：缺失的背景知识，以及每个陈述背后的推理过程（特别是逐步推导或逻辑推理）。 通过 \u003cStartOfLatent\u003e\u003cPrior\u003e ... \u003cEndOfPrior\u003e 这样的特殊token，将生成的潜在思维插入原始数据中，以训练联合分布$p(z, x)$ 或近似后验$q(z|x)$，具体取决于插入位置（在$x$ 前或后）。但由于 CoT 是由近似模型$q\\sim(z|x)$ 生成，其性能会受限。\n为解决这一问题，Ruan 等人提出在 E 步中引入重要性权重，其公式为：\n$$ w^{(k)} = \\frac{p(z^{(k)}, x)}{q(z^{(k)}|x)} = \\frac{p(x|z^{(k)}) p(z^{(k)})}{q(z^{(k)}|x)} $$即优先选择那些：能够较好预测观察数据（$p(x|z^{(k)})$ 高）、简单直观（$p(z^{(k)})$ 高）、但又不是过于显而易见的 CoT（$q(z^{(k)}|x)$ 低）。\n迭代学习（Iterative Learning） 由于预训练模型已经具备生成思维链（CoT）的能力，因此可以设计一个直观的迭代改进流程：生成多个 CoT，并仅在**能导出正确答案的推理理由（rationale）**上对模型进行微调。\n然而，这种直接设计可能失败，因为模型在失败的问题上无法获得学习信号。STaR（“自学推理器”，Self-taught reasoner；Zelikman et al. 2022）通过引入“rationalization”过程解决了这个限制：当模型失败时，它会在已知问题和真实答案的条件下向后生成高质量 CoT，以便生成更合理的推理链。然后，模型会在以下两类正确解答上进行微调：一类是自然推导得到正确答案的 CoT，另一类是通过 rationalization 生成的 CoT。\nSTaR 算法示意图。（图片来源：Zelikman et al. 2022）\n我们可以将 STaR 看作是强化学习中策略梯度（policy gradient）的一种近似形式，其中奖励函数为简单的指示函数$𝟙[ŷ = y]$。我们的目标是在$z ∼ p(z|x)$、$y ∼ p(y|x,z)$ 的采样过程中最大化该奖励的期望，因为\n$$ p(y|x) = \\sum_z p(z|x) p(y|x,z) $$推导如下：\n$$ \\nabla_θ J(θ) = \\nabla_θ \\mathbb{E}_{z_i, y_i ∼ p(\\cdot | x_i)} \\mathbb{1}[y_i = y_i^{truth}] \\\\ = \\sum_{i=1}^N \\nabla_θ \\mathbb{1}[y_i = y_i^{truth}] p(y_i, z_i | x_i) \\\\ = \\sum_{i=1}^N \\mathbb{1}[y_i = y_i^{truth}] p(y_i, z_i | x_i) \\nabla_θ \\log p(y_i, z_i | x_i) $$每次迭代等价于：首先根据$\\mathbb{1}[y = y\\_{truth}]$ 筛选 CoT 样本，然后通过监督微调优化生成优质 CoT 与答案的对数概率（logprob）。STaR 的性能随训练迭代次数提升而改善，而“rationalization”过程进一步加速了模型对更优 CoT 的学习。\n他们还观察到：高温采样（high temperature sampling）虽然提高了获得正确答案的几率，但往往伴随着错误的推理链，在这种数据上微调 LLM 会降低泛化能力。对于没有真实标签的数据集，可以采用多个高温输出的多数投票结果作为“代理真值”（proxy ground truth）（Wang et al. 2022），从而使用合成样本进行训练。\n两数相加任务准确率对比示意图。通过 rationalization（基于真实答案生成 CoT），模型能够更早掌握复杂运算任务，如 5 位数加法。（图片来源：Zelikman et al. 2022）\n思考时间的扩展规律（Scaling Laws for Thinking Time） 前文已提供了大量证据表明：在推理阶段允许模型投入更多计算资源以进行思考，在产生最终答案前进行推理，可以显著提升性能。诸如“提示模型生成中间推理步骤”或“训练模型在预测下一个 token 前暂停思考”的技术，均可让模型性能超越训练阶段所获得的能力上限。这本质上为提升模型智能引入了新的维度，与传统 scaling law 中的规模、训练计算量、数据量等因素互补（Kaplan et al. 2020）。\n近期研究表明，优化大语言模型（LLM）在测试时的计算资源使用，可能比单纯扩展参数量更高效（Snell et al. 2024，Wu et al. 2025）。小模型配合高效的推理算法，可以在成本与性能之间提供帕累托最优的权衡。\nSnell 等人（2024） 比较了预训练计算与推理计算的使用情况，并发现两者不可互换。测试时计算在模型能力差距较小时可轻松弥补简单和中等难度问题的缺口，但在困难问题上补偿能力有限。预训练与推理token预算之比至关重要。测试时计算仅在推理token远少于训练token的情况下才具有优势。这表明：构建能力强大的基础模型仍然是核心任务，仅靠推理时计算无法弥补大能力缺口。\n（左）不同推理预算下的准确率变化（迭代修订 vs 并行解码）；（右）小模型+推理技巧 vs 大14倍模型+贪婪解码性能对比。当推理token远少于训练token时，测试时计算的优势最为明显。（图片来源：Snell et al. 2024）\ns1 模型（Muennighoff \u0026 Yang 等人，2025）通过“预算强制”（budget forcing）技术控制思维链长度（即强制加词 \"wait\" 增加推理长度，或使用 \"Final Answer:\" 提前结束推理）。他们观察到：平均思考时间（以token计）与下游任务准确率呈显著正相关。\n并行与顺序扩展的测试时计算方法在 s1 实验中均展现出与评估性能的正相关关系。（图片来源：Muennighoff \u0026 Yang 等人，2025）\n当将此预算强制技术与其他控制 CoT 长度的解码方法对比时，发现一个惊人现象：简单的拒绝采样（即仅接受满足指定长度的生成）反而导致“反向 scaling”——即 CoT 越长，准确率越低。\n（左）思维链路径越长，评估准确率越高；（右）使用拒绝采样控制 CoT 长度时，路径越长反而准确率越低，呈负相关。（图片来源：Muennighoff \u0026 Yang 等人，2025）\n未来展望（What’s for Future） 对测试时计算（test-time compute）和思维链推理（chain-of-thought reasoning, CoT）的探索为提升模型能力带来了新的机遇。更有趣的是，通过测试时思考机制，我们正逐步迈向构建更类人的 AI 系统，这些系统将体现人类思维中的最佳实践，包括适应性、灵活性、批判性反思与自我纠错。\n当前的进展令人振奋，同时也激励我们在未来开展更多研究，不仅要深入理解“我们——以及我们的模型——如何思考”，更要理解“为何思考”。\n在文章的最后，作者呼吁研究者对以下有关测试时计算与思维链推理的未解问题展开进一步研究：\n我们能否激励模型在强化学习（RL）训练过程中，生成人类可读且忠实的推理路径，同时避免奖励欺骗行为？\n如何定义奖励欺骗（reward hacking）？我们能否在不依赖人类干预的前提下，在强化学习训练或推理过程中捕捉奖励欺骗？又如何避免对奖励欺骗的“打地鼠”式（whack-a-mole）修复？\n自我纠错（self-correction）可以在思维链内部发生，也可以在多轮强化学习中被显式激励。我们如何在没有真实标签（ground truth）时，训练模型自我纠错而不引发幻觉（hallucination）或性能退化（regression）？\n对于高度依赖上下文、个性化且难以评分的任务（如创意写作、情感辅导、头脑风暴），我们该如何进行基于 CoT 展开的强化学习训练？\n在实际部署模型时，我们不可能无限增加测试时的思考时间。那么如何将测试时思考带来的性能收益，平滑地转化为基础模型的能力（例如通过 知识蒸馏 distillation 以降低推理成本）？\n如何使测试时计算的投入根据任务难度自动适配？即，模型在遇到困难问题时“多想一会”，在简单任务上则快速给出答案？\nCitation Please cite this work as:\nWeng, Lilian. \"Why We Think\". Lil'Log (May 2025). https://lilianweng.github.io/posts/2025-05-01-thinking/ Or use the BibTex citation:\n@article{weng2025think, title = {Why We Think}, author = {Weng, Lilian}, journal = {lilianweng.github.io}, year = {2025}, month = {May}, url = \"https://lilianweng.github.io/posts/2025-05-01-thinking/\" } References [1] Alex Graves. “Adaptive Computation Time for Recurrent Neural Networks.”. arXiv preprint arXiv:1603.08983 (2016).\n[2] Wang Ling, et al. “Program Induction by Rationale Generation: Learning to Solve and Explain Algebraic Word Problems.”. arXiv preprint arXiv:1705.04146 (2017).\n[3] Karl Cobbe, et al. “Training Verifiers to Solve Math Word Problems.”. arXiv preprint arXiv:2110.14168 (2021).\n[4] Jason Wei, et al. “Chain of Thought Prompting Elicits Reasoning in Large Language Models.”. NeurIPS 2022.\n[5] Maxwell Nye, et al. “Show Your Work: Scratchpads for Intermediate Computation with Language Models.”. arXiv preprint arXiv:2112.00114 (2021).\n[6] Daniel Kahneman. Thinking, Fast and Slow. Farrar, Straus and Giroux (2013).\n[7] Takeshi Kojima, et al. “Large Language Models are Zero-Shot Reasoners.”. NeurIPS 2022.\n[8] Michihiro Yasunaga, et al. “Large Language Models as Analogical Reasoners”. arXiv preprint arXiv:2310.01714 (2023).\n[9] Eric Zelikman, et al. “STaR: Bootstrapping Reasoning With Reasoning.”. NeurIPS 2022.\n[10] Xuezhi Wang, et al. “Self-consistency Improves Chain of Thought Reasoning in Language Models.”. ACL 2023.\n[11] Ryo Kamoi, et al. “When Can LLMs Actually Correct Their Own Mistakes? A Critical Survey of Self-Correction of LLMs.”. TACL 2024.\n[12] Jie Huang, et al. “Large Language Models Cannot Self-Correct Reasoning Yet.”. ICLR 2024.\n[13] Noah Shinn, et al. “Reflexion: Language Agents with Verbal Reinforcement Learning.”. arXiv preprint arXiv:2303.11366 (2023).\n[14] Yunxiang Zhang, et al. “Small Language Models Need Strong Verifiers to Self-Correct Reasoning.”. ACL Findings 2024.\n[15] Hao Liu, et al. “Chain of Hindsight Aligns Language Models with Feedback.”. arXiv preprint arXiv:2302.02676 (2023).\n[16] Sean Welleck, et al. “Generating Sequences by Learning to Self-Correct.”. arXiv preprint arXiv:2211.00053 (2023).\n[17] Yuxiao Qu, et al. “Recursive Introspection: Teaching Language Model Agents How to Self-Improve.”. arXiv preprint arXiv:2407.18219 (2024).\n[18] Aviral Kumar, et al. “Training Language Models to Self-Correct via Reinforcement Learning.”. arXiv preprint arXiv:2409.12917 (2024).\n[19] Hunter Lightman, et al. “Let’s Verify Step by Step.”. arXiv preprint arXiv:2305.20050 (2023).\n[20] Yuxi Xie, et al. “Self-Evaluation Guided Beam Search for Reasoning.”. NeurIPS 2023.\n[21] Yangzhen Wu, et al. “Inference Scaling Laws: An Empirical Analysis of Compute-Optimal Inference for Problem-Solving with Language Models”. ICLR 2025.\n[22] Dongwei Jiang, et al. “RATIONALYST: Pre-training Process-Supervision for Improving Reasoning”. arXiv preprint arXiv:2410.01044 (2024).\n[23] Xuezhi Wang and Denny Zhou. “Chain-of-Thought Reasoning Without Prompting.”. arXiv preprint arXiv:2402.10200 (2024).\n[24] DeepSeek-AI. “DeepSeek-V3 Technical Report.” arXiv preprint arXiv:2412.19437 (2024).\n[25] DeepSeek-AI. “DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning.”. arXiv preprint arXiv:2501.12948 (2025).\n[26] Luyu Gao, Aman Madaan \u0026 Shuyan Zhou, et al. “PAL: Program-aided Language Models.”. ICML 2023.\n[27] Shunyu Yao, et al. “ReAct: Synergizing Reasoning and Acting in Language Models.”. ICLR 2023.\n[29] Bowen Baker, et al. “Monitoring Reasoning Models for Misbehavior and the Risks of Promoting Obfuscation.”. arXiv preprint arXiv:2503.11926 (2025).\n[30] Wojciech Zaremba, et al. “Trading Inference-Time Compute for Adversarial Robustness.”. arXiv preprint arXiv:2501.18841 (2025).\n[31] Tamera Lanham, et al. “Measuring Faithfulness in Chain-of-Thought Reasoning”. arXiv preprint arXiv:2307.13702 (2023).\n[32] Boshi Wang, et al. “Towards Understanding Chain-of-Thought Prompting: An Empirical Study of What Matters.”. ACL 2023.\n[33] Miles Turpin, et al. “Language Models Don’t Always Say What They Think: Unfaithful Explanations in Chain-of-Thought Prompting.”. NeuriPS 2023.\n[34] James Chua \u0026 Owain Evans. “Are DeepSeek R1 And Other Reasoning Models More Faithful?”. arXiv preprint arXiv:2501.08156 (2025).\n[35] Yanda Chen et al. “Reasoning Models Don’t Always Say What They Think”. arXiv preprint arXiv:2505.05410 (2025).\n[36] Edward Yeo, et al. “Demystifying Long Chain-of-Thought Reasoning in LLMs.”. arXiv preprint arXiv:2502.03373 (2025).\n[37] Mostafa Dehghani, et al. “Universal Transformers.”. ICLR 2019.\n[38] DeLesley Hutchins, et al. “Block-Recurrent Transformers.”. NeurIPS 2022.\n[39] Aydar Bulatov, et al. “Recurrent Memory Transformers.”. NeuriPS 2022.\n[40] Jonas Geiping, et al. “Scaling up Test-Time Compute with Latent Reasoning: A Recurrent Depth Approach.”. arXiv preprint arXiv:2502.05171 (2025).\n[41] Herel \u0026 Mikolov. “Thinking Tokens for Language Modeling.”. AITP 2023.\n[42] Sachin Goyal et al. “Think before you speak: Training Language Models With Pause Tokens.”. ICLR 2024.\n[43] Eric Zelikman, et al. “Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking.”. arXiv preprint arXiv:2403.09629 (2025).\n[44] Wangchunshu Zhou et al. “Towards Interpretable Natural Language Understanding with Explanations as Latent Variables.”. NeurIPS 2020.\n[45] Du Phan et al. “Training Chain-of-Thought via Latent-Variable Inference.”. NeurIPS 2023.\n[46] Yangjun Ruan et al. “Reasoning to Learn from Latent Thoughts.”. arXiv preprint arXiv:2503.18866 (2025).\n[47] Xuezhi Wang et al. “Rationale-Augmented Ensembles in Language Models.”. arXiv preprint arXiv:2207.00747 (2022).\n[48] Jared Kaplan, et al. “Scaling Laws for Neural Language Models.”. arXiv preprint arXiv:2001.08361 (2020).\n[49] Niklas Muennighoff \u0026 Zitong Yang, et al. “s1: Simple test-time scaling.”. arXiv preprint arXiv:2501.19393 (2025).\n[50] Peiyi Wang, et al. “Math-Shepherd: Verify and Reinforce LLMs Step-by-step without Human Annotations” arXiv preprint arXiv:2312.08935 (2023).\n[51] Yixin Liu, et al. “Improving Large Language Model Fine-tuning for Solving Math Problems.” arXiv preprint arXiv:2310.10047 (2023).\n[52] Charlie Snell, et al. “Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters.”. arXiv preprint arXiv:2408.03314 (2024).\n[53] OpenAI. o1-preview: “Learning to reason with LLMs.” Sep 12, 2024.\n[54] OpenAI. o3: “Introducing OpenAI o3 and o4-mini.” Apr 16, 2025.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Why We Think",
    "uri": "/agi/why-we-think-ch/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  C2",
    "content": "Decision Advantage and Initiative Completing Joint All-Domain Command and Control\nBrian R. Price\nAbstract 本文在约翰·博伊德（John Boyd）的观察、定向、决策、行动（OODA）循环和他的《指挥与控制的有机设计》（1987）分析的背景下定义了决策优势和主动权。博伊德的思想远远超越了他所在的时代，但在当今不断变化的作战环境中仍具有重要的现实意义。决策优势的结果是主动权。此外，决策优势不仅是一种状态，也是实现这种优势所需的过程。由于人类仍然是有效的联合全域指挥与控制的关键，规划者和战略家必须接受有关这些关键概念的理论细微差别的教育。\n以空军对决策优势的概念为基础，本文提出了在决策与执行（即规划、决策和执行过程中的“d”和“e”）之间建立更紧密联系的建议。决策优势植根于退役的美国空军上校约翰·博伊德的指挥与控制决策循环概念，本文通过主动权的概念进一步拓展了他的思想。本文提出的主动权工作定义和对空军决策优势定义的修改，完善了联合全域指挥与控制（JADC2）的概念。这些变革有助于联合作战力量创造一种决策氛围，鼓励教育的开展，从而将态势感知纳入更广泛的理解中，并融入那些更难以量化的人为因素的复杂性。\nIntroduction 决策优势：决策优势是态势理解、确保和交换信息的能力，以及通过在各个领域保持优势来进行和传达决策的产物。——《空军条令出版物3-99》，2021年11月19日\n布莱恩·普莱斯博士是空军指挥与参谋学院战斗部门的副教授。\n文职和军事领导人在所需的速度下做出及时的决策，以超越对手。决策需要一个共同的情报图景和对全球部队部署的共享理解，以实时观察作战行动：识别抓住主动权的机会，识别权衡、风险和机会成本。自动化、预先计划的响应和任务指挥对于以所需的相关速度采取行动至关重要。——《联合出版物3-0》，2022年6月\n国防部对联合全域作战（JADO，前身为多域作战）的接受，已引发了一系列发展和组织活动，这些活动由对作战环境变化的感知以及特定近敌对手挑战美国安全领导地位的努力所激发。指挥与控制是所有军种对多域或全域作战概念的核心。鉴于新兴技术对过去规划、决策和执行周期限制的潜在深远影响，本文——作为空军大学2020年JADC2会议的成果——通过博伊德1987年简报《指挥与控制的有机设计》的视角，探讨了决策优势的概念。\n尽管博伊德的脾气暴躁减少了他帮助国防机构的效果，但他在20世纪80年代末的著作在考虑JADC2的意图和架构时，显得出奇地预见性。对博伊德思想的研究可以帮助当前一代的规划者和架构师更好地理解可能性。\n无论使用何种技术来驱散战争中的迷雾与摩擦，人类因素——信仰、信任、共同愿景、身份认同、知识、经验、教育与训练等——可以说对JADC2系统的重要性丝毫不亚于传感器网络、开放数据标准与交换、网状连接、云计算或边缘计算、人机协作、机器学习，甚至人工智能（AI）。俄罗斯对该问题的应对方式表明，俄罗斯的规划者将人类因素视为JADC2系统中最薄弱的环节之一，或可能是其最强有力的方面。\n本文探讨了似乎支撑国防部JADC2系统的一个基本信条——博伊德的观察、定向、决策、行动（OODA）循环。本文并不质疑国防部对这一决策模型的采用。此外，尽管本文探讨了JADC2条令和架构设计，但由于篇幅限制，未涉及作为实践的条令制定的适用性。\nBackground 关于军事革命的概念存在激烈的争论。尽管如此，许多美国军事、盟友和合作伙伴的规划者都认识到正在进行的一场革命，俄罗斯和中国也同样注意到这场革命，它利用了新兴技术。这些技术包括传感器网络、开放架构数据框架、机器学习（“弱”AI）、云计算或边缘计算以及高级分析。此外，这些技术有可能超越现有的规划、决策和执行过程。联合全域指挥与控制旨在为下一代决策者提供根本性优势，但这些技术将如何塑造未来的规划、决策和执行周期，目前尚未明确阐述。\n然而，决策本身并不提供优势；相反，由决策产生的行动——即夺取和保持主动权——才能带来优势。主动权是安全领域内一个未被充分重视的概念，尽管它类似于体育运动中的动量概念，但却难以评估。\n将决策与行动联系起来的问题引发了军事规划者之间的辩论：决策优势是部分由信息优势、训练、教育和人类领域内的其他因素导致的一种状态，还是代表了实现预期效益所必需的过程？事实上，在制定决策优势的全面理论定义时，考虑这两种概念都是至关重要的。无论拥有多少态势感知，都无法替代初级或高级领导者的理解。此外，即使操作执行得再完美，如果战略本身存在缺陷，也可能会失败，正如在阿富汗所发生的那样。\n定义决策优势的基础 尽管高级领导层采用了“信息优势”和“决策优势”这两个术语来表达对联合全域作战（JADO）方法的期望收益，但多年来“决策优势”一直未能被国防部明确定义。在未分类的JADC2和多域作战/JADO文件中提到过决策优势的概念，但并未清晰定义，尽管JADC2系统的全部目的就是“决策的艺术与科学，以及将这些决策转化为行动的能力，利用跨所有领域和任务伙伴的能力，在竞争和冲突中实现作战优势。”最终，在2021年11月，空军发布了其定义。\n图1. 修改后的JADC2高层作战图示\n有些人可能会认为JADC2就是决策优势。上述定义在整个冲突连续体中提供了有用的联系，尽管它并未明确将这一概念与JADC2的技术架构联系起来。这个定义也出现在2020年空战司令部关于JADC2的关键图形总结（图1）中，任务是“以压倒性的决策优势挫败敌人的进攻”，但同样没有明确定义什么是决策优势。\nJADC2的概念是一种旨在提供卓越态势感知的架构。理解JADC2至少需要深入的领域知识，理想情况下，还需要跨领域的知识，这反映了在形成背景时相互碰撞和交互的关键视角。\n在美国军队中，人机协作增强了决策过程。陆军多域作战条令指出，“由人工智能和高速数据处理支持的人机界面，提高了人类决策的速度和准确性。”《2028年多域作战中的美国陆军》，美国陆军训练与条令司令部（TRADOC）手册525-3-1，强调攻击对手的情报、监视和侦察体系：“陆军部队与伙伴及联合部队协作，反制敌方侦察，并实施欺骗，以在敌方决策过程中制造不确定性。”此外，它还指出，“在竞争中展示的能力削弱了对手的信息战行动，并在其决策过程中制造复杂性和不确定性。”\n这与俄罗斯的做法类似，其目的是在决策循环中注入模糊性，以创造机动空间。这也类似于中国的决策方式，中国通过“系统毁灭战”来阻止关键信息的获取并导致瘫痪。\n尽管陆军手册没有定义或使用“决策优势”这一术语，但它确实使用了“决定性空间”这一术语，并将其定义为“在时间和空间（物理、虚拟和认知）中，通过跨域能力的全面优化使用，产生显著优势并极大地影响作战结果的位置。”这似乎是对“决定性点”这一熟悉概念的改编，并且与中国选择对手系统中的关键点并设计对抗系统来进行打击的概念相似。\nTRADOC 525-3-1还讨论了预测性保障作战： 精确后勤保障依赖于一个保障企业资源计划决策支持系统（重点突出），该系统具有预测分析工具和无需请求即可补给或根据优先级重新分配物资的能力；以及指挥官和后勤人员在各级能够查看的实时共同作战图景。\n这样的系统对于支持敏捷作战部署或其他形式的动态部队部署是绝对必要的。\n最后，陆军的综合作战行动旨在协调“与信息相关的能力（IRC），与其他作战线相结合，影响、欺骗、破坏、腐蚀或颠覆敌人和对手的决策，同时保护我们自身”，并影响敌人和民众的战斗意志。TRADOC 525-3-1强调了削弱敌方决策能力的重要性，并建议保护美国的类似能力。在TRADOC 525-3-1的构想中，优势主要通过攻击敌方的认知能力而非构建一个更优越的决策流程和信息环境来获得。\n前陆军未来司令部司令约翰·M·默里（John M. Murray）将军在2021年3月的一次采访中引用前陆军参谋长詹姆斯·麦康维尔（James McConville）将军对“决策主导”一词的使用，清晰地表达了陆军对决策优势的定义：“这是一个正在发展的定义，但目前来看，‘决策主导’是指指挥官能够比任何对手更快、更有效地感知、理解、决策、行动和评估的能力。”默里的这一概念与博伊德的OODA循环非常接近。\n从情报的角度来看，另一种分析指出，可用的、适当分析和保护的情报“可以提供决策优势，使决策者获得更好的信息，并以一种没有这些情报就无法实现的方式理解问题的更多方面”，并且“当对手或竞争者不具备相同的见解或不了解对方决策者所知内容时，这种决策优势尤为关键。”\n这种来自情报界的决策优势概念具有许多优势。在决策者与其对手的比较中，“更好地了解”和“理解问题的更多方面”是基础。这些条件体现了信息和背景的质量，从而导致更优越的理解。\n在讨论JADC2和2021年全球信息主导演习时，美国北方司令部官员表示，“新的人工智能将即时汇集各种数据，为指挥官提供战场的清晰图景，从而做出良好而迅速的决策。”这些官员指出，“关键在于，由AI系统——而不是过去那样缓慢的人类——迅速提供并不断升级最佳选项，以确保高概率的拦截成功率。”美国北方司令部J8 JADC2开发负责人最近解释说：\n“现在，人类可以有更多的时间和更多的选项来做出决策。”\n……[这个工具的想法是提供]一个关于竞争者正在做什么的更早期和更好的理解……这个工具让我们能够看到：竞争者在日常基础上的行动是什么，他们在机场、指挥控制设施以及他们将用于海上行动的地方做了些什么。\n2020年，美国北方司令部司令特伦斯·O’Shaughnessy将军表示，“[JADC2] 将为我们的决策者提供信息，帮助他们做出类似下棋般的决策，思考两到三步之后的动作。它将以相关的速度为决策者提供做出非常复杂决策的能力。”\n博伊德的OODA循环、有机指挥与控制（C2）以及主动权概念 回顾博伊德的OODA循环——这是支撑JADC2的关键基础概念——可以发现现有理论和操作文件中未能涵盖的关于决策优势的一些方面。OODA循环的决策周期概念位于JADC2和JADO愿景与架构文件的核心，假设在技术发展的推动下，更快且拥有更全面的信息进行行动是必要且不可避免的。然而，这一假设曾受到博伊德的挑战。\n在20世纪后期，模糊性、主动权和决策的问题引起了博伊德的注意。虽然博伊德的一些成就可能被夸大了，但他持久的贡献在于将战略家、规划者和行动者的战争、冲突和竞争概念从基于规模转向基于节奏和破坏的模式。这些思想在当今快节奏的技术创新环境中显得更加相关。博伊德是最早提出这些概念的人之一——或许有些过早了——但他的工作对当今的环境仍具有相当的见解，尤其是在模糊性已成为美国近敌对手首选武器的当下。\n简化版OODA循环模型在决策中的广泛接受，证明了博伊德这一引人注目的启发式方法的普及。在军事、商业和战略写作中，“决策周期”一词常常与OODA循环同义。在由所有主要国防部利益相关者制定的图1中，这一循环被呈现为“理解、决策、指挥、实施、评估”。在JADC2文献中，OODA概念作为核心基础，一套需要仔细审视的假设。\n在他的空军生涯中，博伊德对战斗机战术的教学和战斗机设计中机动性的实现与工程作出了重要贡献，这些成就通过他与数学家汤姆·克里斯蒂（Tom Christie）共同开发的能量机动性理论得以实现。在职业生涯后期，博伊德发展了他的核心思想，融入了复杂自适应系统的概念，这些概念现在已反映在国防部的理论中。博伊德通过他多次修订的“冲突模式”简报以及一系列其他不那么宏大但富有洞察力的作品，广泛探讨了冲突问题。\n尽管“冲突模式”受到了广泛关注，但他1987年的一份不太为人所知的简报“指挥与控制的有机设计”定义了今天常用的OODA循环。在“有机设计”中，博伊德阐述了他的愿景。其目的不仅是要更快速地行动，还要创造导致对手混乱和瘫痪的环境，即“在对手的观察-定向-决策-行动循环内作战，将对手困在一个充满不确定性、怀疑、不信任、混乱、无序、恐惧、恐慌和混乱的世界中……或者将对手反折回他自己内部，使其无法应对正在展开的事件和行动。”这后半部分“将对手反折回他自己内部，使其无法应对正在展开的事件和行动”与俄罗斯的反射性控制概念以及中国分解系统链条以孤立系统各部分的做法非常相似，使得各部分之和小于整体。\n博伊德进一步强调了指挥与控制中社会、智力和文化方面的重要性，他总结道，由“基因遗产、以往经历和正在展开的环境”所提供的凝聚力有助于通过滤镜创建环境图景。滤镜源于人类的经验——这些是塑造观察和定向的有形和无形元素。反过来，人为因素是通过决策循环过程取胜的重要推动力。博伊德认为，这一过程就是指挥与控制：“观察-定向-决策-行动的过程代表了指挥与控制过程中发生的事情——这意味着OODA循环可以被认为就是C\u0026C循环。”\nJADC2架构和概念反映了旨在显著提高作战节奏和复杂性的最新发展。这不仅缩短了决策周期，还将其压缩到了所谓的“OODA点”，即数据源的速度和复杂性超出了人类的处理能力。因此，操作员越来越依赖于人机协作、机器学习，最终依赖人工智能（AI）。因此，中国和俄罗斯等近敌竞争者采取了各自的方法，试图介入美国的规划、决策和执行循环。\n在近期竞争和冲突中，决策周期潜力的明显压缩是重要的，但这一概念可能是不完整的。长期研究博伊德思想的弗朗斯·奥辛加（Frans Osinga）谨慎地指出，如果仅仅将OODA循环与时间对齐，往往会被误解。\n对博伊德作品的全面概述表明，OODA循环不仅仅代表或意味着一个决策过程，这一模型包含了比信息优势和速度更多的胜利因素……第一个误解涉及速度要素。快速的OODA循环想法暗示了对决策速度的关注，并通过更快地完成连续的OODA循环来“超越”对手。\n奥辛加的这种说法可能是在讨论JADC2的核心假设，即所提议的计算/数据架构忽略了许多因素——特别是人类维度，有时也被称为人类领域。这些元素在考虑到敌方有意降低系统性能、散布虚假信息以及通过制造模糊性来延迟反应时，是必须考虑的。\n博伊德的工作未能认识到并支持利用传感器和计算机技术显著改善态势感知的潜在好处——例如空军的低空导航与夜间目标红外系统（LANTIRN）、空中预警与控制系统（AWACS）E-3哨兵和E-8C联合监视目标攻击雷达系统（Joint STARS）。很明显，他对越南战争后期传感器网络的否定过于矫枉过正。很少有美国人在越南战争后的世界，甚至是在“9/11”后的战场上，会轻易在没有这些平台或即将替代它们的平台的情况下参战，尽管它们在近敌作战环境中的生存能力受到了挑战。然而，博伊德在其关于“有机”指挥与控制的“替代愿景”中提出的人类因素，值得重新审视，特别是在俄罗斯和中国积极注入模糊性到竞争和冲突环境中，或阻止进入电磁频谱，从而对抗JADC2所追求的清晰性。\n博伊德的工作在近20年的时间里不断发展这一主题。在《指挥与控制的有机设计》中，他提到了当代指挥与控制在行动中的失败，例如西贡撤离（1975年）和沙漠一号行动（1980年）：\n机构应对这些失败的反应是更多更好的传感器、更多的通信设备、更多更好的计算机、更多更好的显示设备、更多的卫星、更多更好的信息融合中心等等——所有这些都整合到一个巨大的、完全信息化、完全能力化的指挥与控制系统中。这种思维方式强调硬件是解决方案……\n我认为还有另一种方式——一种强调人类隐性本质的方式……\n[我们]需要洞察力和愿景……焦点和方向……适应性……[以及]安全。\n博伊德对越南战争后努力克服战争迷雾和摩擦的概念类似于今天的传感器网络、数据架构以及对云计算/边缘计算的强调。虽然博伊德显然忽略了当指挥与控制系统正常运行时，通过态势感知所提供的实质性好处——正如在阿富汗、伊拉克、叙利亚等地的空中和传感器作战中所展示的那样——但他关于人类力量和人类领域的观点在国防部试图构建一个强大、有能力和敏捷的JADC2系统时绝不能被忽视。\n从卡尔·冯·克劳塞维茨（Carl von Clausewitz）的思想出发，博伊德得出以下结论：\n战争的氛围就是摩擦。\n摩擦由威胁、模糊性、欺骗、迅速性、不确定性、不信任等因素产生并被放大。\n摩擦通过隐性理解、信任、合作、简单、专注等因素被减少。\n从这个意义上说，多样性和迅速性倾向于放大摩擦，而和谐和主动性倾向于减少摩擦。\n（博伊德的观点强调了人类因素的重要性，即使在高度技术化的作战环境中，信任、合作和简化等因素在减少战争中的摩擦方面仍然至关重要。）\nJADO（联合全域作战）方法掌握了许多这些要素，试图通过广泛的传感器、数据弹性和边缘计算来减少战争迷雾和摩擦，通过在多个领域的同时行动制造混乱，从而进入对手的OODA循环。然而，当前对JADC2（联合全域指挥与控制）的描述仍然强调速度和信息优势。它们似乎还没有完全接受服务文化或人类因素的变化，这些变化对于实现JADC2概念的全部潜力至关重要，或者更紧迫的是，防范对手创造模糊性、混乱、无序、孤立和延迟（甚至瘫痪）行动的努力。正如上文提到的，中国和俄罗斯采取的方法旨在破坏美国的决策循环，特别是在关键的定向阶段。\n博伊德将定向定义为OODA循环中的关键步骤。他写道：“定向是重心（schwerpunkt）”，它“代表了由遗传传统、文化背景、以往经验和正在展开的环境所塑造的世界的图像、观点或印象。” 换句话说，JADO的信息优势网络所产生的硬数据视图将根据参与者的共享和独特视角被参谋人员和决策者过滤。\n要实现统一的行动，参与者需要有共享的经验、文化和信任。用博伊德的话来说，“定向是一个多方面隐性交叉参照、共情、关联和拒绝的互动过程，这一过程由遗传传统、以往经验和正在展开的环境之间的相互作用所塑造并反过来塑造这些相互作用。” 更具挑衅性的是，他提出了一种去中心化的指挥与控制观念，主张以领导力代替指挥，以理解（监控）代替控制。博伊德强调协调一致的“和谐”去中心化的力量，并指出“理解和领导比指挥与控制（C\u0026C）更适合、更丰富地调整和适应环境。”\n博伊德清楚地理解，推动行动进入并穿透对手的决策循环的目的是制造混乱、无序和瘫痪。值得重申的是，人类因素，包括信仰、信任、共同愿景和身份认同、知识、经验、教育和培训，对JADC2系统的重要性与传感器网络、开放数据标准与交换、网状连接、云计算/边缘计算、人机协作、机器学习，甚至人工智能（如果它能完全发展起来）同样重要。人类因素将成为JADC2系统中最薄弱的环节和最强大的方面。\n主动权的概念 关键的人类因素决定了主动权的概念。主动权，或推动行动的能力，是通过OODA模型在竞争和冲突中奠定基础的。在军事圈子里，特别是有时会有一种信念，即采取行动——任何行动——都比将主动权让给对手要好。\n在最新版本的《联合出版物3-0：联合战役和行动》中，对主动权进行了广泛讨论。在关于联合职能的部分中，主动权被提及六次，并明确与指挥与控制、任务指挥概念以及保障相关联。附录A与进攻性联合行动的原则相关，“进攻的目的是夺取、保持和利用主动权”，但主动权本身并没有被定义。\n将主动权与进攻联系在一起的一个问题是，主动权也可以与防御和诱导行动联系在一起：如果一方引诱对手采取行动，而对手照做了，那么即使是在防御中，对手也掌握了主动权。这可能看起来像是以防御为掩饰的进攻，但将主动权严格地与进攻联系在一起会在参谋军官和指挥官中产生一种错误的预期，即进攻等同于主动权。\n脱离国防部术语的主动权概念在定义通过决策优势所寻求的目标时是有用的。《联合出版物3-0》中提到主动权近40次，并将其作为一个作战阶段来讨论——“利用主动权以实现作战层面的目标。”具体而言，“与夺取主动权相关的部队部署可能具有足够的威慑作用，以劝阻敌人进行进一步的行动，使[作战环境]恢复到更稳定的状态。”\n此外，主动权在联合行动原则中与进攻紧密相关：“进攻性行动是军事力量在保持行动自由和实现有意义目标的同时，夺取和保持主动权的方式。” 重要的不是决策本身，而是决策所带来的主动权和控制力。\n《牛津英语词典》中提供了一个有用的主动权定义：“采取领导，迈出第一步，发起某种行动”；“发起某事的权力、权利或功能，因此，拥有或掌握主动权”；以及“通过某种推动力来驱动或强迫……”。主动权的概念将决策与行动联系起来。主动权使对手不得不重新启动OODA循环，耗费时间，并播下怀疑、混乱、模糊、不信任等情绪，从而削弱博伊德所强调的信心、确定性、清晰性和信任。因此，本文提出以下工作定义：主动权是由及时决策和行动所产生的推动力，使行动自由成为可能，同时限制对手的选择。\n竞争或基于冲突的决策的目标是推动行动，迫使或引诱对手做出反应；成为行动的主体，而不是被动对象；并通过行动迫使对手重新观察、重新定向、重新决策和反应。主动权是一种零和的、二元的资源；战斗双方之一可能拥有它，但不可能同时拥有。然而，也可能双方都不具备主动权，并且在感知与现实之间可能存在差异。一个人可能相信自己拥有主动权，但实际上并没有。\n在国际象棋、围棋或单打决斗中，主动权是显而易见的。如果一个人感到不得不做出某个动作，而他显然更希望做另一个动作时，对手就掌握了主动权，成为了驱动这一行动的人。如果情况反过来，对手就失去了行动自由，被迫做出反应，而不是按照自己的意愿行事。\n这一概念可以推广到战术、作战和战略层面。这也是研究战略游戏、武术或军事和政治历史对于培养军事领域专长有用的部分原因；通过经验，人们能够识别模式，从混乱中提炼出秩序，建立起做出决策的信心，从而传递主动权。任何关于决策优势的定义都应包括夺取和保持主动权的意图。\n决策优势：状态与过程 困扰军事规划者的一个问题是，决策优势到底是代表一种状态还是一种过程。将其视为状态的观点认为，决策优势是一种由技术辅助理解所支持的状态，从而能够做出决策。过程观点则认为，如果不与实现这种状态的方法相联系，那么这种状态是毫无意义的，即必须有具体的方法将理解转化为计划和行动。\n多年来，空军指挥与参谋学院的联合全域战略家（前称多域作战战略家）项目的毕业生们学会了通过威胁信息驱动的决策支持矩阵来增强联合规划过程。通过预测在作战或战略层面推动决策点所需的信息，这类矩阵框架能够收集指挥官的关键信息需求，分析并清晰地呈现风险，并将决策与作战或战略设计相连接。即使使用手动过程，决策支持矩阵的开发和使用虽然需要大量工作人员，但能够在关键时刻实现更快和更有依据的决策。\n(这种观点将决策优势视为一个过程的结果，通过具体的方法和工具，如决策支持矩阵，将理解转化为行动，而不是将其仅仅看作一个由技术辅助的静态状态。因此，过程观点强调了将决策优势从状态转变为具体行动能力的必要性。)\nCOA 1：第1阶段 准备 决策点 NAI/TAI 事件 需要的决策 决策标准 可用资源 CJTF行动 将地面部队力量转移到阿塞拜疆边境 地面部队（LC）向西北伊拉克边境移动进行地面演习（D-1） 最高领导人宣布C日 第0阶段（塑造）完成 空中 - ISR\n海上 - ISR；SPOD防御\n特种作战部队 - ISR；信息作战\n地面 - 演习姿态单位；力量保护\n电子战 - Jx（需要频谱主导）\n空间 - NTM 部署地面部队至阿塞拜疆（AZJ）边境\n开始信息作战行动\n将综合防空系统（IADS）提升至最高戒备状态 1 最高领导人批准部署 国土防御能力绿灯 假设 假设的反应 关键指挥官情报需求（CCIRs） 向美国和阿塞拜疆（AZJ）提供明确的警告 阿塞拜疆发布新闻稿，谴责部队向其边境移动 首要情报需求（PIR）：\n- 美国和阿塞拜疆的战备状况\n- GOAZ的状态\n- 阿塞拜疆关键基础设施的状态 无美国地面部队反对 阿塞拜疆防御部队进入高度戒备状态 紧急信息报告（FFIR）：\n- 综合防空系统（IADS）的姿态/警戒/战备水平 美国和其他国家的情报、监视与侦察（ISR）收集 可能美国对部署部队进行空袭 风险 对任务的影响 发生概率 缓解措施 缓解后剩余风险 将地面部队（LC）转移至阿塞拜疆（AZJ）边境，使美国和阿塞拜疆察觉我们的计划 缩短我们在美国干预前采取行动的时间线 中等 在第0阶段期间，在伊拉克（IZ）边境建立地面演习历史\n通过媒体广泛宣传演习\n向美国提供有关演习合法性的情报 低 不将地面部队转移至阿塞拜疆边境，导致无法为进入阿塞拜疆做好准备 严重拖慢时间线，并迫使整体计划发生变化 高 无 高 图2. 空军指挥与参谋学院联合全域战略家项目演习的决策支持矩阵\n在JADC2架构下，通过自动化，应当可以在很大程度上自动化收集和呈现由工作人员制定的决策支持矩阵，包括动态创建新的力量和资源配置所需的变更，从而实现显著更快的决策和作战相关行动。\n对于这一想法的支持者来说，围绕已知的决策框架创建一个自动化系统是将决策优势概念付诸实践的关键。从某种意义上说，过程视角抓住了从决策到行动的连接需求，正如前文讨论的那样，这是主动权的体现。因此，决策优势是一种持有优势的状态。然而，没有过程，这种优势是毫无意义的，因为它无法转化为对主动权的掌握。\n（这种观点强调，决策优势不仅仅是占据有利位置的状态，更是将这种状态通过具体的过程转化为行动的能力。自动化系统通过在已知的决策框架内高效执行这些过程，有助于确保决策优势能够真正转化为有效的作战行动，进而掌握并保持主动权。）\n定义决策优势 鉴于OODA循环概念的性质，强调了人类因素、速度和信息优势，以及主动权概念的重要性，本文提出了一个决策优势的定义。第一部分定义了决策优势本身，而第二部分则将JADC2置于OODA概念和人类因素的背景下，结合对手的作战方法来进行探讨：决策优势是在正确的时间获取并识别正确信息（信息优势），从而能够做出及时决策并将其转化为行动，从而夺取或保持主动权。\n美国空军最近发布的《空军条令出版物3-99/太空军条令出版物3-99：空军在联合全域作战中的作用》中，将决策优势定义为“态势理解、确保和交换信息的能力，以及通过在各个领域保持优势来做出和传达决策的产物。” 这个定义有许多值得称赞之处。它强调了理解而非单纯的意识。与本文作者的提议不同，它强调了通信的核心作用，并将决策与传达决策的需求联系起来。然而，它也提出了在所有领域保持优势的必要性，这在实践中可能难以实现——尽管毫无疑问，如果能够以某种方式实现，这将是一个理想的情况。\n然而，空军的定义仍然缺乏一个强调决策优势重要性的核心要素——主动权的传递。对军种定义的修改，若能更紧密地将决策与主动权联系起来，可以表述如下：决策优势是态势理解的产物，确保和交换信息的能力，以及做出并传达决策以在关键领域夺取或保持优势的能力。\n(这个修改后的定义不仅保留了原有的态势理解和信息优势的要素，还加强了主动权的重要性，将决策与实际的作战效果紧密相连。通过这样的定义，决策优势不仅仅是信息优势和通信能力的集合，更是通过这些能力最终在关键领域中获得并保持主动权的手段。)\n无论采用哪种定义，决策优势都依赖于优越的理解、自信和信任，这些要素能够克服模糊性并创造清晰性。决策通过夺取和保持对敌人或竞争对手的主动权，迫使其重新观察和重新定向，延迟其决策，最终剥夺其行动甚至保持团结的能力。同时，决策优势旨在最大化友方的行动自由、团结一致以及引导对手朝着有利于美国的决策、目标和最终状态前进的能力，这在一些俄罗斯文献中被称为反射性控制。\n优越的理解源自相关的知识、经验、适当的智力工具、教育和培训；自信源自对理解、愿景、目标、权限和意图的清晰把握——即已知的事物。信任则通过支持既有关系中的风险来对抗未知。因此，决策优势的对立面可能是瘫痪——无法进行定向、决策和行动。\n大卫·爱泼斯坦（David Epstein）最近有力地论证了跨领域和多领域知识的重要性——在这里指的是学术领域，而不一定是作战领域——这种知识在一个高度专业化的世界中解决棘手问题时可能具有巨大的价值。如果爱泼斯坦的观点是正确的，那么广泛而深入的教育对于在不同领域之间转移知识并找到对专家们来说似乎难以解决的问题的解决方案是必要的。此外，当前已知的AI固有限制性，这表明适应性和灵活性是战胜相对狭窄但极为迅速的机器判断的关键。\n爱泼斯坦关于跨领域知识是应对模糊性困境的有力武器的论点，与军事领域中多域或全域作战的概念相呼应，这些作战模式是对敌人实现优势的关键。在这两种观点中，来自单一领域之外的信息或知识的意识能够带来重要的优势。\n(通过综合理解、跨领域知识和信任建立的决策优势，军事规划者可以更好地应对充满不确定性和复杂性的作战环境。主动权的获得不仅仅是信息优势的结果，还依赖于将这些信息转化为行动的能力，以及应对敌方干扰和模糊性策略的灵活性。正如反射性控制概念所强调的那样，决策优势最终在于能够引导并掌控战局的发展方向，而这需要全面的知识基础和灵活的思维方式。)\n乌克兰部队的小型单位创新与俄罗斯部队的中央化指挥形成了鲜明对比，这种对比具有启示性。乌克兰军民不仅拥有技术优势，而且还怀着强烈的保家卫国的愿望，凭借即时创新的技术和战术，令俄罗斯对手措手不及。像M142高机动性火箭炮系统、美国的情报、监视与侦察系统、标枪导弹以及无人机等技术使乌克兰部队在远距离作战中表现得更加灵活和有力。并非这些技术本身使俄罗斯军队困惑，而是这些技术与乌克兰部队创新速度的结合可能是关键所在。\n同样，广泛的教育背景可能有助于防止陷入瘫痪，能够快速综合分析并解决即时出现的棘手问题。这一点至关重要，因为注入模糊性和虚假信息几乎肯定会对支持机器计算和人类判断产生不利影响，从而需要人类来填补这一空白。优质教育结合训练，将有助于应对人为注入的模糊性以及由此产生的战争迷雾和摩擦，因为这些因素会导致子系统被攻击并崩溃。\n在现代化进程中，利用新兴技术的潜力，JADC2系统最薄弱与最强大的环节都将是人类操作员及其所操作的组织。然而，各级决策者仍然需要理解以接近机器速度呈现的信息——他们必须具备态势感知能力。视角、偏见、文化、身份等因素赋予信息以意义，并为战斗信息提供另一套透镜，使其通过。教育是防止组织狭隘僵化的一种对策，而这种个人偏见即使在JADC2得以实现后，仍可能存在，无论它以何种形式呈现。\n(乌克兰部队的成功表明，灵活的思维和创新能力在现代战争中的重要性，不仅仅依赖于技术本身，更在于如何运用这些技术并快速适应变化的战场环境。与此相比，俄罗斯部队的迟缓反应和中央集权式指挥则凸显了缺乏这种创新精神和灵活性的代价。因此，在JADC2系统的开发和应用过程中，确保操作员和组织具备适应性和创新能力至关重要，这需要通过广泛的教育和持续的训练来培养，以应对未来战场上可能遇到的复杂挑战。)\nConclusion 联合全域作战旨在通过利用全域信息优势，获得决策优势。这种信息优势是通过传感器网络、云计算或边缘计算的高级分析以及具备弹性和开放数据连接的支持而创建的，以支撑基于任务指挥的规划、决策和执行周期，这些周期必须比对手更快、更智能、更强大。然而，嵌入在JADC2已发布架构中的一个关键概念——博伊德的OODA循环——经常被误解为仅关注决策速度。博伊德还强调了信息质量的重要性，指出冲突竞争的全部意义在于通过大量输入来使对手迷失方向。此外，最近对决策优势的定义努力忽视了将行动与决策联系起来的重要性——即主动权的掌握和保持，这与进攻并不完全相同。\n即使JADC2取得成功，当今的新兴对手也在试图通过虚假信息、误导以及选择性地攻击美国的指挥与控制系统的要素，来削弱美国当前和近期的战场优势，以制造停顿、犹豫、功能下降，最终导致瘫痪。\n此外，这些攻击所针对的人类因素，即使在一个完美的操作环境中，即使拥有近乎完美的态势感知，也可能扭曲理解并导致糟糕和无效，甚至灾难性的决策。同时，人类处理变化信息的速度比具有中央集权和机器特性（如俄罗斯那样）的机器或组织系统更快。如果像大卫·爱泼斯坦这样的思想家是正确的，那么JADC2系统中的人类元素将是整个系统的关键弱点和强项。对人类广度的考虑可以补充JADC2的机器处理深度，从而揭示战争迷雾和摩擦中隐藏的一些内容。\n(JADC2的成功不仅依赖于技术优势，还需要充分考虑人类因素的复杂性。这些因素可能会因为对手的攻击或自身的局限性而导致决策失误。因此，确保人类操作员具备广泛的知识和快速适应变化的能力，与技术手段相辅相成，是赢得现代战场的关键。)\nDisclaimer and Copyright 《空中与空间作战评论》（Air \u0026 Space Operations Review, ASOR）中的观点和意见仅代表作者个人立场，并未得到美国政府任何机构或部门的正式认可。本文档及其中包含的商标受法律保护，仅供非商业用途。任何复制行为须遵循1976年《版权法》和美国适用条约的规定。作者保留根据《美国法典》第17篇第106条授予的所有权利。任何复制行为均需获得作者的许可，并注明标准的来源引用行。若需帮助，请联系《空中与空间作战评论》编辑：asor@au.af.edu。",
    "description": "决策优势与主动权：完善联合全域指挥与控制",
    "tags": [],
    "title": "决策优势与主动权",
    "uri": "/c2/decision-advantage-and-initiative-completing-joint-all-domain-command-and-control.ch/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation \u003e  Aerodynamics",
    "content": "1. 概述 本设计文档旨在为小型固定翼无人机仿真系统提供逼真的飞行动力学与飞行控制方案，替代当前的简单PID+运动学模型，指导后续具体实现与集成。文档涵盖系统需求、6-DOF动力学模型、级联控制架构、模块接口、参数标定及实现建议等内容。\nC++代码实现\n2. 系统需求 实时性：仿真步长 ≤ 0.01s，支持 6-DOF 状态更新与控制运算。 精度：考虑升力、阻力、侧力及机动特性，航向/姿态/速度跟踪误差 ≤ 5%。 可扩展性：支持载荷变化、风场扰动、不同气动数据库切换。 接口兼容：保留现有接口文档中输入/输出字段，向后兼容。 3. 飞行动力学模型（6-DOF） 3.1 状态变量定义 位置与速度：$\\mathbf{r}=[x,y,z]^T$, $\\mathbf{v}=[u,v,w]^T$（机体坐标系）。 姿态与角速度：Euler 角 $[\\phi,\\theta,\\psi]^T$，角速率 $[p,q,r]^T$。 总状态向量：$\\mathbf{x}=[\\mathbf{r},\\mathbf{v},\\phi,\\theta,\\psi,p,q,r]^T$。 3.2 动力学方程 平动方程： $m\\dot{\\mathbf{v}}=\\mathbf{F}_a+\\mathbf{F}_g+\\mathbf{F}_t$\n$\\mathbf{F}_a$：气动力，包含升力、阻力、侧力，由攻角 $\\alpha$、侧滑角 $\\beta$ 及控制面偏角计算。 $\\mathbf{F}_g$：重力，在机体坐标系下投影。 $\\mathbf{F}_t$：推进力，由推力曲线或简单发动机模型获得。 转动方程： $\\mathbf{I}\\dot{\\boldsymbol{\\omega}}+\\boldsymbol{\\omega}\\times(\\mathbf{I}\\boldsymbol{\\omega})=\\mathbf{M}_a+\\mathbf{M}_t$\n$\\mathbf{M}_a$：气动力矩，依赖于控制面夹角与角速率。 $\\mathbf{M}_t$：发动机或尾舵力矩。 姿态更新： $\\dot{\\mathbf{R}}=\\mathbf{R}[\\boldsymbol{\\omega}]_\\times$ 或使用Euler角微分： $\\begin{bmatrix}\\dot{\\phi}\\\\\\dot{\\theta}\\\\\\dot{\\psi}\\end{bmatrix}=\\mathbf{E}(\\phi,\\theta)\\begin{bmatrix}p\\\\q\\\\r\\end{bmatrix}.$\n3.3 气动系数获取与典型值 系数 物理含义 典型值 单位 $C_{L0}$ 零攻角升力系数 0.2 — $C_{L_{\\alpha}}$ 升力曲线斜率 5.7 1/rad $C_{D0}$ 零升阻力系数 0.02 — $k$ 诱导阻力因子 $1/(\\pi AR e)\\approx0.066$ — $AR$ 展弦比 6 — $e$ 诱导阻力效率因子 0.8 — $C_{m0}$ 零攻角俯仰力矩系数 0.05 — $C_{m_{\\alpha}}$ 俯仰力矩斜率 -0.38 1/rad $C_{L_{\\delta_e}}$ 升力—升降舵偏导 0.8 1/rad $C_{m_{\\delta_e}}$ 俯仰力矩—升降舵偏导 -1.1 1/rad 注：数值来源于 Beard \u0026 McLain (2012)；Stevens \u0026 Lewis (2003)，可根据实际试验标定。\n3.4 数值集成 推荐使用 4/5 阶 Runge–Kutta 积分器，步长 0.005–0.01s，保证数值稳定性与精度。 4. 级联控制架构与典型增益 采用三级级联 PID 控制：外环生成姿态/速率指令，中环生成速率指令，内环生成舵面输出。\n4.1 外环（航迹／航路跟随，20 Hz） 航向控制\n误差：$\\tildeψ=ψ_d-ψ$ 控制：$φ_d=K_{p,ψ}\\tildeψ+K_{i,ψ}\\int\\tildeψdt$ 增益：$K_{p,ψ}=1.2,;K_{i,ψ}=0.01$ 高度控制\n误差：$\\tilde h=h_d-h$ 控制：$θ_d=K_{p,h}\\tilde h+K_{i,h}\\int\\tilde h dt$ 增益：$K_{p,h}=0.8,;K_{i,h}=0.005$ 空速控制\n误差：$\\tilde V=V_d-V$ 控制：$δ_T=K_{p,V}\\tilde V+K_{i,V}\\int\\tilde V dt$ 增益：$K_{p,V}=0.5,;K_{i,V}=0.02$ 偏航跟踪\n误差：$\\tildeψ=ψ_d-ψ$ 控制：$r_d=K_{p,ψ_r}\\tildeψ+K_{i,ψ_r}\\int\\tildeψdt$ 增益：$K_{p,ψ_r}=0.5,;K_{i,ψ_r}=0.02$ 4.2 中环（姿态／速率生成，50 Hz） 横滚角生成\n误差：$\\tildeφ=φ_d-φ$ 控制：$p_d=K_{p,φ}\\tildeφ+K_{d,φ}\\dot{\\tildeφ}$ 增益：$K_{p,φ}=5.5,;K_{d,φ}=1.2$ 俯仰角生成\n误差：$\\tildeθ=θ_d-θ$ 控制：$q_d=K_{p,θ}\\tildeθ+K_{i,θ}\\int\\tildeθdt+K_{d,θ}\\dot{\\tildeθ}$ 增益：$K_{p,θ}=6.0,;K_{i,θ}=0.2,;K_{d,θ}=1.0$ 偏航速率辅助\n可结合侧滑角环或直接使用 $r_d$。 4.3 内环（角速率控制，100 Hz） 横滚速率控制\n误差：$\\tilde p=p_d-p$ 控制：$δ_a=K_{p,p}\\tilde p+K_{d,p}\\dot{\\tilde p}$ 增益：$K_{p,p}=8.0,;K_{d,p}=1.5$ 俯仰速率控制\n误差：$\\tilde q=q_d-q$ 控制：$δ_e=K_{p,q}\\tilde q+K_{d,q}\\dot{\\tilde q}$ 增益：$K_{p,q}=9.0,;K_{d,q}=1.8$ 偏航速率控制\n误差：$\\tilde r=r_d-r$ 控制：$δ_r=K_{p,r}\\tilde r+K_{d,r}\\dot{\\tilde r}$ 增益：$K_{p,r}=4.0,;K_{d,r}=0.5$ 4.4 执行周期与时序 外环 20 Hz, 中环 50 Hz, 内环 100 Hz\n主循环示例：\nwhile(sim) { read_state(); if(time%0.05==0) external_loop(); if(time%0.02==0) attitude_loop(); rate_loop(); integrate_dynamics(Δt); log(); } 5. 接口与模块划分 模块 输入 输出 动力学模型 状态 $\\mathbf{x}$，控制 $[δ_T,δ_a,δ_e,δ_r]$ 更新后状态 $\\mathbf{x}_{t+Δt}$ 外环控制 目标航迹/姿态，当前状态 $ψ_d,θ_d,V_d,h_d,r_d,p_d,q_d$ 中环控制 $φ_d,θ_d,r_d$，当前姿态 $p_d,q_d,r_d$ 内环控制 $p_d,q_d,r_d$，当前角速 $δ_a,δ_e,δ_r$ 6. 参数标定与验证 开环仿真：验证动力学模型平飞稳定性。 阶跃响应测试：分析外环/中环/内环步响应特性。 闭环跟踪：执行航线跟随、高度保持、空速保持任务，记录误差。 蒙特卡洛测试：加入风/参数扰动，评估鲁棒性。 7. 实现建议 使用 Eigen 实现矩阵运算与 RK 积分。 将控制器与动力学模型封装为模块化接口（虚基类+派生）。 参数通过 JSON/YAML 配置加载，并支持在线调参。 日志与可视化：保存关键变量，用于离线分析与调优。 8. 参考文献 Stevens, B.L., \u0026 Lewis, F.L. (2003). Aircraft Control and Simulation. Wiley. Beard, R.W., \u0026 McLain, T.W. (2012). Small Unmanned Aircraft: Theory and Practice. Princeton University Press. JSBSim User Guide, PRIMES, Inc.",
    "description": "为小型固定翼无人机仿真系统提供逼真的飞行动力学与飞行控制方案，替代当前的简单PID+运动学模型。文档涵盖系统需求、6-DOF动力学模型、级联控制架构、模块接口、参数标定及实现建议等内容。",
    "tags": [],
    "title": "小型固定翼无人机飞行动力学模型",
    "uri": "/uas/fix_wing_uav_flight_sim/fix_wing_uav_flight_sim/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation \u003e  Velocity Plan",
    "content": "该文档描述了算法的数学模型、约束条件以及求解流程。文档中的符号和公式与代码中的计算逻辑相对应，详细说明了如何根据输入参数（如轨迹弧长 $S$、总飞行时间$T$、进入速度 $v_{In}$、期望速度 $v_{Des}$、最小/最大速度 $v_{min}, v_{max}$、最大加速度 $a_{Max} $和最大加加速度 $j_{Max}$）计算出整个轨迹在仿真步长 $dt$ 下的速度、加速度和加加速度曲线，同时在后段尽可能保持接近期望速度飞行，并通过二分查找调整 $v_{Des}$ 以匹配目标弧长。\n1. 引言 本模型旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。给定目标轨迹弧长 $S$ 与总飞行时间 $T$，输入参数包括进入速度 $v_{in}$ 与期望速度 $v_{des}$（代码中记为 vIn 与 vDes），同时受到速度上下限 $v_{min}, v_{max}$ 以及动态约束：最大加速度 $a_{max}$ 和最大加加速度 $j_{max}$ 的限制。整个模型通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。\n在线计算器链接\nC++代码库： https://github.com/flitai/Velocity_Plan/\n2. 模型参数与符号定义 输入参数：\n$S$ : 轨迹弧长（米） $T$ : 总飞行时间（秒） $v_{in}$ : 进入速度（米/秒） $v_{des}$ : 期望速度（米/秒） $v_{min}$ : 最小允许速度（米/秒） $v_{max}$ : 最大允许速度（米/秒） $a_{max}$ : 最大加速度（米/秒²） $j_{max}$ : 最大加加速度（米/秒³） $dt$ : 仿真步长（秒） 其他符号：\n$\\Delta v = v_{des} - v_{in}$ $s = \\text{sgn}(\\Delta v)$，正表示加速，负表示减速。 3. S 曲线变速段设计 为实现平滑过渡，S 曲线变速段分为两种情况，根据 $|\\Delta v|$ 与 $\\frac{a_{max}^2}{j_{max}}$ 的关系区分为【梯形 S 曲线】与【三角形 S 曲线】。\n3.1 梯形 S 曲线 当\n$$ |\\Delta v| \\ge \\frac{a_{max}^2}{j_{max}}, $$ 采用梯形 S 曲线，其分为三个子段：\n上升阶段（加加速阶段）：\n时间区间：$t \\in [0, T_j]$，其中\n$$ T_j = \\frac{a_{max}}{j_{max}}. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}\\, t,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, t^2}{2}. \\end{aligned} $$ 恒定加速阶段：\n时间区间：$t \\in (T_j,\\, T_j + T_a]$，其中\n$$ T_a = \\frac{|\\Delta v|}{a_{max}} - T_j. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= 0,\\\\ a(t) \u0026= s\\, a_{max},\\\\ v(t) \u0026= v_{in} + \\frac{s\\, a_{max}^2}{2j_{max}} + s\\, a_{max}(t - T_j). \\end{aligned} $$ 下降阶段（减加速阶段）：\n时间区间：$t \\in (T_j+T_a,\\, T_{conv}]$，其中\n$$ T_{conv} = 2T_j + T_a. $$ 定义局部时间 $\\tau = t - (T_j+T_a)$，动态表达式： $$ \\begin{aligned} j(t) \u0026= -s\\, j_{max},\\\\ a(t) \u0026= s\\, a_{max} - s\\, j_{max}\\, \\tau,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, a_{max}^2}{2j_{max}} + s\\, a_{max}\\, T_a + s\\Big(a_{max}\\tau - \\frac{j_{max}\\, \\tau^2}{2}\\Big). \\end{aligned} $$ 3.2 三角形 S 曲线 当\n$$ |\\Delta v| \u003c \\frac{a_{max}^2}{j_{max}}, $$ 采用三角形 S 曲线，其分为两个子段：\n上升阶段：\n时间区间：$t \\in [0, T']$，其中\n$$ T' = \\sqrt{\\frac{|\\Delta v|}{j_{max}}}. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}\\, t,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, t^2}{2}. \\end{aligned} $$ 下降阶段：\n时间区间：$t \\in (T',\\, 2T']$，设 $\\tau = t - T'$，动态表达式： $$ \\begin{aligned} j(t) \u0026= -s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}(T' - \\tau),\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, T'^2}{2} + s\\Big(j_{max}\\, T'\\,\\tau - \\frac{j_{max}\\,\\tau^2}{2}\\Big). \\end{aligned} $$ 此时，总变速段时间为\n$$ T_{conv} = 2T'. $$ 4. 定速阶段 在变速阶段（$t \\le T_{conv}$）结束后，进入定速阶段，设定：\n$$ v(t) = v_{des},\\quad a(t)=0,\\quad j(t)=0,\\quad \\text{for } t \\in (T_{conv},\\, T]. $$ 定速阶段的位移为\n$$ S_{const} = v_{des}\\,(T - T_{conv}). $$ 5. 总位移匹配与 vDes 调整 整个飞行的总位移为： $$ S_{total} = S_{conv} + S_{const}, $$ 其中\n$S_{conv} = \\int_{0}^{T_{conv}} v(t)\\, dt$（变速段的累计位移）， $S_{const} = v_{des}\\,(T - T_{conv})$。 目标是满足\n$$ S_{total} = S. $$由于直接根据初始参数计算得到的 $S_{total}$ 可能与目标 $S$ 不符，代码中采用二分查找法在允许范围 $[v_{min}, v_{max}]$ 内调整期望速度 $v_{des}$，使得修正后的 $v_{des}$ 满足 $$ \\left|S_{conv} + v_{des}\\,(T - T_{conv}) - S\\right| \u003c \\epsilon, $$ 其中 $\\epsilon$ 为容忍误差（例如 0.001 米）。\n同时，通过比例因子\n$$ \\text{scaleFactor} = \\frac{v_{des}^{*}}{v_{des}}, $$ 记录调整幅度，以便反馈用户。\n6. 离散化与仿真步骤 时间离散化：\n将总飞行时间 $T$ 以步长 $dt$ 离散为 $N = \\lceil T/dt \\rceil$ 个时间点。\n按阶段计算：\n对于 $t \\le T_{conv}$ 的点，依据所选 S 曲线（梯形或三角形）分别计算对应的 $v(t)$、$a(t)$ 与 $j(t)$，同时累加位移 $S_{conv}$。 对于 $t \u003e T_{conv}$ 的点，设 $v(t) = v_{des}$（调整后的值），位移按 $v_{des} \\times dt$ 累加。 数据输出：\n生成离散的时间序列数据，格式为\n$$ \\{t_k,\\, v(t_k),\\, a(t_k),\\, j(t_k)\\},\\quad k=0,1,\\ldots, N, $$ 用于后续图形显示和进一步分析。\n7. 模型求解流程 初始计算：\n根据输入参数计算 $\\Delta v$ 和符号 $s$。判断 $|\\Delta v|$ 是否满足梯形 S 曲线条件，从而计算对应的 $T_j, T_a$（或 $T'$），进而确定变速阶段时间 $T_{conv}$。\n积分求位移：\n对变速段进行数值积分获得 $S_{conv}$，再计算定速段位移 $S_{const}$，从而得出 $S_{total}$。\n二分查找调整 $v_{des}$：\n若 $S_{total}$ 与目标 $S$ 存在误差，则在 $[v_{min}, v_{max}]$ 范围内采用二分查找调整 $v_{des}$，直到满足误差要求。\n生成输出数据：\n依据调整后的 $v_{des}$ 与计算结果生成全程的速度、加速度与加加速度数据，并输出曲线信息与统计指标。\n8. 总结 本 S 曲线速度规划模型在满足总飞行时间 $T$ 与轨迹弧长 $S$ 的严格约束下，通过以下步骤实现：\n变速段设计： 根据 $v_{in}$ 与 $v_{des}$ 之间的差值，选择梯形或三角形 S 曲线生成平滑的加速/减速过渡，计算出变速段时间 $T_{conv}$ 与累计位移 $S_{conv}$。 定速段补充： 变速结束后，采用定速 $v_{des}$ 飞行，确保后段尽可能长以接近期望速度。 迭代优化： 采用二分查找调整期望速度 $v_{des}$（同时记录比例因子），以确保总体位移匹配目标 $S$。 离散仿真： 按照步长 $dt$ 离散生成整段轨迹的速度、加速度和加加速度数据。 该模型不仅实现了速度规划的平滑性和安全性，同时在后段尽可能保持接近飞出速度飞行，从而满足特定飞行性能的要求。",
    "description": "旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。",
    "tags": [],
    "title": "三段S曲线速度规划模型",
    "uri": "/uas/velocity_plan/%E4%B8%89%E6%AE%B5s%E6%9B%B2%E7%BA%BF%E9%80%9F%E5%BA%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation \u003e  Aerodynamics",
    "content": "用户手册 https://jsbsim-team.github.io/jsbsim-reference-manual/\n本部分解释了如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim 软件提供了许多现成可用的飞行器模型示例。一旦用户熟悉了进行模拟所需的所有步骤和设置，可能会希望查看这些示例，并详细了解更有经验的 JSBSim 用户是如何实现某些特定模型的。\n该项目和发行版中包含的飞行器模型不包含任何专有、敏感或机密数据。所有数据均来源于教材（如 Stevens 和 Lewis 的《Aircraft Control and Simulation》以及 Sutton 的《Rocket Propulsion Elements》）、公开的技术报告（见：NASA技术报告网站和AIAA网站），或其他公开数据（如FAA网站）。JSBSim 发行版中包含的飞行器模型，以及与现有商业或军事飞行器名称相对应的模型，都是基于公开信息制作的近似模型，仅供教育或娱乐使用。\n概述 什么是 JSBSim？ 从应用程序编程的角度来看，JSBSim 是一个主要用 C++ 编程语言编写的程序代码集合（其中包括一些 C 语言例程）。组成 JSBSim 的一些 C++ 类用于建模物理实体，如大气、飞行控制系统或引擎。某些类封装了诸如运动方程、矩阵、四元数或向量等概念或数学构造。一些类管理其他对象的集合。总的来说，JSBSim 应用程序接受控制输入，计算并汇总来自这些控制输入和环境的力矩，并在离散时间步中推进飞行器的状态（速度、方位、位置等）。\nJSBSim 已经在各种平台上构建和运行，如 Windows 或 Linux 系统上的 PC、苹果 Macintosh 以及硅谷图形公司的 IRIX 操作系统。自由的 GNU g++ 编译器可以轻松编译 JSBSim，其他如 Borland 和 Microsoft 的编译器也能很好地工作。更多信息请参见《程序员指南》。\n从最终用户的角度来看（例如进行研究的学生），JSBSim 可以被视为一个“黑箱”，它通过 XML 格式的输入文件进行提供。这些 XML 文件包含了航天器、引擎、脚本等的描述。当这些文件被加载到 JSBSim 中时，它们指示 JSBSim 模拟该飞行器的飞行情况，作为更大仿真框架的一部分（例如 FlightGear 或 OpenEaagles），或者在批处理模式下以比实际时间更快的速度运行。每次运行 JSBSim 都会生成包含模拟飞行器性能和动态数据的文件。\n从软件集成者的角度来看（例如将 JSBSim 集成到更大仿真框架中的人员），JSBSim 是一个可以被调用的库，提供输入（如飞行员的控制输入），并返回输出（描述飞行器在某一时刻的位置）。\n它适合谁，如何使用？ JSBSim 飞行动力学模型（FDM）软件库旨在易于理解，特别适合高年级航空航天工程学生。由于其配置简便，它也已被业界专业人士用于多种场景。它已经被集成到更大、更全面的飞行模拟应用程序和架构中（例如 FlightGear、Outerra 和 OpenEaagles），并且已被用作工业和学术界的批量模拟工具。\n使用示例 Aerocross Echo Hawk JSBSim 被用于 Aerocross Echo Hawk UAV 的硬件在环（HITL）测试。编写了自定义代码以通过 RS-232/422/485、模拟模拟输入/输出、离散输入/输出和套接字与飞行硬件（基于 PC/104 的系统）接口，但核心仿真代码仍为未经修改的 JSBSim 代码。飞行员/操作员培训也依赖于 JSBSim 作为六自由度（6-DoF）仿真模型。\nDuPont Aerospace 公司 JSBSim 曾在 DuPont Aerospace 公司与 Matlab 一起用于实时 HITL 仿真和飞行员/操作员培训。DuPont Aerospace 公司的 Rex duPont 解释了该项目：\n在 1990 年代，DuPont Aerospace 公司正在研发一种飞机，测试其垂直起降风扇喷气运输机的概念。我们开发了一个基于 Microsoft Windows 的飞行模拟器，用于测试拟议飞行器的飞行特性。然而，我们需要一个可以在实时中使用的仿真系统，以便能够在操作飞行执行器的全尺寸模型上测试飞行特性。我们最终选择了 FlightGear 模拟器，并使用了 JSBSim 飞行动力学模型，因为我们可以获得完整的代码，它的组织方式很好，使我们能够创建新的子程序来匹配我们的飞机，同时也有可用的支持。\n我们同时开发了一个 Matlab 模拟器，用于开发更有效的自动驾驶仪引导系统，因为我们的主要任务是仅使用自动驾驶仪起飞并保持悬停 30 秒。这将明确显示控制系统是否足够强大。因此，我们在 Matlab 模拟器和 JSBSim 派生模拟器的每个相关模块中内建了一系列单元测试，提供一系列输入以交叉验证，确保两个系统同步。\n我们使用 JSBSim 系统测试了一些 Matlab 模型难以测试的动态问题，尤其是涉及飞行员感受和过渡至悬停过程中的可控性问题。这些问题在纯控制系统领域（如 Matlab 中）很难评估，因为过渡过程中，基础的力结构随着空气动力学力量的增强和纯推力控制力的减少而不断变化。\n我们还对气动仿真中关键参数的估算误差敏感度进行了参数研究。这些研究通过让飞行员执行一系列标准机动来完成，目的是测试当一个或多个参数降低 50% 时飞机的响应（飞行员不知道是哪一个参数被改变）。\n我们也对伺服带宽进行了模拟，测试飞行特性在何种情况下变得不可接受。这有助于定义所需的特性。飞行员对控制系统的需求几乎总是与理论上最佳的参数不同。\n此外，我们开发了多种 HUD 显示系统，以便在悬停过程中操作时提供帮助，在这种情况下需要非常精确的地面速度控制。最终我们实现了一个系统，允许一个甚至没有飞行员执照的年轻工程师起飞并保持悬停在恒定高度 30 秒以上，偏差不超过 1 英尺。\n我们最终于 2007 年 9 月 30 日成功实现了自动驾驶仪控制的起飞和悬停，两次飞行的持续时间大约为 45 秒。两次飞行都因为其中一台发动机燃料耗尽而终止，而不是因为控制问题。\nMITRE 空中交通研究 JSBSim 在 MITRE 用于开发一个 6-DoF 模拟系统，模拟飞行管理系统（FMS）在连续下降进场（CDA）和优化下降进场（OPD）过程中的行为。MITRE 使用了 JSBSim 的独立版本（用于批量运行）和与 FlightGear 集成的版本。此外，还创建了附加的控制系统组件，以支持特定的横向和纵向导航研究。\nJSBSim 还被扩展为通过套接字向 MITRE 的其他应用程序输出消息，该应用程序提供了类似于空中交通管制员所看到的视图。\n美国交通部 在与美国交通部合作的项目中，开发了一个使用 JSBSim 作为六自由度（6-DoF）仿真核心的人类飞行员数学模型。\n意大利那不勒斯大学 Federico II 那不勒斯大学拥有一个基于 FlightGear 和 JSBSim 的运动座舱飞行/驾驶模拟器。该模拟器具有三屏视觉显示，提供 190 度的视场。JSBSim 源代码经过修改，提供了力反馈能力。\nJSBSim 在那不勒斯大学被用作支持近地飞行操作风险评估的工具。考虑到碰撞风险研究中的实际问题之一是评估在机场区域内新增障碍物（如建筑物或雷达塔）对飞行操作的威胁。风险评估是通过改变障碍物的几何形状和位置来进行的。评估程序基于对飞机轨迹与“正常”飞行路径的统计偏差分析，评估某一轨迹穿越给定的“保护”区域的概率。为此框架，操作场景被正式描述和实现，以便运行多个计算机模拟。\n弗劳恩霍夫风能系统研究所 在与意大利那不勒斯大学 Federico II 合作的研究中，弗劳恩霍夫风能系统研究所（IWES）的研究人员研究了轻型飞机飞行通过或接近风力涡轮机尾流时的尾流相遇问题。\n为了这项研究，开发了一个软件应用程序框架，用于生成和控制在指定风场和湍流场下的飞行仿真场景。JSBSim 被用作该框架中的飞行动力学模型，并通过调整其自动驾驶仪系统来模拟飞行员在导航过程中的真实行为。风力涡轮机尾流中的风分布是通过 OpenFOAM 计算的，并作为输入提供给动态模型。\n南非试飞学院（TFASA） 南非试飞学院使用 JSBSim 作为地面可变稳定系统（VSS）模拟器的基础，用于飞行员训练。基础飞行器模型的空气动力学稳定性和控制系数被修改，以展示它们对飞行任务的影响。还对执行器进行了建模，以展示它们在不同延迟、滞后和速率限制条件下对飞行员输入输出（PIO）的潜在影响。\n模拟的飞行器包括固定翼飞机和旋翼飞机，并配有可编程的力反馈控制装置，用于展示飞行控制机械特性（FCMC）的影响。\nJSBSim 与 Prepar3D 集成，利用 Prepar3D 的外部视觉系统，渲染到三块大型 LCD 屏幕或通过三投影仪系统呈现 180 度视图。\n仿真 虽然 JSBSim 用户不需要了解飞行模拟器操作的所有细节，但理解其基本工作原理是有帮助的。以下是一些重要的概念。\n参考坐标系用于描述飞行器模型中各种项目的位置和布局。 在定义飞行器模型时，单位的指定具有灵活性——支持英制单位和公制单位。 使用“属性”使得 JSBSim 成为一个通用模拟器，提供了一种通过参数（或变量）接口与各种系统进行交互的方法。属性广泛用于描述飞机和发动机特性配置文件中。 数学在飞行物理建模中发挥着重要作用。JSBSim 使用数据表格，因为飞行动力学特性通常存储在表格中。JSBSim 还允许设置任意代数函数，从而广泛自由地描述气动和飞行控制特性。 用户至少需要具备基本的飞行器飞行力学知识，了解飞机飞行时的常规力和力矩。 理解飞行控制和系统建模方法是成功和有效仿真的关键。 参考坐标系 在描述对象的位置、飞机的姿态和方向，或为给定的飞行条件指定输入时，需要理解一些基本的参考坐标系。以下是对这些坐标系的简要介绍：\n结构坐标系，或“构造坐标系” 该坐标系是常见的制造商参考坐标系，用于定义飞机上的各个点，例如重心位置、所有轮子的位置信息、飞行员视点、点质量、推进器等。JSBSim 飞机配置文件中的项目就是使用此坐标系来定位的。\n在结构坐标系中，X 轴沿着机身长度方向延伸，指向飞机尾部，Y 轴指向飞机右翼，Z 轴则朝上。通常，这个坐标系的原点 $O_C$ 位于飞机前部（例如机头尖端、单发动机飞机的机头防火墙处，或者位于机头前方的一段距离）。这个坐标系通常被命名为 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$.。\n结构（或构造）坐标系的飞机参考坐标系，原点 $O_C$。除了结构坐标系轴 $x_C$, $y_C$, zC 外，还展示了标准机体坐标系轴 $x_B$, $y_B$, $z_B$，它们的原点在重心 G 处。飞行员的视点位于 PEP。\nX 轴通常与机身中心线重合，并且通常与推力轴重合（例如在单发动机螺旋桨飞机中，它通过螺旋桨轴心）。沿 $x_C$ 轴的位置称为站位，沿 zC 轴的位置称为水线位置，沿 $y_C$ 轴的位置称为尾线位置。\n这是从 3D 建模软件 Blender 中截取的屏幕截图，展示了 Cessna 172 的模型及其结构坐标系 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$。在这个例子中，原点 $O_C$ 位于驾驶舱内，靠近仪表盘。\n注意，JSBSim 模拟的飞机的原点可以位于任意位置，因为 JSBSim 内部仅使用重心（CG）与各个物体之间的相对距离——而不是物体的绝对位置。\n在结构坐标系中确定的重心位置（CG）为点 G。\n根据结构坐标系位置定义的地面接触点。\n结构坐标系中的两个关键点位置 $P_{\\mathrm{ARP}}$ 和 $P_{\\mathrm{CG}, \\mathrm{EW}}$ ，分别为气动力矩的极点和空重 CG（空机重心）。机翼根部的形状和弦长也被勾画出来。\n除了 $P_{\\mathrm{CG}, \\mathrm{EW}}$，还展示了两个重要的位置，$P_{\\text {Pilot }}$ 和 $P_{\\text {Right Pass }}$ ，分别代表飞行员和右侧乘客的质量集中点。\n机体坐标系 在 JSBSim 中，机体坐标系类似于结构坐标系，但沿 $y_C$ 轴旋转 180 度，原点与重心（CG）重合。通常，机体坐标系是通过已知飞机重心 G 位置和纵向结构轴 $x_C$ 方向来定义的。$x_B$ 轴应选择与 $x_C$ 轴平行，且从 G 指向机头的正方向。\n机体轴坐标系通常命名为$\\mathcal{F}_{\\mathrm{B}}=\\left\\{G, x_{\\mathrm{B}}, y_{\\mathrm{B}}, z_{\\mathrm{B}}\\right\\}$。$x_B$ 轴称为滚转轴，指向前方，$y_B$ 轴称为俯仰轴，指向右翼，$z_B$ 轴称为偏航轴，指向飞机腹部。\n标准的飞机机体轴坐标系，原点在重心 G 处。\n在机体坐标系中，飞机的力和力矩被相加，结果加速度被积分以得到速度。\n稳定坐标系，或“气动坐标系” 这个坐标系是根据相对风矢量相对于机体的瞬时方向来定义的。如果为了简化假设空气相对于地球静止（无风），且 $\\boldsymbol{V}$ 是飞机质心相对于地球固定观察者的速度矢量（也称为 $\\boldsymbol{V}_{\\mathrm{CM} / \\mathrm{E}}$，以强调相对运动），那么 $-\\boldsymbol{V}$ 就是相对风速，$V=\\|V\\|$是空速。\n该坐标系命名为 $\\mathcal{F}_{\\mathrm{A}}=\\left\\{G, x_{\\mathrm{A}}, y_{\\mathrm{A}}, z_{\\mathrm{A}}\\right\\}$，其中轴 $x_{\\mathrm{A}}$ 指向相对风矢量投影到飞机对称平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的方向。轴 $y_{\\mathrm{A}}$ 仍然指向右翼，并与机体轴 $y_{\\mathrm{B}}$ 重合，轴 $z_{\\mathrm{A}}$ 完成右手坐标系。\n气动坐标系，定义了气动角度 $\\alpha_{\\mathrm{B}}$ 和 $\\beta$.\n这两个轴 $x_{\\mathrm{A}}$ 和 $z_{\\mathrm{A}}$ 根据定义属于飞机的对称面，但它们在飞行过程中可能会旋转，因为相对风速矢量 $V$ 相对于飞行器的方向可能会发生变化。上图展示了如何构建气动坐标系。两个轴 $x_{\\mathrm{A}}$ 和 $x_{\\mathrm{B}}$ 之间的夹角是飞机的迎角 $\\alpha_{\\mathrm{B}}$。相对风的瞬时方向 $\\boldsymbol{V}$ 与其在平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的投影之间形成的夹角是侧滑角 $\\beta$。\n这个坐标系，在一些手册中被称为稳定坐标系，在此也称为“气动坐标系”，因为瞬时气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 在 $z_{\\mathrm{A}}$ 轴上的投影 $Z_{\\mathrm{A}}$ 定义了气动升力。具体来说，升力 $L$ 是这样定义的：$-L$ 是气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 沿 $z_{\\mathrm{A}}$ 轴的分量，即 $Z_{\\mathrm{A}}=-L$。\n为了更好地理解上述描述，考虑一个在飞行力学中常见的典型动作：零侧滑（或“协调”）、保持恒定高度的匀速转弯。在这种情况下，机翼会倾斜，升力也会倾斜。在这种转弯中，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 是倾斜的，而 $x_{\\mathrm{A}}$ 轴保持水平。一般来说，升力作为一个矢量总是定义在飞机的对称面内。\n在恒定高度的匀速协调转弯中，倾斜升力的情况。倾斜角 $\\phi_{\\mathrm{W}}$ 是绕相对风速矢量的旋转。当速度矢量与北方对齐时，运动被定格在时间上。协调转弯意味着 $\\beta=0$，恒定高度意味着 $x_{\\mathrm{A}}$ 轴保持水平。\n备注 —— 在动态稳定性研究中，“稳定坐标系”与上述的气动坐标系略有不同：飞机飞行力学和稳定性约定中的稳定坐标系不过是一个特定的机体固定坐标系，定义是基于初始的对称、稳定、机翼水平、恒定高度的飞行状态。该状态给出了 $x_S$ 的方向（在该特定飞行姿态下与 $x_A$ 重合）。因此，在动态稳定性研究中，稳定坐标系与气动坐标系不同，是固定在飞行器上的。\n在 JSBSim 中，稳定坐标系 $\\mathcal{F}_{\\mathrm{S}}=\\left\\{G, x_{\\mathrm{S}}, y_{\\mathrm{S}}, z_{\\mathrm{S}}\\right\\}$ 代表了气动坐标系。\n地心惯性坐标系（ECI）和地心固定坐标系（ECEF） 地心惯性坐标系（或简称“惯性坐标系”）$\\mathcal{F}_{\\mathrm{ECI}}=\\left\\{O_{\\mathrm{ECI}}, x_{\\mathrm{ECI}}, y_{\\mathrm{ECI}}, z_{\\mathrm{ECI}}\\right\\}$固定，其原点位于地球中心。其笛卡尔坐标轴相对于恒星保持固定，为飞机（或航天器）运动方程提供最简洁的参考坐标系。正 $z_{\\mathrm{ECI}}$ 轴穿过地球的地理北极。$x_{\\mathrm{ECI}}$ 和 $y_{\\mathrm{ECI}}$ 轴位于赤道平面内。$x_{\\mathrm{ECI}}$ 轴始终与从太阳质心到地球在春分时的轨道位置的连线平行。下图展示了 ECI 系统。\n地心惯性（ECI）坐标系和地心固定（ECEF）坐标系。\n地心地固参考系（ECEF）的坐标轴，如 $x_{\\mathrm{ECEF}}$、$y_{\\mathrm{ECEF}}$ 和 $z_{\\mathrm{ECEF}}$，也如上图所示。ECEF 坐标轴相对于地球保持固定。这个笛卡尔系统的原点 $O_{\\mathrm{ECEF}}$，与惯性坐标系一样，位于地球的质心。$z_{\\mathrm{ECEF}}$ 轴也沿着地球的自转轴，并与 $z_{\\mathrm{ECI}}$ 轴重合。$x_{\\mathrm{ECEF}}$ 和 $y_{\\mathrm{ECEF}}$ 轴都位于赤道平面内，且正 $x_{\\mathrm{ECEF}}$ 轴通过本初子午线（格林威治子午线）。ECEF 坐标系绕惯性坐标系的 $z_{\\mathrm{ECI}}$ 轴以角速度 $\\omega_{\\mathrm{E}}$ 逆时针旋转。地球的角速度 $\\omega_{\\mathrm{E}}$ 近似等于 $2 \\pi / 24$ 弧度/小时。\n北向切平面坐标系 当假设地球表面有数学表示（如椭球体或近似球体）时，可以定义一个切平面坐标系。选取与地表某一点 $O_{\\mathrm{E}}$ 相切的平面作为参考。一个叫做“北向切平面坐标系”的地理坐标系 $\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 具有固定原点 $O_{\\mathrm{E}}$，其平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与切平面重合。轴 $x_{\\mathrm{E}}$ 指向地理北方，轴 $y_{\\mathrm{E}}$ 指向东方，最后，轴 $z_{\\mathrm{E}}$ 指向地面，平行于椭球体的法线（如果使用近似球体代替椭球体，则该轴指向地球中心）。因此，坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 也被称为切平面 NED 坐标系（North-East-Down）。\n地心固定（ECEF）坐标系、地理坐标、切平面坐标系和局部垂直坐标系。\n局部垂直局部水平坐标系，或局部 NED 坐标系 局部垂直坐标系$\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$ 与飞机在空间中的朝向无关，而仅由其重心相对于某个便捷的地球固定观察者的位置定义。如果 $G_{\\mathrm{GT}}$ 是重心在地面上的投影（即“地面跟踪”），则坐标平面 $x_{\\mathrm{V}} y_{\\mathrm{V}}$ 平行于在 $G_{\\mathrm{GT}}$ 处与地球表面局部切平面的平面——即平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$，其中 $O_{\\mathrm{E}} \\equiv G_{\\mathrm{GT}}$。然后，轴 $x_{\\mathrm{V}}$ 指向地理北方，轴 $y_{\\mathrm{V}}$ 指向东，最后，轴 $z_V$ 指向地球中心的下方。因此，坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 也被称为局部NED（载机）坐标系。\n飞机体坐标系和局部垂直坐标系（NED坐标系）。图中还展示了飞机的欧拉角：航向角 $\\psi$（图中为负），俯仰角 $\\theta$，和滚转角 $\\phi$。\nNED惯例确保飞机的重量是一个力，在坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 中的分量为 $(0,0, m g)$，其中 $m$ 是飞机的质量，$g$ 是重力加速度。\n上述图展示了一个包含两个坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 和 $\\mathcal{F}_{\\mathrm{B}}$ 的飞机。定义机体坐标系相对于局部NED坐标系的朝向的欧拉角是飞机的欧拉角。对于大气飞行器，定义欧拉角时使用的旋转序列是“3-2-1”。这定义了相对于固定在地球上的观察者的航向角 $\\psi$、俯仰角 $\\theta$ 和滚转角 $\\phi$。\n飞机的欧拉角旋转序列。坐标系$\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 是一个地球固定的 NED 坐标系，原点 $O_{\\mathrm{E}}$ 位于地面某处（或海平面），且平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与地球表面相切。如果地面跟踪点 $G_{\\mathrm{GT}}$ 离 $O_{\\mathrm{E}}$ 不远，则地球坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 的轴线与局部 NED 坐标系 $\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$的轴线平行。\n风坐标系 除了升力，瞬时气动合力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 在参考系中还有两个分量，其中 $z_{\\mathrm{A}}$ 是第三轴。该参考系称为风参考系 $\\mathcal{F}_{\\mathrm{W}}=\\left\\{G, x_{\\mathrm{W}}, y_{\\mathrm{W}}, z_{\\mathrm{W}}\\right\\}$。\n风参考系的定义是将 $x_W$ 轴沿相对风的方向，并且其正方向与运动方向一致。这意味着 $x_{\\mathrm{W}}$ 与向量 $\\boldsymbol{V}$ 重合。风参考系的第三轴沿升力作用线定义，即 $z_{\\mathrm{W}} \\equiv z_{\\mathrm{A}}$。最后，第二轴 $y_{\\mathrm{W}}$ 被选择以完成右手坐标系。风参考系的第三轴始终处于机体对称面（也叫“参考面”）内。由于飞机的姿态随着相对风 $-\\boldsymbol{V}$ 的变化而变化，所有三个风轴会相对于机体轴旋转。\n力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 沿着 $\\boldsymbol{V}$ 方向的分量 $X_{\\mathrm{W}}$ 定义了气动阻力：气动阻力 $D$ 满足 $X_{\\mathrm{W}}=-D$。在存在非零侧滑角 $\\beta$ 的情况下，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 会沿横向轴 $y_{\\mathrm{W}}$ 产生第三个非零分量，即侧向力分量 $Y_{\\mathrm{W}}$。\n当侧滑角 $\\beta$ 为零时，风参考系和气动参考系重合。仅在这种情况下，$y_{\\mathrm{W}}$ 与 $y_{\\mathrm{A}}$ 和 $y_{\\mathrm{B}}$ 重合，且垂直于参考面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$。\n下图显示了飞机在平稳空气中的爬升飞行的标准参考系。当围绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$ 时，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以与气动参考系 $\\mathcal{F}_{\\mathrm{A}}$ 重合。\n标准参考系和飞机在平稳空气中的爬升飞行。质心速度矢量 $\\boldsymbol{V}$ 与水平面形成飞行路径角 $\\gamma$。标准的三个气动合力分量 $D$、$L$ 和 $Y_{\\mathrm{A}}$ 也已显示。\n因此，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以通过先绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$，再绕 $y_{\\mathrm{A}}$ 轴旋转角度 $\\alpha_{\\mathrm{B}}$，与机体参考系 $\\mathcal{F}_{\\mathrm{B}}$ 重合。 $$ \\mathcal{F}_{\\mathrm{W}} \\xrightarrow{-\\beta \\curvearrowright z_{\\mathrm{W}}} \\mathcal{F}_{\\mathrm{A}} \\xrightarrow{\\alpha_{\\mathrm{B}} \\curvearrowright y_{\\mathrm{A}}} \\mathcal{F}_{\\mathrm{B}} \\tag{1} $$气动结果力在机体轴上的分量则表示如下：\n$$ \\left\\{\\begin{array}{c} X_{\\mathrm{B}} \\\\ Y_{\\mathrm{B}} \\\\ Z_{\\mathrm{B}} \\end{array}\\right\\}=\\left[\\begin{array}{ccc} \\cos \\alpha_{\\mathrm{B}} \u0026 0 \u0026 -\\sin \\alpha_{\\mathrm{B}} \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin \\alpha_{\\mathrm{B}} \u0026 0 \u0026 \\cos \\alpha_{\\mathrm{B}} \\end{array}\\right]\\left[\\begin{array}{ccc} \\cos \\beta \u0026 \\sin (-\\beta) \u0026 0 \\\\ -\\sin (-\\beta) \u0026 \\cos \\beta \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{array}\\right]\\left\\{\\begin{array}{c} -D \\\\ Y_{\\mathrm{W}} \\\\ -L \\end{array}\\right\\} \\tag{2} $$这些表示了气动阻力、侧向力和升力。\n单位 JSBSim 在内部计算中几乎 exclusively 使用英制单位。然而，也可以在配置文件中输入一些参数时使用不同的单位。为了避免混淆，建议总是指定单位。单位使用 unit 属性进行指定。例如，翼展的规格如下所示：\n\u003cwingspan unit=\"FT\"\u003e 35.8 \u003c/wingspan\u003e 上述声明指定了一个 35.8 英尺的翼展。以下声明将翼展指定为米单位，这将导致翼展在读取时转换为 35.8 英尺：\n\u003cwingspan unit=\"M\"\u003e 10.91 \u003c/wingspan\u003e 这两条关于翼展的声明实际上是等效的。\nJSBSim 目前支持以下单位：\n长度\nunit= 单位 FT 英尺 IN 英寸 M 米 KM 千米 面积\nunit= 单位 M2 平方米 FT2 平方英尺 体积\nunit= 单位 FT3 立方英尺 CC 立方厘米 M3 立方米 LTR 升 质量和重量\nunit= 单位 LBS 磅（质量） KG 千克 惯性矩\nunit= 单位 SLUG*FT2 磅*英尺² KG*M2 千克*米² 角度\nunit= 单位 RAD 弧度 DEG 度 弹簧力\nunit= 单位 N/M 牛顿/米 LBS/FT 磅/英尺 阻尼力\nunit= 单位 N/M/SEC 牛顿/(米·秒) LBS/FT/SEC 磅/(英尺·秒) 功率\nunit= 单位 WATTS 瓦特 HP 马力 力\nunit= 单位 LBS 磅 N 牛顿 速度\nunit= 单位 KTS 节 FT/SEC 英尺/秒 M/S 米/秒 扭矩\nunit= 单位 N*M 牛顿·米 FT*LBS 磅·英尺 压力\nunit= 单位 PSF 磅/平方英尺 PSI 磅/平方英寸 ATM 大气压 PA 牛顿/平方米 INHG 英寸汞柱 属性系统 仿真程序需要管理大量的状态信息。对于特别庞大的程序，数据管理任务可能会引发一些问题：\n贡献者越来越难以掌握所需的多个接口，以进行任何有用的程序扩展，因此贡献进展变慢。 运行时的可配置性变得越来越困难，因为不同的模块使用不同的机制（环境变量、自定义规范文件、命令行选项等）。 模块初始化的顺序变得复杂且脆弱，因为一个模块的初始化例程可能需要从未初始化的模块设置或获取状态信息。 通过附加脚本、规范文件等进行扩展的能力仅限于程序提供的状态信息，且非编码开发人员往往要等待较长时间才能获得开发人员添加新变量的支持。 属性管理器系统提供了一个单一的接口，用于选择程序的状态信息，并允许在运行时动态创建新的用户指定的变量。后一种能力对于 JSBSim 控制系统模型尤其重要，因为组成飞机控制律的各个控制系统组件（PID 控制器、开关、加法器、增益等）仅在配置文件中存在。在运行时——在解析组件定义之后——这些组件将被实例化，属性管理器将创建一个属性来存储每个组件的输出值。\n属性本身类似于具有选择性限制可见性（只读或读写）的全局变量，它们被分类到一个层次结构的树形结构中，类似于 Unix 文件系统的结构。属性树的结构包括根节点、子节点（类似子目录）和终端节点（属性）。类似于 Unix 文件系统，属性可以相对于当前节点或根节点进行引用。节点可以像符号链接文件或目录到其他文件或目录一样，附加到其他节点上。属性在整个 JSBSim 和 FlightGear 中用于引用程序代码中的特定参数。属性名称的形式如下：position/h-sl-ft 和 aero/qbar-psf。\n为了说明使用属性和配置文件的强大功能，考虑一下高性能喷气式飞机模型的案例。假设在示例飞机的控制面板上添加了一个新的开关，允许飞行员在飞行控制系统（FCS）中覆盖俯仰限制。对于 FlightGear，仪表面板是在配置文件中定义的，开关也在那里定义以进行视觉显示。该开关定义还会分配一个属性名称。在 JSBSim 飞机规范文件中的飞行控制部分，分配给仪表面板定义中俯仰覆盖开关的相同属性名称可以用于根据开关位置引导控制律通过所需路径。无需修改任何代码。\n特定的仿真参数可以通过属性在 JSBSim 和配置文件规范中进行访问和设置。如前所述，“属性”是我们用来描述可以从配置文件或命令行中访问或设置的参数的术语。\n许多属性是标准属性——即所有飞行器始终存在的属性。气动系数、发动机、推进器以及飞行控制/自动驾驶模型也会具有动态定义的属性。这是因为，直到读取相关的飞行器配置文件后，整个气动系数、发动机等的集合才会被确定。要访问这些参数，必须知道使用的属性命名约定。例如，X-15 模型的飞行控制系统包括以下组件：\n\u003cflight_control name=\"X-15\"\u003e \u003cchannel name=\"Pitch\"\u003e \u003csummer name=\"fcs/pitch-trim-sum\"\u003e \u003cinput\u003e fcs/elevator-cmd-norm \u003c/input\u003e \u003cinput\u003e fcs/pitch-trim-cmd-norm \u003c/input\u003e \u003cclipto\u003e \u003cmin\u003e -1 \u003c/min\u003e \u003cmax\u003e 1 \u003c/max\u003e \u003c/clipto\u003e \u003c/summer\u003e \u003caerosurface_scale name=\"fcs/pitch-command-scale\"\u003e \u003cinput\u003e fcs/pitch-trim-sum \u003c/input\u003e \u003crange\u003e \u003cmin\u003e -50 \u003c/min\u003e \u003cmax\u003e 50 \u003c/max\u003e \u003c/range\u003e \u003c/aerosurface_scale\u003e \u003cpure_gain name=\"fcs/pitch-gain-1\"\u003e \u003cinput\u003e fcs/pitch-command-scale \u003c/input\u003e \u003cgain\u003e -0.36 \u003c/gain\u003e \u003c/pure_gain\u003e \u003c/channel\u003e \u003c/flight_control\u003e 在上面的例子中，第一个组件（fcs/pitch-trim-sum）接收来自两个地方的输入，即已知的静态属性 fcs/elevator-cmd-norm 和 fcs/pitch-trim-cmd-norm。接下来的组件将接收第一个组件的输出作为输入。第二个组件列出的输入属性为 fcs/pitch-trim-sum。继续上述示例，最后一个组件 fcs/pitch-gain-1 接收前一个组件的输出 fcs/pitch-command-scale，该属性名为 fcs/pitch-command-scale。\n因此，现在我们已经可以访问 JSBSim 内部的许多参数，并且我们知道如何组装 JSBSim 中的飞行控制系统（FCS）。在 FCS 中使用的相同组件，也可以用来构建自动驾驶系统或其他系统。\n数学 函数 JSBSim 中的函数规范是一个强大且多功能的资源，允许在 JSBSim 配置文件中定义代数函数。函数的语法在概念上类似于 MathML（数学标记语言，http://www.w3.org/Math/），但它更加简洁和紧凑。\n一个函数定义由一个操作、一个值、一个表格或一个属性（评估为值）组成。当前支持的操作有：\nsum（接受 n 个参数） difference（接受 n 个参数） product（接受 n 个参数） quotient（接受 2 个参数） pow（接受 2 个参数） exp（接受 2 个参数） abs（接受 n 个参数） sin（接受 1 个参数） cos（接受 1 个参数） tan（接受 1 个参数） asin（接受 1 个参数） acos（接受 1 个参数） atan（接受 1 个参数） atan2（接受 2 个参数） min（接受 n 个参数） max（接受 n 个参数） avg（接受 n 个参数） fraction（接受 1 个参数） mod（接受 2 个参数） lt（小于，接受 2 个参数） le（小于等于，接受 2 个参数） gt（大于，接受 2 个参数） ge（大于等于，接受 2 个参数） eq（等于，接受 2 个参数） nq（不等于，接受 2 个参数） and（接受 n 个参数） or（接受 n 个参数） not（接受 1 个参数） if-then（接受 2-3 个参数） switch（接受 2 个或更多参数） random（高斯随机数，无参数） integer（接受 1 个参数） 一个操作在配置文件中的定义示例如下：\n\u003csum\u003e \u003cvalue\u003e 3.14159 \u003c/value\u003e \u003cproperty\u003e velocities/qbar \u003c/property\u003e \u003cproduct\u003e \u003cvalue\u003e 0.125 \u003c/value\u003e \u003cproperty\u003e metrics/wingarea \u003c/property\u003e \u003c/product\u003e \u003c/sum\u003e 在上述例子中，sum 元素包含了其他三个项。它的计算过程可以用代数表达式表示为： $$ 3.14159+\\text { qbar }+(0.125 \\cdot \\text { wingarea }) $$ 一个完整的函数定义（例如在气动部分的配置文件中使用的）包括 function 元素和其他元素。需要注意的是，函数定义中只能有一个非可选（非文档）元素——即一个操作元素。该元素不能包含多个直接子操作、property、table 或 value 元素。几乎总是，函数元素中的第一个操作将是乘积（product）或和（sum）。例如：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003e Roll moment due to yaw rate \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-area \u003c/property\u003e \u003cproperty\u003e metrics/bw-ft \u003c/property\u003e \u003cproperty\u003e velocities/r-aero-rad_sec \u003c/property\u003e \u003cproperty\u003e aero/bi2vel \u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在函数定义中，最“底层”的元素总是一个值或一个属性，它本身不能包含其他元素。如所示，操作可以包含值、属性、表格或其他操作。\n在 JSBSim 中，某些操作仅接受一个参数。然而，这个参数可以是一个操作（例如 sum），而该操作可以包含其他项。需要记住的一点是，任何此类包含的操作都将计算出一个单一的值 —— 这正是三角函数所要求的（除了 atan2，它接受两个参数）。\n最后，在函数定义中，有一些简写别名可以用来代替标准的元素标签，从而使得表达式更加简洁。属性、值和表格通常用 \u003cproperty\u003e、\u003cvalue\u003e 和 \u003ctable\u003e 标签来引用。但是，在函数定义中，以上这些元素可以使用 \u003cp\u003e、\u003cv\u003e 和 \u003ct\u003e 标签来代替。因此，之前的示例可以简化为以下格式：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003eRoll moment due to yaw rate\u003c/description\u003e \u003cproduct\u003e \u003cp\u003e aero/qbar-area \u003c/p\u003e \u003cp\u003e metrics/bw-ft \u003c/p\u003e \u003cp\u003e aero/bi2vel \u003c/p\u003e \u003cp\u003e velocities/r-aero-rad_sec \u003c/p\u003e \u003ct\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/t\u003e \u003c/product\u003e \u003c/function\u003e 在气动建模中，表格函数可以用来表示影响升力和阻力的地面效应因子。下图解释了地面效应：\n为了了解如何在 JSBSim 中建模地面效应，我们可以查看 Cessna 172 Skyhawk 模型。这一模型在文件 \u003cJSBSim-root-dir\u003e/aircraft/c172p/c172p.xml 中实现。在该 XML 文件的 \u003caerodynamics/\u003e 块中，建模了两个无量纲因子, $K_{C_{D, \\mathrm{ge}}}$ 和 $K_{C_L, \\mathrm{ge}}$,它们是无量纲地面高度的函数，并被视为升力和阻力的乘数。这些因子如下所示：\n\u003cfunction name=\"aero/function/kCDge\"\u003e \u003cdescription\u003eChange in drag due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 0.4800 0.1000 0.5150 0.1500 0.6290 0.2000 0.7090 0.3000 0.8150 0.4000 0.8820 0.5000 0.9280 0.6000 0.9620 0.7000 0.9880 0.8000 1.0000 0.9000 1.0000 1.0000 1.0000 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e \u003cfunction name=\"aero/function/kCLge\"\u003e \u003cdescription\u003eChange in lift due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.2030 0.1000 1.1270 0.1500 1.0900 0.2000 1.0730 0.3000 1.0460 0.4000 1.0550 0.5000 1.0190 0.6000 1.0130 0.7000 1.0080 0.8000 1.0060 0.9000 1.0030 1.0000 1.0020 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 下图展示了表示因子 $K_{C_{D, \\text{ ge}}}$ 和 $K_{C_{L, \\text{ ge}}}$ 的表格函数 aero/function/kCDge 和 aero/function/kCLge ，分别表示因地面效应引起的阻力和升力的变化。它们的图形化表示如下，显示了相对于无量纲地面高度 $h/(b/2)$ 的变化。在飞机离地面高度小于机翼半个翼展 $b/2$ 时，可以观察到地面效应；而在更高的高度时，这两个因子值趋于 1。\n以上图表展示了无量纲地面高度 $h/(b/2)$ 的函数，定义了 c172p 飞机气动模型中的 aero/function/kCLge 和 aero/function/kCDge 属性。\n表格 在 JSBSim 中，可以定义一维、二维或三维查找表，用于气动学和函数定义。对于一个单一的“向量”查找表，格式如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003ctableData\u003e key_1 value_1 key_2 value_2 ... ... key_n value_n \u003c/tableData\u003e \u003c/table\u003e 在这个例子中，\u003cindependentVar/\u003e 元素的 lookup=\"row\" 属性是可选的；默认假设 independentVar 是行变量。一个实际的示例如下：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e -1.57 1.500 -0.26 0.033 0.00 0.025 0.26 0.033 1.57 1.500 \u003c/tableData\u003e \u003c/table\u003e 数据表格中的第一列代表查找索引（或 断点，或键）。在这个例子中，查找索引是 aero/alpha-rad（迎角，以弧度为单位）。如果 aero/alpha-rad 的值为 0.26 弧度，则查找表返回的值为 0.033。\n二维表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003ctableData\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 数据是以网格格式呈现的。以下是一个实际示例，其中 aero/alpha-rad 是行查找（迎角的断点排列在第一列），fcs/flap-pos-deg 是列查找（襟翼位置的角度，分别为 0、10、20 和 30 度）：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/flap-pos-deg \u003c/independentVar\u003e \u003ctableData\u003e 0.0 10.0 20.0 30.0 -0.0523599 8.96747e-05 0.00231942 0.0059252 0.00835082 -0.0349066 0.000313268 0.00567451 0.0108461 0.0140545 -0.0174533 0.00201318 0.0105059 0.0172432 0.0212346 0.0 0.0051894 0.0168137 0.0251167 0.0298909 0.0174533 0.00993967 0.0247521 0.0346492 0.0402205 0.0349066 0.0162201 0.0342207 0.0457119 0.0520802 0.0523599 0.0240308 0.0452195 0.0583047 0.0654701 0.0698132 0.0333717 0.0577485 0.0724278 0.0803902 0.0872664 0.0442427 0.0718077 0.088081 0.0968405 \u003c/tableData\u003e \u003c/table\u003e 三维查找表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e property_name_3 \u003c/independentVar\u003e \u003ctableData breakpoint=\"table_1_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003ctableData breakpoint=\"table_2_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e ... \u003ctableData breakpoint=\"table_n_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 请注意 \u003ctableData/\u003e 元素中的 breakpoint 属性。以下是一个示例：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e fcs/row-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/column-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e fcs/table-value \u003c/independentVar\u003e \u003ctableData breakPoint=\"-1.0\"\u003e -1.0 1.0 0.0 1.0000 2.0000 1.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"0.0000\"\u003e 0.0 10.0 2.0 1.0000 2.0000 3.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"1.0\"\u003e 0.0 10.0 20.0 2.0 1.0000 2.0000 3.0000 3.0 4.0000 5.0000 6.0000 10.0 7.0000 8.0000 9.0000 \u003c/tableData\u003e \u003c/table\u003e 插值：表格中的值是线性插值的，且不会在表格的限制值之外进行外推。表格返回的最大值是已定义的最大值。 一维插值 一些仿真中的查找表——尤其是气动数据——可能是四维、五维、六维，甚至更多维度的。Interpolate1d 返回通过对提供的值进行一维插值的结果，其中第一个直接子元素的值表示查找表中的查找值，后续的值对表示自变量和因变量。第一个提供的子元素预期是一个属性。插值不会进行外推，如果提供的查找值超出了定义的范围，则返回最高值。其格式如下：\n\u003cinterpolate1d\u003e {property, value, table, function} {property, value, table, function} {property, value, table, function} ... \u003c/interpolate1d\u003e 示例：如果 mach 为 0.4，插值将返回 0.375。如果 mach 为 1.5，插值将返回 0.60。\n\u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cv\u003e 0.25 \u003c/v\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003cv\u003e 0.50 \u003c/v\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003cv\u003e 0.60 \u003c/v\u003e \u003c/interpolate1d\u003e 上面的示例非常简单。一个更复杂的示例可能会在任何参数（除了第一个）中使用函数。这意味着断点向量可能是变量——尽管这并不常见——但更重要的是，查找向量（第二列）中的值可能是 1、2 或 3 维度的函数表元素。参数甚至可以是嵌套的 interpolate1d 元素。例如：\n\u003cfunction name=\"whatever\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 进一步扩展：\n\u003cfunction name=\"bigWhatever1\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 上面的结构实际上提供了一个五维查找表。在实践中，这会非常庞大且混乱，但这就是实现方式。 :-)\n不过，这里还有更多。对于非常非常大的气动数据库，有时某些气动系数可能不需要计算。例如，地面效应气动系数只在接近地面时才需要计算。当地面效应不对气动力和力矩产生影响时，为什么还要浪费 CPU 循环呢？我们可以使用 ifthen 元素来跳过昂贵的计算。ifthen 元素的工作方式如下：\n如果第一个直接子元素的值为 1，则返回第二个直接子元素的值，否则返回第三个子元素的值。\n\u003cifthen\u003e {property, value, table, or other function element} {property, value, table, or other function element} {property, value, table, or other function element} \u003c/ifthen\u003e 示例：如果 flight-mode 大于 2，则返回 0.00，否则返回属性 control/pitch-lag 的值。\n\u003cifthen\u003e \u003cgt\u003e \u003cp\u003e executive/flight-mode \u003c/p\u003e \u003cv\u003e 2 \u003c/v\u003e \u003c/gt\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cp\u003e control/pitch-lag \u003c/p\u003e \u003c/ifthen\u003e 在我们的例子中，可以如下编写五维查找表查询，除非起落架已放下，否则返回零：\n\u003cfunction name=\"propertyname\"\u003e \u003cifthen\u003e \u003clt\u003e \u003cp\u003e position/altitudeMSL \u003c/p\u003e \u003cv\u003e 90 \u003c/v\u003e \u003c/lt\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003cv\u003e 0 \u003c/v\u003e \u003c/ifthen\u003e \u003c/function\u003e 上面的例子在某种程度上是没有实际意义的，但格式是正确的。从性能角度来看，这是有效的，因为表格只有在查找时确实需要时才会被执行。\n力与力矩 空气动力学 有几种方法可以模拟作用在飞机上的空气动力学力和力矩（扭矩）。JSBSim 最初采用的是系数积累法。在系数积累法中，升力（例如）是通过将所有升力贡献相加来确定的。贡献的具体内容根据飞机的不同和模型的精度而有所不同，但升力的贡献可以包括来自以下方面的贡献：\n机翼 升降舵 襟翼 空气动力学系数是一些数字，这些数字在乘以某些其他值（如动态压力和机翼面积）后，结果就是一个力或力矩。这些系数可以来自飞行试验报告或教科书，或者可以通过软件（如 Digital DATCOM 或其他商业软件）或手工计算来得出。最终，JSBSim 增加了对作为函数指定的空气动力学属性的支持。在配置文件的 \u003caerodynamics\u003e 部分中，有六个子部分，分别代表 3 个力轴和 3 个力矩轴（总共六个自由度）。空气动力学部分的基本布局如下：\n\u003caerodynamics\u003e \u003caxis name=\"DRAG\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"SIDE\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"LIFT\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"ROLL\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"PITCH\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"YAW\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003c/aerodynamics\u003e 并非所有单独的轴都是必需的。JSBSim 支持几组标准的轴系统：\n\"DRAG\"、\"SIDE\"、\"LIFT\"（风轴） \"X\"、\"Y\"、\"Z\"（机体轴） \"AXIAL\"、\"SIDE\"、\"NORMAL\"（机体轴） 所有三个系统都接受 \"ROLL\"、\"PITCH\"、\"YAW\" 轴的定义。轴系统不能混合使用。在轴元素中，函数用于定义对该轴总力或力矩的各个贡献。在 JSBSim 中，函数是被广泛使用的。在定义力或力矩时，函数可以使用表格、常数、三角函数或其他标准 C 库函数。仿真参数通过属性进行引用。以下是一个例子：\n\u003cfunction name=\"aero/force/lift_due_to_flap_deflection\"\u003e \u003cdescription\u003e襟翼偏转引起的升力贡献\u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003eaero/function/ground-effect-factor-lift\u003c/property\u003e \u003cproperty\u003eaero/qbar-area\u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003efcs/flap-pos-deg\u003c/independentVar\u003e \u003ctableData\u003e 0.0 0.0 10.0 0.20 20.0 0.30 30.0 0.35 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在此例中，以上内容的文字描述如下：该函数的值是 ground-effect-factor-lift、qbar-area 和通过表格确定的值的乘积，表格根据襟翼位置（以度为单位）进行索引。\n在 \u003caxis/\u003e 部分中的所有函数都会相加，并以适当的方式应用于飞机。然而，这种格式具有一定的灵活性。那些在任何 \u003caxis/\u003e 部分之外指定的函数会被创建和计算，但它们本身并不会直接贡献到任何力或力矩的总值中。然而，它们可以被引用到位于 \u003caxis/\u003e 部分内的其他函数中。这种技术允许将可能应用于多个单独函数的计算一次性执行，并多次使用。这个技术还可以进一步扩展，实际上，空气动力学系数可以在 \u003caxis/\u003e 定义外计算出来，然后在函数定义内通过乘以各种因子（属性）将它们转换为力和力矩，并最终在 \u003caxis/\u003e 定义中应用。\n力与力矩的例子：瞬时升力 作为一个例子，我们来分析瞬时升力 $L(t)$。它可以通过以下积累公式表示：\n$$ L=L_{\\text {basic }}\\left(\\alpha_{\\mathrm{B}}, \\phi_{\\text {hyst }}\\right)+\\Delta L\\left(\\delta_{\\text {flap }}\\right)+\\Delta L\\left(\\delta_{\\mathrm{e}}\\right)+\\Delta L\\left(\\dot{\\alpha}_{\\mathrm{B}}\\right)+\\Delta L(q) \\tag{1} $$其中，$\\alpha_B$、$\\delta_{\\text{flap}}$、$\\delta_e$、$\\dot{\\alpha}_B$ 和 $q$ 是常见的飞机状态变量。无量纲标量 $\\phi_{\\text{hyst}}$ 通常等于 0，当攻角较大时（接近失速情况，当空气动力学滞后效应被建模时），它的值为 1。\n公式 (1) 中的项 $L_{\\text{basic}}\\left(\\alpha_B, \\phi_{\\text{hyst}}\\right)$ 被称为“基本”贡献，它依赖于攻角。我们知道，增加攻角会增加升力——直到某个点为止。升力通常被定义为飞行动态压力（“qbar”，$\\bar{q}$，或者对于空气动力学家而言是 $\\bar{q}_{\\infty}$）与机翼面积（$S_W$ 或简写为 $S$）和升力系数（$C_L$）的乘积。在本例中，升力系数通过查找表来确定，使用 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 作为查找表的索引：\n\u003cfunction name=\"aero/force/lift_from_alpha\"\u003e \u003cdescription\u003e 升力由于攻角 \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-psf \u003c/property\u003e \u003cproperty\u003e metrics/Sw-sqft \u003c/property\u003e \u003cproperty\u003e aero/function/kCLge \u003c/property\u003e \u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e aero/stall-hyst-norm \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.0000 -0.0900 -0.2200 -0.2200 0.0000 0.2500 0.2500 0.0900 0.7300 0.7300 0.1000 0.8300 0.7800 0.1200 0.9200 0.7900 0.1400 1.0200 0.8100 0.1600 1.0800 0.8200 0.1700 1.1300 0.8300 0.1900 1.1900 0.8500 0.2100 1.2500 0.8600 0.2400 1.3500 0.8800 0.2600 1.4400 0.9000 0.2800 1.4700 0.9200 0.3000 1.4300 0.9500 0.3200 1.3800 0.9900 0.3400 1.3000 1.0500 0.3600 1.1500 1.1500 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 基本升力系数\n$$ C_{L, \\text{ basic }}=\\frac{L_{\\text{ basic }}\\left(\\alpha_B, \\phi_{\\text{hyst }}\\right)}{\\bar{q} S} \\tag{2} $$下面是根据攻角 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 绘制的基本升力系数 $C_{L,\\text{basic}}$ 的曲线。\n上图显示了与 c172p 空气动力学模型中名为 aero/coefficient/CLwbh 的查找表相对应的二元函数 $C_{L,\\text{basic}}(\\alpha_B, \\phi_{\\text{hyst}})$。\nTODO 完成本小节内容。\n该图表示了与 c172p 空气动力学模型中名为 aero/coefficient/CDwbh 的查找表相对应的二元函数 $C_{D,\\text{basic}}(\\alpha_B, \\delta_{\\text{flap}})$。\nTODO 完成本小节内容。\n推力 (Propulsion) 推力部分通常涉及发动机的性能以及与之相关的空气动力学效应。在 JSBSim 中，推力系统通常通过对发动机的建模来实现，这包括计算气流、转速、油门设置和其他影响推力的因素。推力的计算需要依赖于多种因素，比如油门位置、发动机转速、飞行状态等。\n\u003cpropulsion\u003e \u003cengine name=\"engine1\"\u003e \u003cthrustModel\u003egeneric\u003c/thrustModel\u003e \u003crpm\u003e2000\u003c/rpm\u003e \u003cpower\u003e180\u003c/power\u003e \u003cfuelFlow\u003e50\u003c/fuelFlow\u003e \u003cthrust\u003e \u003cfunction\u003ethrust_from_rpm\u003c/function\u003e \u003c/thrust\u003e \u003c/engine\u003e \u003c/propulsion\u003e 在此示例中，我们定义了一个名为 engine1 的发动机，使用了 generic 的推力模型，并为其指定了转速、功率和油耗等参数。推力是通过某个特定的函数来计算的，比如根据发动机转速来推算。\n重量 (Weight) 飞机的重量是影响飞行的关键因素，它包括飞机的自重、载荷以及油料的质量等。重量的变化直接影响到升力、飞行速度以及燃料消耗等参数。在 JSBSim 中，重量可以通过以下方式进行建模：\n\u003cweight\u003e \u003cemptyWeight\u003e1500\u003c/emptyWeight\u003e \u003cmaxTakeoffWeight\u003e2500\u003c/maxTakeoffWeight\u003e \u003cfuelWeight\u003e \u003cproperty\u003efuel/weight\u003c/property\u003e \u003c/fuelWeight\u003e \u003c/weight\u003e 在此示例中，定义了飞机的空重、最大起飞重量以及燃料重量。燃料的重量由 fuel/weight 属性控制，表示当前燃料的质量。\n地面接触 (Ground Contact) 地面接触模型用于模拟飞机与地面之间的交互力和接触点。这些交互力包括着陆、起飞时的冲击力，以及滑行时的摩擦力。在 JSBSim 中，地面接触模型通常包括以下几个部分：\n摩擦力：模拟飞机与地面之间的摩擦。 起落架：描述起落架的刚度、阻尼和承载能力。 接触力：模拟飞机与地面接触时产生的垂直力和水平力。 \u003cgroundContact\u003e \u003ccontact\u003e \u003csurfaceType\u003easphalt\u003c/surfaceType\u003e \u003cfrictionCoefficient\u003e0.8\u003c/frictionCoefficient\u003e \u003clandingGear\u003e \u003cmodel\u003ebasic\u003c/model\u003e \u003cstiffness\u003e2000\u003c/stiffness\u003e \u003cdamping\u003e100\u003c/damping\u003e \u003c/landingGear\u003e \u003c/contact\u003e \u003c/groundContact\u003e 在此示例中，定义了地面接触的表面类型（如沥青）、摩擦系数，以及起落架的刚度和阻尼特性。\n飞行控制与系统建模 将飞机视为一般的动力学系统，它受控制输入向量 $\\boldsymbol{u}$ 的作用。输入的数量和类型可能取决于具体考虑的飞机类型。对于常规配置的飞机，输入的最小配置通常为： $$ \\boldsymbol{u}=\\left[\\delta_{\\mathrm{T}}, \\delta_{\\mathrm{a}}, \\delta_{\\mathrm{e}}, \\delta_{\\mathrm{r}}\\right] \\tag{1} $$ 其中，$\\delta_{\\mathrm{T}}$ 是油门设定，$\\delta_{\\mathrm{a}}$、$\\delta_{\\mathrm{e}}$ 和 $\\delta_{\\mathrm{r}}$ 分别是右副翼、升降舵和方向舵的角度偏转。这些量有标准符号，且它们的范围可能会根据具体的飞机设计有所不同。在飞行仿真中，它们的变化通常与驾驶舱中相应控制的归一化设置相关。\n通常油门的设定范围从 0（空闲）到 +1（最大功率）。从概念上讲，$\\delta_{\\mathrm{T}}$ 可视为实际飞行速度和高度下最大推力输出的当前分数。\n操纵杆的偏转范围通常从 −1 到 +1。\n这些映射通常取决于控制律的存在，这些控制律可能会改变飞行员操作对实际效应器偏转和推力输出的最终影响。\n从数学的角度看，无论是考虑实际的气动表面偏转和推力输出，还是归一化的命令范围，它们都被视为控制变量 $\\boldsymbol{u}$ 的一组边界。\n必须再次强调，控制输入的数量和类型是特定飞机的特征。即使在相同的广泛类别中，两种飞机设计也可能呈现出本质上不同的控制配置和数量。但一般来说，它们至少有相同的“主要”控制：一对副翼，一个主要的纵向控制，即一对对称运动的升降舵，以及一个方向舵。在许多情况下，水平尾翼也具有相对于机身参考线的可变安装角度，这个角度通常称为 $i_{\\mathrm{H}}$，大多数飞行力学教材中都有涉及。\n约定 标准飞机气动控制表面。\n气动建模概述 线性化的迎角系数： $$ C_m=C_{m 0}+C_{m \\alpha} \\alpha_{\\mathrm{B}}+C_{m \\delta_{\\mathrm{e}}} \\delta_{\\mathrm{e}}+C_{m i_{\\mathrm{H}}} i_{\\mathrm{H}}+\\left(C_{m q} q+C_{m \\dot{\\alpha}} \\dot{\\alpha}_{\\mathrm{B}}\\right) \\frac{\\bar{c}}{2 V} \\tag{2} $$ 在 c172p 模型中，升降舵通道的命令与偏转逻辑。操纵杆的移动与迎角调整杆的调节组合，归一化并映射到区间 [−1,1]。该通道的输出是一个实数变量 fcs/elevator-pos-rad，表示一个等效的升降舵偏转 $\\delta_{\\mathrm{e}}^\\star = \\delta_{\\mathrm{e}} + \\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$。其中，$\\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$ 是等效于实际升降舵调整角度 $\\delta_{\\mathrm{e}, \\mathrm{tab}}$ 的偏转角度。$\\delta_{\\mathrm{e}}$ 的范围是 [$\\delta_{\\mathrm{e}, \\mathrm{min}}$, $\\delta_{\\mathrm{e}, \\mathrm{max}}$]。尾部以移动的表面偏转来表示，既有等效条件下（上方）也有实际条件下（下方）的偏转。\n推力建模概述 一架双引擎螺旋桨飞机。在机体坐标系中，推进器、推力应用点和推力矢量的方向位置。\n与 c172p 的 FDM 中的实体 “推进器” 和 “油箱” 相关的位置。",
    "description": "如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。",
    "tags": [],
    "title": "JSBSim User manual",
    "uri": "/uas/fix_wing_uav_flight_sim/jsbsim_user_manual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS Simulation \u003e  Aerodynamics",
    "content": "https://jsbsim-team.github.io/jsbsim-reference-manual/\nJSBSim 是一个轻量级的数据驱动型非线性六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本在线参考手册是一个社区合作项目，旨在让用户和开发者了解软件的所有功能。\n许可证： JSBSim 根据 GNU 较宽通用公共许可证（LGPL）授权。\nAcknowledgements 这款软件是许多人多年来共同努力的成果。\nTony Peden 几乎从 JSBSim 的第一天起就开始为其发展做出贡献。他负责初始化和修剪代码。Tony 还将 David Megginson 的属性系统集成到了 JSBSim 中。Tony 来自俄亥俄州立大学，拥有航空与航天工程学位。\nDavid Culp 为 JSBSim 开发了涡轮发动机模型，并设计了多个使用该模型的飞机，包括 T-38。David 拥有多种军用和民用飞机的飞行经验，包括 T-38、波音 707、727、737、757、767、SGS 2-32 和 OV-10。David 是一名航空航天工程师，毕业于美国空军学院。\nDavid Megginson 曾长期参与 FlightGear 的核心开发工作。David 将我们的飞行动力学与他的一般航空飞行经验相结合，以帮助实现最大程度的真实感，除此之外，他还设计了 FlightGear 和 JSBSim 所使用的属性系统。他以对 XML 技术的贡献而闻名，并编写了 FlightGear 和 JSBSim 使用的 easyXML 解析器。\nErik Hofman 做了多方面的工作，包括寻找飞机数据、创建飞行模型（如 F-16），并进行一些编程工作。他还测试了 IRIX 兼容性。Erik 拥有计算机科学学位。\nMathias Frölich 增加了一个多功能的每个起落架的地面高度能力，并做了许多其他贡献。Mathias 是一位来自德国的数学家。\nAgostino De Marco 为 JSBSim 创建了一个广泛适用的成本/惩罚修剪分析功能，并曾在那不勒斯大学单独使用 JSBSim 或与 FlightGear 一起使用 JSBSim。\n来自英国的 David Luff 提供了最初的活塞发动机模型，Ron Jensen 对其进行了不断的改进。\n拥有多年仿真经验的工程师 Lee Duke 和 Bill Galbraith 提出了许多建议和想法，帮助改进了 JSBSim。\n来自 NASA 兰利研究中心的 Bruce Jackson，参与了多种仿真系统的开发与应用，长期以来一直给予支持和帮助，他许多年前用 C 语言编写的仿真代码（“LaRCSim”）对 JSBSim 的早期开发具有启发意义。\nCurt Olson 协调 FlightGear 及其一些构成部分（SimGear）的开发，多年来在仿真、控制理论和其他许多话题的讨论中给予了极大的帮助。与 FlightGear 社区的合作使 JSBSim 成为一个更好的工具。\n最后，用户和开发者社区的努力使 JSBSim 达到了今天的水平。感谢所有曾经花时间报告 bug 或请求新功能的人。\n前言 JSBSim 于 1996 年构思，作为一个轻量级、数据驱动型、非线性的六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本手册简介 本在线文档分为多个部分。这是因为 JSBSim 可以从不同的角度进行查看：作为飞行器模型开发者的视角，作为将 JSBSim 集成到完整飞行仿真架构中并配有视觉效果的集成者视角，或者作为希望通过添加额外功能来适配或增强 JSBSim 的软件开发者视角。\n文档的 快速入门 部分（第零部分）解释了如何快速开始使用 JSBSim。\n接下来的第一部分是 用户手册，它解释了如何使用 JSBSim 进行仿真运行、创建飞机模型、编写脚本，并执行其他不涉及更改 JSBSim 程序代码的任务。\n第二部分是 程序员手册，解释了 JSBSim 的架构——代码是如何组织的，如何工作。\n第三部分是 公式手册，其中包含了 JSBSim 中存在的数学模型和算法的描述。\n第四部分是一些示例和案例研究，展示了 JSBSim 的使用情况。\n本文档不包含的内容 本文档不是关于推导运动方程和飞行动力学的详尽参考书。有关此类内容，请参阅 (Stevens:Lewis:Johnson:2015) 和 (Zipfel:2003)。然而，本文档旨在成为 JSBSim 的权威文档。\n快速入门 要高效使用 JSBSim，您可能需要采用 程序员的态度。这意味着您需要自行下载源代码并在您的平台上进行编译。只要您的计算机上安装了正确的工具，这其实是一个简单的过程。\n对于急于使用的人，提供了自动远程构建过程，能够交付最新的库二进制文件。您可以通过以下链接找到这些二进制文件：\nFlightGear 项目开发者提供的构建版本 (Jenkins 服务器) Linux 版 JSBSim 构建（Linux CentOS 7 虚拟机） 前往工作区 build.flightgear.org:8080/job/JSBSim/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim/build/src/ 文件夹，您会找到：可执行文件 JSBSim 和静态库文件 libJSBSim.a。\nWindows 版 JSBSim 构建 前往工作区 build.flightgear.org:8080/job/JSBSim-win/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim-win/build/src/Debug/ 文件夹，您会找到：可执行文件 JSBSim.exe 和静态库文件 JSBSim.lib。\n提供预编译 JSBSim 二进制文件的工作是 FlightGear 项目的 持续集成与交付服务 的一部分。如需了解有关 Jenkins 持续集成的更多信息，您可以 访问此链接。\nJSBSim 团队提供的构建版本 (Travis 服务器 和 AppVeyor 服务器) JSBSim 团队提供了自己的持续集成服务，交付适用于 Ubuntu 14.04.5 LTS（Trusty Tahr）和 MS Windows 的 x64 二进制文件。发布版本标记为 v2018a（或更高版本），可以从 GitHub 仓库的 发布区 下载。\n要查看最新构建的当前状态，可以访问以下链接：\nUbuntu 版 Travis 构建（包括 Python 2.7 和 3.6 的测试） Windows 版 AppVeyor 构建（无测试） 那么，您想要模拟这架飞机的飞行吗？\n获取源代码 JSBSim 的 GitHub 仓库可以通过以下链接访问：github.com/JSBSim-Team/jsbsim。该仓库镜像了 SourceForge 上的原始仓库：sourceforge.net/projects/jsbsim。\n下载源代码所需的工具 您需要安装 Git 软件。Git 是一个 版本控制软件，用于记录文件或文件集随时间的变化，以便您可以随时回溯到特定版本。JSBSim 的软件源代码文件是通过 Git 进行版本控制的。\n要安装 Git，请 访问下载页面，并选择适合您平台的版本。您可以通过两种方式在本地使用 Git：通过 GUI 客户端，或通过命令行（例如在 Linux 或 Windows 上使用 Bash shell）。\n安装完 Git 后，假设您将通过命令行使用 Git，您可以从以下两个位置之一 克隆 JSBSim 的公开源代码仓库。\n从 SourceForge 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://git.code.sf.net/p/jsbsim/code jsbsim-code 或者（SSH 模式）\n\u003e git clone git://git.code.sf.net/p/jsbsim/code jsbsim-code 从 GitHub 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://github.com/JSBSim-Team/jsbsim.git jsbsim-code 或者（SSH 模式）\n\u003e git clone git@github.com:JSBSim-Team/jsbsim.git jsbsim-code 那么，您想要模拟这架飞机的飞行吗？\n构建程序和库 JSBSim 可以通过 CMake 或 Microsoft Visual Studio 进行构建。如果您使用的是 Mac OSX 或 Linux 平台，必须使用 CMake。如果您是 Windows 用户，可以选择任意一种工具。\nJSBSim 使用标准 C++98/C99 编写，并且没有外部依赖，因此您只需要在您的平台上安装 C/C++ 编译器即可。\n使用 CMake 构建 CMake 是一个跨平台的构建和测试软件的工具。它可以生成用于使用 GNU make 或 Microsoft Visual Studio 构建 JSBSim 的文件。为了将构建文件与源代码分开，最好在单独的目录中构建 JSBSim。\n\u003e cd jsbsim-code \u003e mkdir build \u003e cd build CMake 不构建 软件，它生成文件 供 多种构建工具使用。以下命令假定您使用 GNU make 来构建 JSBSim。\n首先，您应该调用 CMake 然后执行 make\n\u003e cmake .. \u003e make 这将编译各种类并构建 JSBSim 应用程序，最终文件将位于 build/src 目录下。\n传递给 CMake 的选项 CMake 可以使用多个参数来调整 JSBSim 的构建。以下是不同的选项，您可以根据需要独立使用它们或任意组合。\n传递参数给编译器 如果您想设置编译器选项，可以通过传递标志给 CMake 来构建 JSBSim 的 Debug 版本。JSBSim 也使用 C 语言编写了一些代码，您可以为 C++ 和 C 编译器设置选项。\n\u003e cmake -DCMAKE_CXX_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_C_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_BUILD_TYPE=Debug .. \u003e make 或者，您也可以构建 JSBSim 的发布版本，并请求 GNU Make 使用 4 核心来加速可执行文件的构建。\n\u003e cmake -DCMAKE_CXX_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_C_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_BUILD_TYPE=Release .. \u003e make -j4 构建 Expat 或使用系统库 JSBSim 使用 Expat 库 来读取 XML 文件。Expat 源代码与 JSBSim 源代码一起提供，并在构建过程中与 JSBSim 一起编译。然而，如果 Expat 已经安装在您的平台上，您可能更倾向于使用系统的 Expat 库，以避免重复。在这种情况下，您应该将 SYSTEM_EXPAT 标志传递给 CMake：\n\u003e cmake -DSYSTEM_EXPAT=ON .. \u003e make 构建 JSBSim 的 Python 模块 JSBSim 的 Python 模块也可以通过 CMake 来构建。为此，您需要在您的平台上安装 Cython。CMake 将自动检测到 Cython 并构建 Python 模块。\n使用 Microsoft Visual Studio 构建 在 Visual Studio 中，您可以打开项目文件 JSBSim.vcxproj 来加载 JSBSim 项目。该项目文件将配置 Visual Studio 来构建 JSBSim 可执行文件。\n注意 1： JSBSim 的官方构建工具是 CMake。Visual Studio 项目文件作为一种便利工具提供，并不保证始终与代码保持同步。\n注意 2： 从 Visual Studio 2017 开始，Microsoft 已将 CMake 包含在内，因此您应该能够直接从 CMake 文件在 VS2017 中构建 JSBSim。\n测试 JSBSim JSBSim 附带了一个测试套件，用于自动检查构建是否正确。该测试套件位于 tests 目录中，并使用 Python 编写，因此您需要先构建 JSBSim 的 Python 模块。\n测试套件可以在 build 目录中使用 ctest 运行。可以使用 -j 选项在多个核心上并行运行测试（例如，以下示例中使用 4 核心）。\n\u003e ctest -j4 安装 JSBSim 一旦 JSBSim 被构建和测试完成，您可以将 C++ 头文件和库安装到平台范围内。为此，您可以在 build 目录中调用 GNU make：\n\u003e make install 安装 Python 模块 如果您除了 C++ 头文件和库外，还计划安装 JSBSim 的 Python 模块，那么必须将 INSTALL_PYTHON_MODULE 标志传递给 CMake：\n\u003e cmake -DINSTALL_PYTHON_MODULE=ON .. \u003e make \u003e make install 另外，您也可以通过在 build 目录中执行以下命令手动安装 Python 模块：\n\u003e cd tests \u003e python setup.py install 那么，您想模拟这架飞机的飞行吗？\n使用 Visual Studio 构建 随着 Visual Studio 2017 开始支持 CMake，现在有两种方法可以使用 Visual Studio 2017 构建 JSBSim 及其各种组件。一种是使用标准的 Visual Studio 项目文件（*.vcxproj），用于构建 JSBSim 主程序、Aeromatic++ 等组件，另一种是通过 Visual Studio 使用 CMake 来构建 JSBSim 及其各种组件。\n使用 git 检出 JSBSim 源代码。在这些示例中，源代码已检出到：\nC:\\source\\JSBSim 使用 VS 2017 项目文件构建 选择 文件 → 打开 → 项目/解决方案 … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 JSBSim.sln 文件，在本例中是：\nC:\\source\\JSBSim\\JSBSim.sln 项目文件已配置为将编译器和链接器的中间文件以及最终输出文件存储在 JSBSim 源代码树之外的目录中，即存储在 C:\\source\\JSBSim\\src 外部。\n例如，JSBSim 和 Aeromatic 的中间文件将存储在以下目录中：\nC:\\source\\JSBSim\\Debug\\x64\\JSBSim C:\\source\\JSBSim\\Debug\\x64\\aeromatic 输出文件将位于：\nC:\\source\\JSBSim\\Debug 使用 VS 2017 CMake 支持构建 选择 文件 → 打开 → CMake … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 CMakeLists.txt 文件，在本例中是：\nC:\\source\\JSBSim\\CMakeLists.txt 共有 4 种构建配置：x86、x64 以及每种版本的 Debug 和 Release。选择您想要构建的配置。\n然后使用 CMake 菜单选项选择您想要构建的组件。\n默认情况下，Visual Studio 将配置 CMake 构建到源代码树之外，默认使用用户主目录中的一个构建目录，并且将 GUID（全球唯一标识符）作为目录路径的一部分。您将在 Visual Studio 的输出窗口中看到生成的路径，例如：\n工作目录：C:\\Users\\Sean\\CMakeBuilds\\3f00c6d9-d323-5a32-8a90-665138817fd4\\build\\x64-Release 例如，如果您不想将 CMake 构建文件放在主目录中，可以通过 CMake → 更改 CMake 设置 菜单选项生成一个 CMakeSettings.json 文件，并编辑 buildRoot 和 installRoot 属性。\n最后，Visual Studio 还支持执行 JSBSim 测试。\n运行程序 这里所指的 JSBSim 仓库所在的路径将被称为 \u003cJSBSim-root-dir\u003e。如果您是从源代码构建了 JSBSim，您将在 \u003cJSBSim-root-dir\u003e/src/ 子目录下找到可执行文件（在 Linux 上为 JSBSim，在 Windows 上为 JSBSim.exe）。这是 JSBSim 独立应用程序，您可能希望将其复制到根目录中：\n\u003cJSBSim-root-dir\u003e$ cp src/JSBSim . 运行独立 JSBSim 应用程序时，可能会指定多个选项。\n\u003cJSBSim-root-dir\u003e$ JSBSim 用法（方括号中的项是可选的）： JSBSim [脚本名称] [输出指令文件名称] \u003c选项\u003e 选项： --help 返回使用信息 --version 返回版本号 --outputlogfile=\u003c文件名\u003e 设置/替换数据日志文件的名称 --logdirectivefile=\u003c文件名\u003e 设置数据日志指令文件的名称 --root=\u003c路径\u003e 设置 JSBSim 根目录（即 `src/` 所在目录） --aircraft=\u003c文件名\u003e 设置要模拟的飞机名称 --script=\u003c文件名\u003e 指定要运行的脚本 --realtime 指定按实际世界时间运行 --nice 指示 JSBSim 以低 CPU 使用率运行 --suspend 指定在初始化后暂停仿真 --initfile=\u003c文件名\u003e 指定要使用的初始化文件 --catalog 指示 JSBSim 列出该模型的所有属性 （--catalog 可以与 --aircraft 选项一起在命令行中指定， 或单独指定，同时指定飞机名称，例如 --catalog=c172） --end-time=\u003c时间\u003e 指定仿真结束时间（例如，time=20.5） --property=\u003cname=value\u003e 设置属性的值。 例如：--property=simulation/integrator/rate/rotational=1 注意：选项后跟文件名时，等号两边不能有空格 您可以通过提供脚本名称来运行 JSBSim：\n\u003cJSBSim-root-dir\u003e$ JSBSim --script=scripts/c1723.xml TODO\n完善页面内容。\n那么，您想模拟这架飞机的飞行吗？\n获取支持 获取 JSBSim 支持的最佳方式是注册 GitHub 账户并 关注 JSBSim 仓库：github.com/JSBSim-Team/jsbsim。您可以订阅单独的对话，包括问题（issues）、拉取请求（pull requests）和团队讨论，即使您没有关注该仓库或不是讨论所在团队的成员。如果您不再对某个对话感兴趣，可以随时取消订阅未来的通知。\n要了解更多信息，请阅读此指南。",
    "description": "旨在让用户和开发者了解JSBSim软件的所有功能。",
    "tags": [],
    "title": "JSBSim Quickstart",
    "uri": "/uas/fix_wing_uav_flight_sim/jsbsim_quickstart/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Visualization",
    "content": "原文链接\n1、引言 Tacview 1.5引入了一种新的通用公共文件格式。目的是要克服以前格式的复杂性，同时使其功能更强大。\n和之前一样，这个新的文件格式仍是以纯[UTF-8]文本编写。这样，可以很容易地用最简单的编程语言来导出飞行数据。 Tacview 1.4.3中引入了调试日志，它的语法很容易被阅读，现在很容易诊断出任何输出问题。这种新格式非常简单，如果数据量不是天文数字的话甚至都可以用手工编写！\n尽管格式简单，但它提供了一种非常强大的方式来实时设置和更改战场上任何物体的任何属性。例如，现在可以即时更改联盟、颜色甚至对象的类型！同样，您可以轻松设置和更改全局属性，例如天气。\n重要的是要注意，Tacview尚不支持的数据将保留并在原始遥测窗口中可见。如果您认为重要数据应由Tacview本地支持并显示，请随时与我们联系。\n2、ACMI 2.1 文件格式入门 先从最简单的文件开始：\nFileType=text/acmi/tacview FileVersion=2.1 首先任何ACMI文件中必须具有上述两行强制性的文件头。 这个文件头告诉Tacview期望使用哪种格式。 后面的任何数据都是可选的。\n当然从道理上说，即使Tacview会正常加载这个空文件，但我们也需要更多数据才能使其有用！ 这是一个更有意义的文件：\nFileType=text/acmi/tacview FileVersion=2.1 0,ReferenceTime=2011-06-02T05:00:00Z #47.13 3000102,T=41.6251307|41.5910417|2000.14,Name=C172 为了更好地理解这种结构，我们需要知道，除了其头两行的文件头之外，文件的每一行都可以是：\n符号＃后的数字表示相对于ReferenceTime以秒为单位的一个新的时间帧 对象ID（在此示例中为0和3000102），后跟任意多个用逗号分隔的属性，并使用等号 =为每个属性赋予一个新值。 第三种可能性（此处未显示 ），以减号 - 开头的行，后面跟着的是我们要从战场中删除的对象ID（可能被摧毁或超出记录范围）。 下面让我们详细了解每一行的语法：\n0,ReferenceTime=2011-06-02T05:00:00Z 此行将值 2011-06-02T05:00:00Z 赋予给ID=0的始终是全局对象“零”的ReferenceTime属性。换句话说：此行定义用于确定整个飞行记录的基准/参考时间。 为了更好地理解这个含义，让我们看一下接下来这行：\n#47.13 该行定义了一个相对于ReferenceTime的时间帧（以秒为单位）。 在这种情况下，这意味着以下事件或属性发生在ReferenceTime + 47.13秒⇒2011-06-02T05:00:00Z + 47.13⇒2011-06-02T05:00:47.13Z\n再看下一行：\n3000102,T=41.6251307|41.5910417|2000.14,Name=C172 该行定义了对象3000102的两个属性。为节省空间，对象ID以十六进制表示，没有任何前缀或前导零。\n第一个属性T（代表Transform）是一种特殊的属性，用于定义空间中的对象坐标。稍后我们将了解T支持哪些语法。现在，我们仅关注这种情况：T =经度|纬度|高度。\n请注意，纬度和经度以度表示。正值朝北和朝东。由于整个文件始终采用公制，因此高度以米[MSL]表示（海平面以上，在某些国家中也称为ASL）。\n后面的属性名称显然定义了对象名称Name是C172，这是指定Cessna 172飞机的一种缩写。\n创建飞行记录的所有基本知识就是这些了，然后我们将这个飞机向东移动一点。为此，我们可以简单地在文件中添加另一帧：\n#49 3000102,T=41.626|| 如所见，我们在2011-06-02T05:00:49Z的时间帧为飞机定义了新的经度值41.626。\n可能已经注意到，我们不需要再次指定飞机名称，只是因为自上条记录以来就没有改变过！ 与上一条记录的另一个区别是我们省略了纬度和海拔参数，因为它们也没有改变。 在生成长途飞行数据时，这有助于节省大量空间。 虽然飞机通常机动性很强，但这种优化特别适用于可以静止不动或时不时移动的地面物体。\n3、文件结构详解 为更好地了解ACMI文件的结构，下面让我们一起总结一下文件的要求和与文件格式有关的一些技巧：\n3.1 要求 文本数据必须以UTF-8格式写入。 从而文本属性就支持所有语言。 所有数据都以公制表示，以米为单位，如用米每秒数表示速度、用度表示角度、UTC时间等。 对象ID使用64位十六进制数字表示（不带前缀或前导零以节省空间） 对象0用于定义全局属性（如ReferenceTime或Briefing） 当要赋予一个包含逗号的文本属性时，必须在其前面加上转义字符 \\，以便Tacview不会将其解释为字符串的结尾。 Briefing=Here is a text value\\, which contains an escaped comma in it! 3.2 技巧 为了节省空间，强烈建议仅使用LF \\n字符结束行。 使用UTF-8 字节顺序标记（BOM ）标头为文本数据添加前缀码会更干净。 整个文本数据可以包装在zip或7z容器中，以节省带宽或磁盘空间。 数据可以乱序显示， Tacview会在内存中重新排序。 4、对象坐标 现在，让我们仔细看看对象坐标的不同表示法。 为了优化文件大小，Tacview提供了四种不同的表示法。\n这是两个示例：导出一个子弹坐标时，我们不需要有关其旋转角度的任何数据。 相反的例子是飞行模拟器中的飞机在像Falcon 4.0这样的平面世界中飞行：在这种情况下，为了获得准确的重放，我们需要导出飞机在平面世界中的原始位置、旋转以及在球形的世界的坐标 。 这样，飞机不仅可以在Tacview的球形世界中正确显示，而且遥测计算也可在对象的原始坐标系中完成，因此屏幕上见到的数字将与在原始飞行模拟器中看到的数字匹配。\nObject Position Syntax Purpose T = Longitude | Latitude | Altitude 球形世界中的简单对象（通常是子弹之类的次要对象）。 也可以与没有旋转信息的低端数据源（如GPX文件）相关。 T = Longitude | Latitude | Altitude | U | V 来自平面世界坐标的简单对象。 U＆V代表本机x和y。 即使原始坐标以英尺为单位，也不要忘记换算为以米为单位。 海拔高度不重复省略掉了，因为原始世界坐标和球形世界坐标都一样。 T = Longitude | Latitude | Altitude | Roll | Pitch | Yaw 球形世界中的复杂对象。 飞机向右滚转时，滚转为正。 起飞时俯仰为正。 偏航角相对于正北的顺时针方向夹角。 T = Longitude | Latitude | Altitude | Roll | Pitch | Yaw | U | V | Heading 来自平面世界的复杂对象。 和之前一样。 航向（Heading）是相对于平面世界正北的偏航角。 之所以需要这样做，是因为由于投影误差，原始世界的北通常与球形世界的北并不一致。 请记住，您可以省略自上次以来未更改的组件。 这样可以节省很多空间。\n如果某些数据丢失（例如，对象旋转），Tacview将会去尽量模拟它，以提供良好的重放。 与优化无关，在对象生命周期中，应为每个对象保留相同的数据表示法。 如果在某一时刻使用了不同的表示法，Tacview将会把对象升级为更复杂的表示法。 但是，由于最初缺乏数据，最终结果可能难以预料。\n5、全局属性 我们已经看到，最重要的全局属性之一是ReferenceTime。 显然，您可以在飞行记录中注入许多其他元数据，以使重放更加详细。\n文本属性 Property Name Meaning DataSource 源模拟器，控制台或文件格式。\nDataSource=DCS 2.0.0.48763 DataSource=GPX File DataRecorder 用于记录数据的软件或硬件。\nDataRecorder=Tacview 1.5 DataRecorder=Falcon 4.0 ReferenceTime 当前任务的基准时间（UTC）。 该时间与每个帧偏移（以秒为单位）相结合，以获得每个数据样本最终的绝对UTC时间。\nReferenceTime=2011-06-02T05:00:00Z RecordingTime 记录（文件）创建（UTC）时间。\nRecordingTime=2016-02-18T16:44:12Z Author 创建此记录的作者或操作员。\nAuthor=Lt. Cmdr. Rick 'Jester' Heatherly Title 任务/飞行的标题或名称。\nTitle=Counter Attack Category 飞行/任务的类别。\nCategory=Close air support Briefing 包含飞行/任务简介的自由文本。 Briefing=Destroy all SCUD launchers Debriefing 包含任务报告的自由文本。\nDebriefing=Managed to stay ahead of the airplane. Comments 关于飞行的自由评论。 不要忘记转义任何要插入注释中的行尾字符。\nComments=Part of the recording is missing because of technical difficulties. 5.2 数字属性 Property Name Unit Meaning ReferenceLongitude ReferenceLatitude deg 这些属性用于通过将坐标以一个中间点为原点来减小文件大小。 它们会被加到每个对象的经度和纬度来求得最终坐标。 ReferenceLongitude=-129 ReferenceLatitude=43 5.3 事件 事件可用于将任何类型的文本、记号和调试信息注入飞行记录中。 它们有点特殊：它们像属性一样被声明，但是与属性不同，您可以在同一帧中声明多个事件而不会覆盖前一个事件。\n这是有关如何注入事件的示例：\n#8.62 0,Event=Message|3000100|Here is a generic event linked to the object 3000100 0,Event=Bookmark|Here is a bookmark to highlight a specific part of the mission! #8.72 0,Event=Debug|Here is some debug text, visible only with the /Debug:on command line option 事件声明的结构：\nEvent = EventType | FirstObjectId | SecondObjectId | ... | EventText 对于每个事件，我们必须首先声明事件的类型（例如：标记），然后可选地声明有关对象的ID。 例如，当用户双击事件时，Tacview将使用这些ID将摄像机自动围绕相关对象居中。 最后一部分是强制性的文本信息。 虽然可以提供空白文本，但是建议您提供有用的信息，从而可以充分利用报告。\n这是Tacview当前支持的不同类型的事件：\nEvent Name Meaning Message 通用事件。0,Event=Message|705|Maverick has violated ATC directives Bookmark 记号在时间线和事件日志中突出显示。 它们很容易发现，并且易于突出飞行中的某些部分，例如轰炸或受训者最后着陆时。0,Event=Bookmark|Starting precautionary landing practice Debug 调试事件高亮显示，很容易在时间轴和事件日志中发现。 由于必须将它们用于开发目的，因此仅在使用命令行启动Tacview时带上参数/Debug:on时才会显示它们0,Event=Debug|327 active planes LeftArea 此事件对于指定何时将飞机（或任何物体）从战场上完全地移走（不是被摧毁）非常有用。 这样可以防止Tacview错误生成Destroyed事件。0,Event=LeftArea|507| Destroyed 当物体被正式摧毁时。0,Event=Destroyed|6A56| TakenOff 由于Tacview可能无法始终正确地自动检测起飞事件，因此在飞行记录中手动添加此事件可能很有用。0,Event=TakenOff|2723|Col. Sinclair has taken off from Camarillo Airport Landed 由于Tacview可能无法始终正确地自动检测降落事件，因此在飞行记录中手动添加此事件可能很有用。0,Event=Landed|705|Maverick has landed on the USS Ranger Timeout 主要用于现实世界中的训练报告，以指定武器（通常是导弹）何时达到或错过其目标。 Tacview将在射击日志以及3D视图中报告射击结果。 大多数参数是可选的。 SourceId指定发射武器的对象，而TargetId为指定的射击目标。 即使显示的结果可能是海里，也必须以米为单位指定靶心坐标。 必须使用独立于此事件的适当属性来明确（手动）销毁或禁用目标。0,Event=Timeout|SourceId:507|AmmoType:FOX2|AmmoCount:1|Bullseye:50/15000/2500|TargetId:201|IntendedTarget:Leader|Outcome:Kill 6、对象属性 从Tacview 1.5开始，可以实时设置和更改任何对象属性。 即使新属性可能并不总是在3D视图中可见，您也可以始终在原始遥测窗口中查看当前选定对象的每个属性的当前值。\nTacview 1.7引入了一个新的对象 database ，可以预定义Type和Name所需的任何对象属性。 例如，您可以在该数据库中预定义F-16C的默认形状。 如果遥测文件中未定义Shape属性值，则Tacview将使用数据库中存储的值，并在3D视图中显示F-16C的自定义3D模型。\n通过阅读专用文档.了解如何更新和扩展Tacview数据库。\n6.1 文本属性 Property Name Meaning Name 对象名称应为每个对象使用最通用的符号。 强烈建议使用ICAO或北约名称，例如：C172或F A-18C。 这将有助于Tacview将每个对象与其数据库中的相应条目相关联。 只有类型Type和名称Name是不能在Tacview数据库中预定义的属性。Name=F-16C-52 Type 对象类型是使用标签构建的。 与以前的独占类型相比，这使对象管理更加强大和透明。 （请参阅下面的受支持类型列表）。只有类型Type和名称Name是不能在Tacview数据库中预定义的属性。Type=Air+FixedWing AdditionalType 此处定义的所有标签都将添加到当前对象类型中。 这对强制在遥测数据中未明确定义的对象类型很有用。 例如，您可以使用此属性为来自Garmin csv文件（通常不包含任何类型声明）的Cessna 172遥测数据自动设置FixedWing标签。 出于明显的原因，此属性只能在Tacview数据库中使用，而在遥测文件中则不能使用。\u003cAdditionalType\u003eAir+FixedWing\u003c/AdditionalType\u003e Parent 父级十六进制对象ID。 例如，可用于关联导弹（子对象）及其发射飞机（父对象）。 Parent=2D50A7 Next 跟随对象的十六进制ID。 通常用于将航路点链接在一起。Next=40F1 ShortName 该缩写名称将显示在3D视图中，并且在任何其他情况下都将以较小的空间显示对象名称。 通常在Tacview数据库中定义。 不应在遥测数据中定义。ShortName=A-10C LongName 更详细的对象名称，用在比杂乱的3D视图有更多空间但空间不足以显示完整详细名称的小窗口中。 为了便于阅读，建议首先以短名称（通常是北约代码的缩写）开头，然后是对象昵称/北约名称。 通常在Tacview数据库中定义。 不应在遥测数据中定义。LongName=A-10C Thunderbolt II FullName 完整的对象名称，通常在窗口和其他日志中显示，只要有足够的空间可以显示很多数据而不会出现混乱的情况。 通常在Tacview数据库中定义。 不应在遥测数据中定义。FullName=Fairchild Republic A-10C Thunderbolt II CallSign 呼叫符号将优先于对象名称（有时是飞行员名称）显示，尤其是在3D视图和选择框中。 这对于任务报告很方便，在这些任务报告中，呼号比飞机名称更有意义。CallSign=Jester Registration 飞机注册号（又名尾号）Registration=N594EX Squawk 当前的应答器代码。 任何代码都是可能的，没有像旧的4位数字应答器那样的限制。Squawk=1200 Pilot 飞机驾驶员的指挥名称。Pilot=Iceman Group 对对象所属的组进行分组。 用于将对象分组在一起。 例如，一个F-16编队一起飞过CAP。Group=Springfield Country ISO 3166-1 alpha-2 国家代码 Country=us Coalition 联军属性（敌军、友军）Coalition=Allies Color 可以是以下颜色之一：Red, Orange, Green, Blue, Violet。 颜色是预定义的，以确保在所有情况下都能清晰显示整个战场。Color=Blue Shape 3D模型的文件名，将用于表示3D视图中的对象。 3D模型必须为Wavefront .obj文件格式，并存储在%ProgramData%\\Tacview\\Data\\Meshes\\或%APPDATA%\\Tacview\\Data\\Meshes\\中。可以阅读专用文档，了解有关3D模型的更多信息Shape=Rotorcraft.Bell 206.obj Debug 使用/Debug:on命令行参数启动Tacview时，调试文本在3D视图中可见。Debug=ObjectHandle:0x237CB9 Label 可在3D视图和遥测窗口中显示的自由实时文本（向最终用户提供其他信息）Label=Lead aircraft FocusedTarget 该对象当前瞄准的目标（通常用于指定激光束目标对象，也可用于显示飞行员当前瞄准的目标）FocusedTarget=3001200 LockedTarget 首要目标十六进制ID（可以使用任何设备锁定，例如雷达，IR，NVG等）LockedTarget=3001200 6.2 数字属性 Property Name Unit Meaning Importance ratio 比率越高，对象就越重要（例如，本地模拟的飞机可能是1.0的重要因子）Importance=1 Slot index 机群中的飞机地位（最低的是领导者） Slot=0 Disabled boolean 指定禁用一个对象（通常是战斗结束）而不将其销毁。 这对于战斗训练和射击记录特别有用。Disabled=1 Length m 对象长度。 在显示建筑物时特别有用。Length=20.5 Width m 对象宽度。 在显示建筑物时特别有用。Width=10.27 Height m 对象高度。 在显示建筑物时特别有用。 Height=4 Radius m 对象边界球半径。 可用于定义自定义爆炸，烟雾/手榴弹半径。 可以用于动画。Radius=82 IAS m/s 指示空速 IAS=69.4444 CAS m/s 标定空速 CAS=250 TAS m/s 真空速 TAS=75 Mach ratio 马赫数 Mach=0.75 AOA deg 迎角 AOA=15.7 AGL m 物体高于地面的高度 AGL=1501.2 HDG deg 飞机的航向。 如果没有可用的滚转和俯仰数据，则此属性可用于指定偏航，同时在3D视图中保持完整的旋转仿真。 HDG=185.3 HDM deg 飞机的磁航向。 相对于局部磁北偏航。 HDM=187.3 Throttle ratio 主/发动机1号油门手柄位置（对于加力燃烧室，该值可以\u003e 1，对于倒档来说可以\u003c0） Throttle=0.75 Afterburner ratio 主/引擎1加力燃烧器状态 Afterburner=1 AirBrakes ratio 空气制动器状态AirBrakes=0 Flaps ratio 襟翼位置Flaps=0.4 LandingGear ratio 起落架状态 LandingGear=1 LandingGearHandle ratio 起落架手柄位置LandingGearHandle=0 Tailhook ratio 抓钩状态 Tailhook=1 Parachute ratio 降落伞状态（不要误认为DragChute） Parachute=0 DragChute ratio 拖曳伞状态DragChute=1 FuelWeight to FuelWeight9 kg 当前每个油箱中可用的燃油量（最多支持10个油箱）。FuelWeight4=8750 FuelVolume to FuelVolume9 l 当前每个油箱中可用的燃油量（最多支持10个油箱）。 FuelVolume=75 FuelFlowWeight to FuelFlowWeight8 kg/hour 每个引擎的燃油流量（最多支持8个引擎）。 FuelFlowWeight2=38.08 FuelFlowVolume to FuelFlowVolume8 l/hour 每个引擎的燃油流量（最多支持8个引擎）。FuelFlowVolume2=53.2 RadarMode number 雷达模式 (0 = off) RadarMode=1 RadarAzimuth deg 相对于飞机方向的雷达方位角（航向） RadarAzimuth=-20 RadarElevation deg 相对于飞机方向的雷达仰角 RadarElevation=15 RadarRange m 雷达扫描范围 RadarRange=296320 RadarHorizontalBeamwidth deg 雷达水平波束宽度 RadarHorizontalBeamwidth=40 RadarVerticalBeamwidth deg 雷达垂直波束宽度 RadarVerticalBeamwidth=12 LockedTargetMode number 首要目标锁定模式 (0 = no lock/no target) LockedTargetMode=1 LockedTargetAzimuth deg 相对于飞机方向的首要目标方位角（航向）LockedTargetAzimuth=14.5 LockedTargetElevation deg 相对于飞机方向的首要目标俯仰角 LockedTargetElevation=0.9 LockedTargetRange m 距飞机的主要目标距离LockedTargetRange=17303 EngagementMode EngagementMode2 number 开关机状态（例如，当SAM站点关闭其雷达时）(0 = off) EngagementMode=1 EngagementRange EngagementRange2 VerticalEngagementRange VerticalEngagementRange2 m 防空单元的有效范围。 这是将在3D视图中显示的球体的半径。 通常用于SAM和AAA单位，但这也可能与军舰有关。 EngagementRange = 2500您可以选择指定垂直有效范围以绘制蛋形有效气泡形状。VerticalEngagementRange=1800 RollControlInput PitchControlInput YawControlInput ratio 原始玩家HOTAS /Yoke的真实位置（飞行模拟输入设备）PitchControlInput=0.41 RollControlPosition PitchControlPosition YawControlPosition ratio 模拟（带有响应曲线）或现实驾驶舱中的HOTAS/Yoke位置 PitchControlPosition=0.3 RollTrimTab PitchTrimTab YawTrimTab ratio 每个轴的修剪位置 Trim position for each axisPitchTrimTab=-0.15 AileronLeft AileronRight Elevator Rudder ratio 控制面在飞机上的位置 Elevator=0.15 Visible boolean 此标志对于从3D视图隐藏特定对象很有用。 可以用于战争迷雾效果，或防止显示虚拟对象。Visible=0 PilotHeadRoll PilotHeadPitch PilotHeadYaw deg 在驾驶舱内飞行员头部方位相对于飞机方位的方位PilotHeadPitch=12 6.3 对象类型 (aka Tags) 现在，可以使用标签的自由组合来定义对象类型。 标签越多，定义的对象越准确。 标签以加号+分隔。 这里有些例子：\nObject Kind Type (Tags) Aircraft Carrier Type=Heavy+Sea+Watercraft+AircraftCarrier F-16C Type=Medium+Air+FixedWing Bicycle Type=Light+Ground+Vehicle AIM-120C Type=Medium+Weapon+Missile Waypoint Type=Navaid+Static+Waypoint 这是当前支持的标签的列表。 Tacview将使用它们进行显示和分析。\nUse Tags Class Air\nGround\nSea\nWeapon\nSensor\nNavaid\nMisc Attributes Static\nHeavy\nMedium\nLight\nMinor Basic Types FixedWing\nRotorcraft\nArmor\nAntiAircraft\nVehicle\nWatercraft\nHuman\nBiologic\nMissile\nRocket\nBomb\nTorpedo\nProjectile\nBeam\nDecoy\nBuilding\nBullseye\nWaypoint Specific Types Tank\nWarship\nAircraft\nCarrier\nSubmarine\nInfantry\nParachutist\nShell\nBullet\nFlare\nChaff\nSmokeGrenade\nAerodrome\nContainer\nShrapnel\nExplosion 以下是推荐的常见类型（标记的组合），您应该使用它们来描述大多数对象以在Tacview 1.x中显示：\nType Tags Plane Air + FixedWing Helicopter Air + Rotorcraft Anti-Aircraft Ground + AntiAircraft Armor Ground + Heavy + Armor + Vehicle Tank Ground + Heavy + Armor + Vehicle + Tank Ground Vehicle Ground + Vehicle Watercraft Sea + Watercraft Warship Sea + Watercraft + Warship Aircraft Carrier Sea + Watercraft + AircraftCarrier Submarine Sea + Watercraft + Submarine Sonobuoy Sea + Sensor Human Ground + Light + Human Infantry Ground + Light + Human + Infantry Parachutist Ground + Light + Human + Air + Parachutist Missile Weapon + Missile Rocket Weapon + Rocket Bomb Weapon + Bomb Projectile Weapon + Projectile Beam Weapon + Beam Shell Projectile + Shell Bullet Projectile + Bullet Ballistic Shell Projectile + Shell + Heavy Decoy Misc + Decoy Flare Misc + Decoy + Flare Chaff Misc + Decoy + Chaff Smoke Grenade Misc + Decoy + SmokeGrenade Building Ground + Static + Building Aerodrome Ground + Static + Aerodrome Bullseye Navaid + Static + Bullseye Waypoint Navaid + Static + Waypoint Container Misc + Container Shrapnel Misc + Shrapnel Minor Object Misc + Minor Explosion Misc + Explosion 7、注释 为了在导出程序的调试过程中提供帮助，可以在文件的任何行加上双斜杠//作为前缀，与C ++一致。\n// This line and the following are commented // 3000102,T=41.6251307|41.5910417|2000.14,Name=C172 加载文件时，Tacview将忽略这些行。 注释不保留。 您会注意到，下次您从Tacview保存文件时，它们将被丢弃。 如果要包括保留的调试信息，则可以使用前面在全局属性中描述的专用的Debug Event 。\n由于加载性能的考虑，只能在每行的开头插入注释。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Tacview Technical Reference",
    "uri": "/visual/tacview/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM \u003e  Antenna Pattern",
    "content": "一、辛格方向图数学模型 辛格方向图（Sinc Directional Diagram）模型是电子战仿真中常用的一种天线方向图模型，其数学表达式基于归一化的 sinc 函数，可以用于描述天线的辐射方向性。辛格方向图模型的表达式如下：\n$$ G(\\theta) = G_{\\text{max}} \\cdot \\left( \\frac{\\sin(N \\pi \\sin \\theta)}{N \\pi \\sin \\theta} \\right)^2 $$其中：\n$G(\\theta)$：在方向 $\\theta$ 上的天线增益。 $G_{\\text{max}}$：最大增益，通常出现在主瓣方向。 $\\theta$：观察方向与天线主轴之间的夹角。 $N$：天线阵列的阵元数。 特性说明： 主瓣与旁瓣：\n主瓣是指 $\\theta = 0$ 方向上的主要辐射能量范围，主瓣增益为 $G_{\\text{max}}$。 边旁瓣的幅度由阵元数 $N$ 决定，$N$ 越大，旁瓣越小。 归一化因子：\n归一化的 sinc 函数确保方向图的辐射功率在不同方向上的分布符合物理实际。 阵列影响：\n增加阵元数会使主瓣更加集中，旁瓣抑制效果更好。 应用场景： 辛格方向图模型广泛用于线性阵列天线、相控阵天线等的仿真，尤其是在电子战、通信和雷达信号处理中，用于评估天线的方向性性能。\n二、测试计算器 https://claude.site/artifacts/5f11ccb8-beb2-48a2-8a00-eddd0f871edc\n测试计算器代码：\nimport React, { useState } from 'react'; import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, PolarGrid, PolarAngleAxis, PolarRadiusAxis, RadarChart, Radar } from 'recharts'; import { Slider } from '@/components/ui/slider'; import { Button } from '@/components/ui/button'; import { Label } from '@/components/ui/label'; import { CalculatorIcon } from 'lucide-react'; const SincCalculator = () =\u003e { const [N, setN] = useState(8); const [tempN, setTempN] = useState(8); const [Gmax, setGmax] = useState(1); const [tempGmax, setTempGmax] = useState(1); const [cartesianData, setCartesianData] = useState([]); const [polarData, setPolarData] = useState([]); // 关键方位角定义 const keyAngles = [0, 45, 90, 135, 180, 225, 270, 315]; const calculateGain = (theta, N, Gmax) =\u003e { const thetaRad = (theta * Math.PI) / 180; const sinTheta = Math.sin(thetaRad); if (Math.abs(sinTheta) \u003c 1e-10) { return Gmax; } const numerator = Math.sin(N * Math.PI * sinTheta); const denominator = N * Math.PI * sinTheta; return Gmax * Math.pow(numerator / denominator, 2); }; const updateData = () =\u003e { const newCartesianData = []; const newPolarData = []; // 更新直角坐标数据 for (let theta = -90; theta \u003c= 90; theta += 1) { const gain = calculateGain(theta, tempN, tempGmax); const gainDB = 10 * Math.log10(Math.max(gain, 1e-10)); newCartesianData.push({ theta, gain: gainDB }); } // 更新极坐标数据 for (let theta = 0; theta \u003c 360; theta += 5) { // 对于大于180度的角度，使用对称性计算 const calcTheta = theta \u003c= 180 ? theta - 90 : 270 - theta; const gain = calculateGain(calcTheta, tempN, tempGmax); const gainDB = 10 * Math.log10(Math.max(gain, 1e-10)); const normalizedGain = Math.pow(10, gainDB/20); newPolarData.push({ theta, gain: normalizedGain, gainDB }); } setCartesianData(newCartesianData); setPolarData(newPolarData); setN(tempN); setGmax(tempGmax); }; // 自定义角度轴刻度格式化 const formatPolarAngle = (angleValue) =\u003e { // 只有关键角度才显示标签 if (keyAngles.includes(angleValue)) { return `${angleValue}°`; } return ''; }; return ( \u003cCard className=\"w-full max-w-4xl p-6\"\u003e \u003cCardHeader\u003e \u003cCardTitle\u003e辛格方向图计算器\u003c/CardTitle\u003e \u003c/CardHeader\u003e \u003cCardContent\u003e \u003cdiv className=\"space-y-6\"\u003e {/* 参数控制区 */} \u003cdiv className=\"space-y-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e阵元数 (N): {tempN}\u003c/Label\u003e \u003cSlider value={[tempN]} min={2} max={32} step={1} onValueChange={(value) =\u003e setTempN(value[0])} className=\"w-full\" /\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e最大增益 (Gmax): {tempGmax}\u003c/Label\u003e \u003cSlider value={[tempGmax]} min={0.1} max={2} step={0.1} onValueChange={(value) =\u003e setTempGmax(value[0])} className=\"w-full\" /\u003e \u003c/div\u003e \u003cButton onClick={updateData} className=\"w-full\" \u003e \u003cCalculatorIcon className=\"w-4 h-4 mr-2\" /\u003e 重新计算 \u003c/Button\u003e \u003c/div\u003e \u003cdiv className=\"grid grid-cols-1 md:grid-cols-2 gap-6\"\u003e {/* 直角坐标图 */} \u003cdiv className=\"w-full overflow-x-auto\"\u003e \u003ch3 className=\"text-lg font-medium mb-4\"\u003e直角坐标方向图\u003c/h3\u003e \u003cLineChart width={500} height={300} data={cartesianData} margin={{ top: 5, right: 30, left: 20, bottom: 5, }} \u003e \u003cCartesianGrid strokeDasharray=\"3 3\" /\u003e \u003cXAxis dataKey=\"theta\" label={{ value: '方位角 (度)', position: 'bottom' }} /\u003e \u003cYAxis label={{ value: '增益 (dB)', angle: -90, position: 'insideLeft' }} domain={[-40, 0]} /\u003e \u003cTooltip /\u003e \u003cLine type=\"monotone\" dataKey=\"gain\" stroke=\"#2563eb\" dot={false} strokeWidth={2} /\u003e \u003c/LineChart\u003e \u003c/div\u003e {/* 极坐标图 */} \u003cdiv className=\"w-full overflow-x-auto\"\u003e \u003ch3 className=\"text-lg font-medium mb-4\"\u003e极坐标方向图\u003c/h3\u003e \u003cRadarChart width={500} height={300} data={polarData} cx=\"50%\" cy=\"50%\" \u003e \u003cPolarGrid /\u003e \u003cPolarAngleAxis dataKey=\"theta\" tickFormatter={formatPolarAngle} ticks={keyAngles} /\u003e \u003cPolarRadiusAxis angle={90} domain={[0, 1]} tickFormatter={(value) =\u003e `${(20 * Math.log10(value)).toFixed(0)}dB`} /\u003e \u003cRadar name=\"增益\" dataKey=\"gain\" stroke=\"#2563eb\" fill=\"#2563eb\" fillOpacity={0.6} /\u003e \u003cTooltip formatter={(value, name, props) =\u003e [ `${(20 * Math.log10(value)).toFixed(2)} dB`, '增益' ]} /\u003e \u003c/RadarChart\u003e \u003c/div\u003e \u003c/div\u003e {/* 关键点数据显示 */} \u003cdiv className=\"grid grid-cols-2 gap-4 mt-4\"\u003e \u003cdiv className=\"p-4 border rounded\"\u003e \u003ch3 className=\"font-medium\"\u003e主瓣增益 (0°)\u003c/h3\u003e \u003cp\u003e{(10 * Math.log10(calculateGain(0, N, Gmax))).toFixed(2)} dB\u003c/p\u003e \u003c/div\u003e \u003cdiv className=\"p-4 border rounded\"\u003e \u003ch3 className=\"font-medium\"\u003e副瓣电平 (±90°)\u003c/h3\u003e \u003cp\u003e{(10 * Math.log10(calculateGain(90, N, Gmax))).toFixed(2)} dB\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/CardContent\u003e \u003c/Card\u003e ); }; export default SincCalculator; 三、模型代码 Python代码 用于测试和可视化辛格方向图模型的代码。这个代码将展示不同阵元数对方向图的影响。\nimport numpy as np import matplotlib.pyplot as plt def calc_sinc_pattern(theta_deg, N, G_max=1.0): \"\"\" 计算辛格方向图模型的增益 参数: theta_deg: ndarray, 观察角度（度） N: int, 天线阵元数 G_max: float, 最大增益 返回: ndarray: 对应角度的增益值 \"\"\" # 将角度转换为弧度 theta_rad = np.deg2rad(theta_deg) # 避免除零错误 sin_theta = np.sin(theta_rad) numerator = np.sin(N * np.pi * sin_theta) denominator = N * np.pi * sin_theta # 处理 theta = 0 的特殊情况 zero_indices = np.where(np.abs(sin_theta) \u003c 1e-10) result = np.zeros_like(theta_deg, dtype=float) # 计算非零角度的增益 nonzero_indices = np.where(np.abs(sin_theta) \u003e= 1e-10) result[nonzero_indices] = G_max * (numerator[nonzero_indices] / denominator[nonzero_indices]) ** 2 # 设置零角度的增益为最大值 result[zero_indices] = G_max return result def plot_pattern(N_values): \"\"\" 绘制不同阵元数的方向图 参数: N_values: list, 要比较的阵元数列表 \"\"\" # 创建角度数组（-90度到90度） theta = np.linspace(-90, 90, 1000) # 设置图形样式 plt.figure(figsize=(12, 8)) plt.grid(True, linestyle='--', alpha=0.7) # 为每个阵元数绘制方向图 for N in N_values: gain_db = 10 * np.log10(calc_sinc_pattern(theta, N)) plt.plot(theta, gain_db, label=f'N={N}') # 设置图形属性 plt.xlabel('方位角 (度)') plt.ylabel('增益 (dB)') plt.title('辛格方向图模型 - 不同阵元数比较') plt.legend() plt.ylim(-40, 0) # 限制最小增益为-40dB plt.show() def test_pattern(): \"\"\" 测试函数：验证方向图的关键特性 \"\"\" # 测试不同阵元数和角度的组合 N_test = [4, 8, 16] theta_test = np.array([0, 30, 60]) print(\"辛格方向图模型测试结果：\") print(\"-\" * 50) for N in N_test: print(f\"\\n阵元数 N = {N}\") gains = calc_sinc_pattern(theta_test, N) gains_db = 10 * np.log10(gains) for theta, gain, gain_db in zip(theta_test, gains, gains_db): print(f\"角度: {theta:3.0f}° | 增益: {gain:.4f} | 增益(dB): {gain_db:.2f} dB\") # 运行测试 if __name__ == \"__main__\": # 执行数值测试 test_pattern() # 绘制不同阵元数的方向图比较 plot_pattern([4, 8, 16]) 以上代码实现了以下功能：\ncalc_sinc_pattern 函数：\n实现了辛格方向图的数学模型 处理了零角度的特殊情况 支持向量化计算，提高效率 plot_pattern 函数：\n绘制极坐标形式的方向图 支持多个阵元数的对比 使用 dB 单位显示增益 test_pattern 函数：\n验证不同角度和阵元数的组合 输出详细的测试结果 要运行这个代码，需要安装 NumPy 和 Matplotlib 库。运行后，将看到：\n控制台输出：显示不同阵元数和角度组合的具体增益值 图形输出：展示不同阵元数的方向图对比 你可以通过修改 N_values 和测试角度来探索不同的参数组合。需要特别注意的是：\n增益值已经归一化，最大值为1（0 dB） 图表中使用了 dB 单位以better展示旁瓣特性 程序处理了 θ = 0° 时的奇异点 C++代码 以下为一个易于集成的C++辛格方向图计算模块，包含清晰的输入输出接口。\n// SincDirectionalModel.hpp #ifndef SINC_DIRECTIONAL_MODEL_HPP #define SINC_DIRECTIONAL_MODEL_HPP #include \u003cvector\u003e #include \u003ccmath\u003e #include \u003cstdexcept\u003e namespace DirectionalModel { /** * @brief 辛格方向图计算模块 * 用于计算和分析天线的辛格方向图特性 */ class SincDirectionalModel { public: /** * @brief 构造函数 * @param elementCount 天线阵元数 * @param maxGain 最大增益值 * @throw std::invalid_argument 当参数无效时抛出异常 */ SincDirectionalModel(unsigned int elementCount = 8, double maxGain = 1.0); /** * @brief 设置天线阵元数 * @param elementCount 天线阵元数 * @return bool 设置是否成功 */ bool setElementCount(unsigned int elementCount); /** * @brief 设置最大增益 * @param maxGain 最大增益值 * @return bool 设置是否成功 */ bool setMaxGain(double maxGain); /** * @brief 计算指定角度的增益 * @param angle_deg 观察角度（度） * @return double 增益值 */ double calculateGain(double angle_deg) const; /** * @brief 计算指定角度的分贝增益 * @param angle_deg 观察角度（度） * @return double 分贝增益值 */ double calculateGainDB(double angle_deg) const; /** * @brief 生成方向图数据点 * @param startAngle 起始角度（度） * @param endAngle 结束角度（度） * @param stepSize 角度步长（度） * @return std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e 角度-增益对 */ std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e generatePattern( double startAngle = -90.0, double endAngle = 90.0, double stepSize = 1.0) const; /** * @brief 生成分贝方向图数据点 * @param startAngle 起始角度（度） * @param endAngle 结束角度（度） * @param stepSize 角度步长（度） * @return std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e 角度-分贝增益对 */ std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e generatePatternDB( double startAngle = -90.0, double endAngle = 90.0, double stepSize = 1.0) const; /** * @brief 获取天线关键参数 * @return std::pair\u003cdouble, double\u003e 主瓣增益(dB)和第一旁瓣电平(dB) */ std::pair\u003cdouble, double\u003e getKeyParameters() const; private: unsigned int N_; // 天线阵元数 double Gmax_; // 最大增益 const double PI = 3.14159265358979323846; // 检查角度参数是否有效 bool validateAngleParams(double start, double end, double step) const; }; } // namespace DirectionalModel #endif // SINC_DIRECTIONAL_MODEL_HPP // SincDirectionalModel.cpp #include \"SincDirectionalModel.hpp\" namespace DirectionalModel { SincDirectionalModel::SincDirectionalModel(unsigned int elementCount, double maxGain) { if (!setElementCount(elementCount) || !setMaxGain(maxGain)) { throw std::invalid_argument(\"Invalid constructor parameters\"); } } bool SincDirectionalModel::setElementCount(unsigned int elementCount) { if (elementCount \u003c 1) return false; N_ = elementCount; return true; } bool SincDirectionalModel::setMaxGain(double maxGain) { if (maxGain \u003c= 0) return false; Gmax_ = maxGain; return true; } double SincDirectionalModel::calculateGain(double angle_deg) const { // 转换为弧度 double angle_rad = angle_deg * PI / 180.0; double sin_theta = std::sin(angle_rad); // 处理零角度特殊情况 if (std::abs(sin_theta) \u003c 1e-10) { return Gmax_; } double numerator = std::sin(N_ * PI * sin_theta); double denominator = N_ * PI * sin_theta; return Gmax_ * std::pow(numerator / denominator, 2); } double SincDirectionalModel::calculateGainDB(double angle_deg) const { double gain = calculateGain(angle_deg); // 防止取对数时出错，设置最小值 gain = std::max(gain, 1e-10); return 10.0 * std::log10(gain); } bool SincDirectionalModel::validateAngleParams(double start, double end, double step) const { if (start \u003e= end || step \u003c= 0) return false; if (std::abs(step) \u003e std::abs(end - start)) return false; return true; } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e SincDirectionalModel::generatePattern( double startAngle, double endAngle, double stepSize) const { if (!validateAngleParams(startAngle, endAngle, stepSize)) { throw std::invalid_argument(\"Invalid angle parameters\"); } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e pattern; pattern.reserve(static_cast\u003csize_t\u003e((endAngle - startAngle) / stepSize) + 1); for (double angle = startAngle; angle \u003c= endAngle; angle += stepSize) { pattern.emplace_back(angle, calculateGain(angle)); } return pattern; } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e SincDirectionalModel::generatePatternDB( double startAngle, double endAngle, double stepSize) const { if (!validateAngleParams(startAngle, endAngle, stepSize)) { throw std::invalid_argument(\"Invalid angle parameters\"); } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e pattern; pattern.reserve(static_cast\u003csize_t\u003e((endAngle - startAngle) / stepSize) + 1); for (double angle = startAngle; angle \u003c= endAngle; angle += stepSize) { pattern.emplace_back(angle, calculateGainDB(angle)); } return pattern; } std::pair\u003cdouble, double\u003e SincDirectionalModel::getKeyParameters() const { double mainLobeGainDB = calculateGainDB(0.0); // 查找第一旁瓣 double firstSidelobeLevel = -std::numeric_limits\u003cdouble\u003e::infinity(); double angle = 0.0; bool foundFirstPeak = false; while (angle \u003c= 90.0) { double currentGain = calculateGainDB(angle); double nextGain = calculateGainDB(angle + 0.1); if (currentGain \u003e nextGain \u0026\u0026 foundFirstPeak) { firstSidelobeLevel = currentGain; break; } if (currentGain \u003c nextGain) { foundFirstPeak = true; } angle += 0.1; } return {mainLobeGainDB, firstSidelobeLevel}; } } // namespace DirectionalModel 这个模块提供了以下主要功能：\n类接口设计：\n清晰的构造函数和设置函数 完整的错误检查和异常处理 命名空间封装 核心功能：\ncalculateGain: 计算指定角度的增益 calculateGainDB: 计算分贝形式的增益 generatePattern: 生成方向图数据点 generatePatternDB: 生成分贝形式的方向图数据点 辅助功能：\ngetKeyParameters: 获取主瓣增益和第一旁瓣电平 参数验证和错误处理 使用示例：\n#include \"SincDirectionalModel.hpp\" #include \u003ciostream\u003e int main() { try { // 创建模型实例：8个阵元，最大增益1.0 DirectionalModel::SincDirectionalModel model(8, 1.0); // 计算单点增益 double gain_0deg = model.calculateGainDB(0.0); std::cout \u003c\u003c \"0度增益: \" \u003c\u003c gain_0deg \u003c\u003c \" dB\\n\"; // 生成方向图数据 auto pattern = model.generatePatternDB(-90.0, 90.0, 1.0); // 获取关键参数 auto [mainLobe, sidelobe] = model.getKeyParameters(); std::cout \u003c\u003c \"主瓣增益: \" \u003c\u003c mainLobe \u003c\u003c \" dB\\n\"; std::cout \u003c\u003c \"第一旁瓣电平: \" \u003c\u003c sidelobe \u003c\u003c \" dB\\n\"; } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; return 1; } return 0; } 集成建议：\n将头文件和源文件添加到项目中 包含头文件并使用 DirectionalModel 命名空间 根据需要调用相应的方法 注意处理可能的异常",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "辛格方向图模型",
    "uri": "/em/antenna-pattern/01.%E8%BE%9B%E6%A0%BC%E6%96%B9%E5%90%91%E5%9B%BE%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM \u003e  Antenna Pattern",
    "content": "一、高斯方向图模型 高斯方向图模型是一种基于高斯分布的天线方向图简化模型，适合描述天线辐射方向图中主瓣的形状。其数学表达式如下： $$ G(\\theta) = G_{\\text{max}} \\cdot e^{-k (\\frac{\\theta}{\\theta_{\\text{3dB}}})^2} $$参数说明\n$G(\\theta)$：方向 $\\theta$ 上的天线增益。 $G_{\\text{max}}$：主瓣最大增益，通常在 $\\theta = 0$ 时取值。 $\\theta$：观察方向与天线主轴（通常是主瓣方向）之间的夹角。 $\\theta_{\\text{3dB}}$：3dB 波束宽度，定义为增益下降到最大值的一半时对应的角度宽度。 $k$：控制波束形状的系数，通常与 $\\theta_{\\text{3dB}}$ 有关，常取值为 $k = \\ln 2$，使得 $\\theta = \\theta_{\\text{3dB}}$ 时增益下降到 $G_{\\text{max}} / 2$。 特性\n主瓣集中性：\n高斯方向图模型的主瓣呈对称的高斯分布，随着角度偏离主轴，增益迅速下降。 由于模型忽略了旁瓣的影响，它通常用于关注主瓣方向的应用场景。 简洁性：\n高斯方向图模型通过简化旁瓣和其他次要特性，显著降低了计算复杂度，适合快速仿真计算。 归一化：\n为了便于计算，可以对增益进行归一化，使得 $G(\\theta)$ 的值在主瓣方向取 1。 应用场景\n电子战：快速估计天线主瓣方向的辐射能量分布，用于干扰或抗干扰评估。 雷达和通信：对主瓣方向性较强的天线进行快速仿真。 方向性优化：通过调整 $\\theta_{\\text{3dB}}$ 和 $k$ 参数实现特定的波束宽度和集中性。 如果需要进一步扩展高斯方向图模型以包括旁瓣或其他特性，也可以通过叠加额外分量进行修正。\n高斯方向图模型的改进形式 改进的高斯方向图模型其特点是用高斯分布描述主瓣，同时提供了一个函数形式用于描述主瓣以外的方向图（即旁瓣）：\n主瓣公式 $$ f(\\theta) = \\exp\\left(-k \\theta^2\\right) $$ 主瓣部分是标准的高斯分布形式，其中 $k = \\frac{4 \\ln \\sqrt{2}}{\\theta_b^2}$，由 $\\theta_b$（单程半功率点波束宽度）控制主瓣的宽度。 参数 $k$ 确保在 $\\theta = \\pm \\frac{\\theta_b}{2}$ 时，方向图幅度下降到其峰值的一半（即 3dB 下降点）。 主瓣以外的方向图 $$ f(\\theta) = \\frac{(1 + \\cos \\theta) \\sin(k \\sin(\\theta))}{2k \\sin(\\theta)} $$ 这一部分用于描述主瓣以外（旁瓣）的方向图特性。 $k = \\frac{1.3916}{\\sin(0.5\\theta_b)}$ 是根据波束宽度 $\\theta_b$ 确定的常数。 分母 $\\sin(\\theta)$ 和分子的 $\\sin(k \\sin(\\theta))$ 描述了旁瓣的振荡特性，旁瓣随 $\\theta$ 增加呈周期性变化。 模型分析\n主瓣部分：\n与传统高斯方向图模型相符，用高斯函数来精确描述主瓣方向的辐射分布。 通过参数 $k$ 和 $\\theta_b$ 控制主瓣的宽度和增益衰减速率。 旁瓣部分：\n旁瓣描述使用的是一个分段函数，体现了辐射能量的衰减和分布。 $(1 + \\cos \\theta)$ 项增强了主瓣附近的旁瓣幅度，而 $k$ 的引入确保旁瓣幅度的适当抑制。 是否为高斯方向图模型：\n这个模型主瓣部分严格满足高斯分布，可以视为高斯方向图模型。 增加了旁瓣描述的扩展部分，因此可以认为它是 一种改进的高斯方向图模型，在实际应用中更接近实际天线的辐射特性。 适用场景\n这种模型在需要对主瓣精确建模并同时考虑旁瓣对系统性能影响的场景中非常适用，例如：\n电子战中的方向图干扰仿真。 雷达系统对目标信号主瓣和旁瓣的能量分布分析。 无线通信中的波束形成优化。 二、可视化线上计算器 https://claude.site/artifacts/917d549d-d142-4c69-95dc-7a8e4ad48997\n这个交互式的React组件，可以让用户调整参数并实时查看改进型高斯方向图模型的变化。\n计算器代码：\nimport React, { useState, useCallback, useEffect } from 'react'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { Slider } from '@/components/ui/slider'; import { Label } from '@/components/ui/label'; import { Button } from '@/components/ui/button'; import { Input } from '@/components/ui/input'; import { Switch } from '@/components/ui/switch'; import { Calculator } from 'lucide-react'; const GaussianBeamCalculator = () =\u003e { // 状态管理 const [thetaB, setThetaB] = useState(10); // 波束宽度（度） const [plotRange, setPlotRange] = useState(90); // 绘图范围（度） const [resolution, setResolution] = useState(360); // 数据点数量 const [patternData, setPatternData] = useState([]); // 方向图数据 const [kMain, setKMain] = useState(0); // 主瓣k参数 const [kSide, setKSide] = useState(0); // 旁瓣k参数 const [manualK, setManualK] = useState(false); // 是否手动设置K参数 const [manualKMain, setManualKMain] = useState('0'); // 手动输入的主瓣k参数 const [manualKSide, setManualKSide] = useState('0'); // 手动输入的旁瓣k参数 // 自动计算K参数 const calculateKParameters = useCallback(() =\u003e { const thetaBRad = (thetaB * Math.PI) / 180; const newKMain = (4 * Math.log(Math.sqrt(2))) / (thetaBRad * thetaBRad); const newKSide = 1.3916 / Math.sin(0.5 * thetaBRad); return { kMain: newKMain, kSide: newKSide }; }, [thetaB]); // 更新K参数（考虑手动/自动模式） const updateKParameters = useCallback(() =\u003e { if (manualK) { setKMain(parseFloat(manualKMain) || 0); setKSide(parseFloat(manualKSide) || 0); } else { const { kMain: newKMain, kSide: newKSide } = calculateKParameters(); setKMain(newKMain); setKSide(newKSide); setManualKMain(newKMain.toFixed(4)); setManualKSide(newKSide.toFixed(4)); } }, [manualK, manualKMain, manualKSide, calculateKParameters]); // 计算方向图数据 const calculatePattern = useCallback(() =\u003e { updateKParameters(); const data = []; const step = (2 * plotRange) / (resolution - 1); const currentKMain = manualK ? parseFloat(manualKMain) : kMain; const currentKSide = manualK ? parseFloat(manualKSide) : kSide; for (let theta = -plotRange; theta \u003c= plotRange; theta += step) { const thetaRad = (theta * Math.PI) / 180; const thetaBHalf = thetaB / 2; const isMainLobe = Math.abs(theta) \u003c= thetaBHalf; let amplitude; if (isMainLobe) { amplitude = Math.exp(-currentKMain * thetaRad * thetaRad); } else { if (Math.abs(thetaRad) \u003c 1e-10) { amplitude = 1; } else { amplitude = ((1 + Math.cos(thetaRad)) * Math.sin(currentKSide * Math.sin(thetaRad))) / (2 * currentKSide * Math.sin(thetaRad)); } } const amplitudeDB = 20 * Math.log10(Math.abs(amplitude)); const normalizedDB = Math.max(amplitudeDB, -60); const r = normalizedDB + 60; data.push({ theta, amplitude: normalizedDB, r, x: r * Math.cos(thetaRad), y: r * Math.sin(thetaRad) }); } setPatternData(data); }, [thetaB, plotRange, resolution, kMain, kSide, manualK, manualKMain, manualKSide, updateKParameters]); // 首次加载时计算初始数据 useEffect(() =\u003e { calculatePattern(); }, []); // 处理手动/自动模式切换 const handleModeToggle = (checked) =\u003e { setManualK(checked); if (!checked) { const { kMain: newKMain, kSide: newKSide } = calculateKParameters(); setManualKMain(newKMain.toFixed(4)); setManualKSide(newKSide.toFixed(4)); } }; // 自定义极坐标图组件（与之前相同） const PolarPattern = ({ data }) =\u003e { if (!data || data.length === 0) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } return ( \u003csvg className=\"w-full h-full\" viewBox=\"-70 -70 140 140\"\u003e {/* 绘制同心圆 */} {[0, 15, 30, 45, 60].map((r, i) =\u003e ( \u003ccircle key={i} cx=\"0\" cy=\"0\" r={r} fill=\"none\" stroke=\"#ddd\" strokeWidth=\"0.5\" /\u003e ))} {/* 绘制角度线 */} {[0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330].map((angle) =\u003e { const radians = (angle * Math.PI) / 180; return ( \u003cline key={angle} x1=\"0\" y1=\"0\" x2={60 * Math.cos(radians)} y2={60 * Math.sin(radians)} stroke=\"#ddd\" strokeWidth=\"0.5\" /\u003e ); })} {/* 绘制方向图曲线 */} {data.length \u003e 0 \u0026\u0026 ( \u003cpath d={`M ${data[0].x} ${data[0].y} ` + data.map(p =\u003e `L ${p.x} ${p.y}`).join(' ')} fill=\"none\" stroke=\"#2563eb\" strokeWidth=\"1\" /\u003e )} {/* 添加刻度标签 */} {[0, -20, -40, -60].map((db, i) =\u003e ( \u003ctext key={i} x=\"2\" y={-15 * i - 2} fontSize=\"4\" fill=\"#666\" \u003e {db}dB \u003c/text\u003e ))} {/* 添加角度标签 */} {[0, 90, 180, 270].map((angle) =\u003e { const radians = (angle * Math.PI) / 180; return ( \u003ctext key={angle} x={65 * Math.cos(radians)} y={65 * Math.sin(radians)} fontSize=\"4\" fill=\"#666\" textAnchor=\"middle\" \u003e {angle}° \u003c/text\u003e ); })} \u003c/svg\u003e ); }; return ( \u003cCard className=\"w-full max-w-4xl\"\u003e \u003cCardHeader\u003e \u003cCardTitle\u003e改进型高斯方向图模型计算器\u003c/CardTitle\u003e \u003c/CardHeader\u003e \u003cCardContent className=\"space-y-6\"\u003e \u003cdiv className=\"space-y-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e波束宽度 θb (度)\u003c/Label\u003e \u003cdiv className=\"flex items-center space-x-4\"\u003e \u003cSlider value={[thetaB]} onValueChange={(value) =\u003e setThetaB(value[0])} min={1} max={30} step={0.5} className=\"flex-1\" /\u003e \u003cspan className=\"w-12 text-right\"\u003e{thetaB}°\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e绘图范围 (±度)\u003c/Label\u003e \u003cdiv className=\"flex items-center space-x-4\"\u003e \u003cSlider value={[plotRange]} onValueChange={(value) =\u003e setPlotRange(value[0])} min={30} max={180} step={10} className=\"flex-1\" /\u003e \u003cspan className=\"w-12 text-right\"\u003e±{plotRange}°\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cdiv className=\"flex items-center justify-between\"\u003e \u003cLabel\u003e手动设置K参数\u003c/Label\u003e \u003cSwitch checked={manualK} onCheckedChange={handleModeToggle} /\u003e \u003c/div\u003e {manualK \u0026\u0026 ( \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e主瓣k参数\u003c/Label\u003e \u003cInput type=\"number\" value={manualKMain} onChange={(e) =\u003e setManualKMain(e.target.value)} step=\"0.0001\" /\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e旁瓣k参数\u003c/Label\u003e \u003cInput type=\"number\" value={manualKSide} onChange={(e) =\u003e setManualKSide(e.target.value)} step=\"0.0001\" /\u003e \u003c/div\u003e \u003c/div\u003e )} \u003c/div\u003e \u003cButton onClick={calculatePattern} className=\"w-full\" \u003e \u003cCalculator className=\"mr-2 h-4 w-4\" /\u003e 计算方向图 \u003c/Button\u003e \u003c/div\u003e \u003cdiv className=\"grid grid-cols-1 md:grid-cols-2 gap-4\"\u003e {/* 直角坐标图 */} \u003cdiv className=\"h-96\"\u003e \u003cLabel className=\"mb-2 block\"\u003e直角坐标显示\u003c/Label\u003e \u003cResponsiveContainer width=\"100%\" height=\"100%\"\u003e \u003cLineChart data={patternData}\u003e \u003cCartesianGrid strokeDasharray=\"3 3\" /\u003e \u003cXAxis dataKey=\"theta\" label={{ value: '角度 (度)', position: 'bottom' }} /\u003e \u003cYAxis domain={[-60, 5]} label={{ value: '幅度 (dB)', angle: -90, position: 'left' }} /\u003e \u003cTooltip formatter={(value) =\u003e `${value.toFixed(2)} dB`} labelFormatter={(label) =\u003e `${label}°`} /\u003e \u003cLegend /\u003e \u003cLine type=\"monotone\" dataKey=\"amplitude\" stroke=\"#2563eb\" name=\"方向图\" dot={false} /\u003e \u003c/LineChart\u003e \u003c/ResponsiveContainer\u003e \u003c/div\u003e {/* 极坐标图 */} \u003cdiv className=\"h-96\"\u003e \u003cLabel className=\"mb-2 block\"\u003e极坐标显示\u003c/Label\u003e \u003cdiv className=\"w-full h-full\"\u003e \u003cPolarPattern data={patternData} /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"text-sm space-y-2\"\u003e \u003cp\u003e主瓣k参数: {kMain.toFixed(4)}\u003c/p\u003e \u003cp\u003e旁瓣k参数: {kSide.toFixed(4)}\u003c/p\u003e \u003cp\u003e3dB波束宽度: {thetaB}°\u003c/p\u003e \u003c/div\u003e \u003c/CardContent\u003e \u003c/Card\u003e ); }; export default GaussianBeamCalculator; 这个交互式的高斯方向图模型计算器具有以下特点：\n参数控制：\n波束宽度(θb)滑块：可调范围1°-30° 绘图范围滑块：可调范围±30°到±180° 实时更新的参数显示 可视化功能：\n响应式图表显示 自动缩放的坐标轴 网格线便于读数 鼠标悬停时显示具体数值 Y轴范围限制在-60dB到5dB 计算特性：\n实时计算主瓣和旁瓣参数 自动处理临界值 平滑的曲线显示 显示关键参数值（k参数等） 使用说明：\n拖动滑块来调整波束宽度和显示范围 图表会实时更新显示新的方向图 将鼠标悬停在曲线上可以查看具体数值 底部显示当前的计算参数 这个计算器使用了现代的React组件和hooks，采用了优化的计算方法，可以流畅地进行实时计算和显示。使用了shadcn/ui组件库来提供统一的UI风格。\n主瓣和旁瓣的K参数可以手动输入，同时保持原有的自动计算功能。\nK参数控制模式：\n添加了切换开关，可以在自动计算和手动输入之间切换 在自动模式下，K参数根据波束宽度自动计算 在手动模式下，可以直接输入K参数值 新增输入界面：\n添加了主瓣和旁瓣K参数的输入框 输入框支持高精度数值（步进值为0.0001） 切换到自动模式时会自动填充计算值 计算逻辑优化：\n分离了K参数计算和方向图计算 在手动模式下使用输入的K值 在自动模式下使用计算的K值 用户界面改进：\n清晰的模式切换开关 数值输入框的合理布局 实时显示当前使用的K参数值 使用方法：\n自动模式（默认）：\nK参数根据波束宽度自动计算 调整波束宽度会影响K参数的计算值 手动模式：\n打开\"手动设置K参数\"开关 直接输入想要的主瓣和旁瓣K参数值 点击\"计算方向图\"查看效果 切换模式：\n从自动切换到手动时，保留当前计算的K值 从手动切换到自动时，恢复根据波束宽度计算的K值 需要注意的是：\n波束宽度的选择会影响both主瓣和旁瓣的形状 可以通过调整显示范围来观察不同角度范围的细节 这个工具可以更好地理解和验证改进型高斯方向图模型的特性。\n三、参考代码 Python代码 一个方便测试和验证这个改进型高斯方向图模型的Python代码。代码将包含模型的实现、可视化以及参数测试功能。\nimport numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Slider class GaussianBeamPattern: def __init__(self, theta_b_deg=10): \"\"\" 初始化改进型高斯方向图模型 参数: theta_b_deg: float, 单程半功率点波束宽度(度) \"\"\" self.set_theta_b(theta_b_deg) def set_theta_b(self, theta_b_deg): \"\"\"设置波束宽度并更新相关参数\"\"\" self.theta_b = np.deg2rad(theta_b_deg) # 转换为弧度 # 计算主瓣的k参数 self.k_main = 4 * np.log(np.sqrt(2)) / (self.theta_b**2) # 计算旁瓣的k参数 self.k_side = 1.3916 / np.sin(0.5 * self.theta_b) def main_lobe(self, theta): \"\"\"计算主瓣方向图\"\"\" return np.exp(-self.k_main * theta**2) def side_lobe(self, theta): \"\"\"计算旁瓣方向图\"\"\" # 避免除零错误 small_angles = np.abs(theta) \u003c 1e-10 result = np.zeros_like(theta, dtype=float) # 处理非零角度 non_zero = ~small_angles theta_nz = theta[non_zero] result[non_zero] = (1 + np.cos(theta_nz)) * np.sin(self.k_side * np.sin(theta_nz)) / (2 * self.k_side * np.sin(theta_nz)) # 处理接近零度的情况（使用极限值） result[small_angles] = (1 + 1) * 1 / (2) # lim(x-\u003e0) sin(kx)/x = k return result def pattern(self, theta): \"\"\"计算完整的方向图\"\"\" # 确定主瓣范围（这里取±theta_b/2） is_main_lobe = np.abs(theta) \u003c= self.theta_b/2 # 分别计算主瓣和旁瓣 pattern = np.zeros_like(theta) pattern[is_main_lobe] = self.main_lobe(theta[is_main_lobe]) pattern[~is_main_lobe] = self.side_lobe(theta[~is_main_lobe]) return pattern def plot_beam_pattern(theta_b_deg=10): \"\"\"绘制方向图并添加交互式控件\"\"\" # 创建图形和坐标轴 fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12)) plt.subplots_adjust(bottom=0.25) # 为滑块留出空间 # 初始化模型 beam = GaussianBeamPattern(theta_b_deg) # 计算角度范围和方向图 theta_deg = np.linspace(-90, 90, 1000) theta = np.deg2rad(theta_deg) pattern = beam.pattern(theta) # 在直角坐标系中绘制 line1, = ax1.plot(theta_deg, 20*np.log10(np.abs(pattern)), 'b-', label='方向图') ax1.grid(True) ax1.set_xlabel('角度 (度)') ax1.set_ylabel('相对幅度 (dB)') ax1.set_ylim(-60, 5) ax1.set_title('方向图 (直角坐标)') ax1.legend() # 在极坐标系中绘制 ax2.set_theta_zero_location('N') # 设置0度在正上方 ax2.set_theta_direction(-1) # 设置角度增长方向为顺时针 pattern_db = 20*np.log10(np.abs(pattern)) pattern_db = np.maximum(pattern_db, -60) # 限制最小值为-60dB line2, = ax2.plot(theta, pattern_db, 'b-') ax2.set_title('方向图 (极坐标)') ax2.set_rmin(-60) ax2.set_rmax(0) ax2.grid(True) # 添加波束宽度滑块 ax_slider = plt.axes([0.2, 0.1, 0.6, 0.03]) slider = Slider(ax_slider, '波束宽度 (度)', 1, 30, valinit=theta_b_deg) def update(val): \"\"\"更新方向图\"\"\" beam.set_theta_b(slider.val) pattern = beam.pattern(theta) pattern_db = 20*np.log10(np.abs(pattern)) # 更新直角坐标图 line1.set_ydata(pattern_db) # 更新极坐标图 pattern_db_polar = np.maximum(pattern_db, -60) line2.set_ydata(pattern_db_polar) fig.canvas.draw_idle() slider.on_changed(update) plt.show() if __name__ == \"__main__\": # 测试代码 plot_beam_pattern(10) # 默认波束宽度为10度 这段代码实现了以下功能：\n模型实现：\n创建了GaussianBeamPattern类，完整实现了改进型高斯方向图模型 分别实现了主瓣和旁瓣的计算函数 处理了临界情况（如角度接近0度时的计算） 可视化功能：\n同时提供直角坐标和极坐标两种显示方式 直角坐标显示详细的幅度变化 极坐标显示更直观的方向图特性 坐标轴和网格的合理设置 交互式参数调节：\n添加了波束宽度的滑动条 实时更新方向图显示 范围设置在1-30度之间 其他特性：\ndB显示范围限制在-60dB到5dB 合理的极坐标显示设置（北向为0度，顺时针方向） 完善的注释和文档 使用方法：\n# 直接运行程序 python gaussian_beam_pattern.py # 或者在其他代码中导入使用 from gaussian_beam_pattern import GaussianBeamPattern beam = GaussianBeamPattern(theta_b_deg=10) pattern = beam.pattern(theta) # theta为弧度制的角度数组 你可以通过滑动控制条来改变波束宽度，观察方向图的变化。这对于理解参数变化对方向图形状的影响非常有帮助。\n需要注意的是，代码需要安装以下Python包：\npip install numpy matplotlib C++代码 以下是一个高斯方向图模型的C++代码模块，具有清晰的输入输出，便于嵌入实际应用程序中使用。\n功能说明\n主瓣使用高斯模型：$f(\\theta) = \\exp\\left(-k \\theta^2\\right)$ 旁瓣描述：$f(\\theta) = \\frac{(1 + \\cos \\theta) \\sin(k \\sin(\\theta))}{2k \\sin(\\theta)}$ 输入： $\\theta$（方向角，单位：弧度） $\\theta_b$（单程半功率点波束宽度，单位：弧度） 输出： 天线方向图增益 $f(\\theta)$ C++代码模块\n#include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cstdexcept\u003e // 高斯方向图模型的实现 class GaussianAntennaPattern { public: // 构造函数，传入波束宽度 GaussianAntennaPattern(double theta_b) { if (theta_b \u003c= 0) { throw std::invalid_argument(\"Beamwidth theta_b must be positive.\"); } this-\u003etheta_b = theta_b; this-\u003ek_main = 4 * std::log(std::sqrt(2)) / (theta_b * theta_b); this-\u003ek_side = 1.3916 / std::sin(0.5 * theta_b); } // 获取指定方向角上的增益值 double computeGain(double theta) const { // 主瓣模型 if (std::abs(theta) \u003c= 0.5 * theta_b) { return std::exp(-k_main * theta * theta); } // 旁瓣模型 else { double sin_theta = std::sin(theta); if (std::abs(sin_theta) \u003c 1e-6) { // 避免除零 return 0.0; } return ((1 + std::cos(theta)) * std::sin(k_side * sin_theta)) / (2 * k_side * sin_theta); } } private: double theta_b; // 半功率点波束宽度 double k_main; // 主瓣系数 double k_side; // 旁瓣系数 }; // 测试高斯方向图模型 int main() { try { // 定义波束宽度 double theta_b = 0.5; // 以弧度为单位 GaussianAntennaPattern antennaPattern(theta_b); // 输出不同方向角的增益 std::cout \u003c\u003c \"Theta (radians) | Gain\" \u003c\u003c std::endl; for (double theta = -1.0; theta \u003c= 1.0; theta += 0.1) { double gain = antennaPattern.computeGain(theta); std::cout \u003c\u003c theta \u003c\u003c \" | \" \u003c\u003c gain \u003c\u003c std::endl; } } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; } return 0; } 代码功能解析\n主类 GaussianAntennaPattern：\n构造函数接受波束宽度 $\\theta_b$ 并计算主瓣和旁瓣的系数 $k_{\\text{main}}$ 和 $k_{\\text{side}}$。 computeGain 方法根据 $\\theta$ 判断是主瓣还是旁瓣，并分别计算增益。 输入校验：\n确保 $\\theta_b \u003e 0$。 防止 $\\sin(\\theta) = 0$ 时的除零错误。 示例输出：\n主程序循环计算不同方向角 $\\theta$ 下的增益并打印。 示例输出\n假设 $\\theta_b = 0.5$，方向角 $\\theta$ 从 $-1.0$ 到 $1.0$：\nTheta (radians) | Gain -1.0 | 0.005 -0.9 | 0.010 -0.8 | 0.050 -0.7 | 0.150 -0.6 | 0.400 -0.5 | 0.707 -0.4 | 0.900 ... 适用性\n模块化设计，便于集成到现有代码中。 支持灵活的方向角计算，适合电子战仿真、雷达信号处理等应用。 可扩展性强，能够添加额外特性（如干扰建模、噪声影响等）。 示例使用场景 场景 1：快速计算特定方向的增益 可以将代码改为直接计算某个方向角的增益，而不是循环输出：\nint main() { try { // 定义波束宽度 double theta_b = 0.5; // 单程半功率点波束宽度 GaussianAntennaPattern antennaPattern(theta_b); // 计算某个角度的增益 double theta = 0.3; // 方向角 double gain = antennaPattern.computeGain(theta); std::cout \u003c\u003c \"Gain at theta = \" \u003c\u003c theta \u003c\u003c \" radians: \" \u003c\u003c gain \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; } return 0; } 运行输出：\nGain at theta = 0.3 radians: 0.9798 场景 2：与实际仿真集成 将类 GaussianAntennaPattern 作为模块嵌入到电子战仿真程序中，只需要调用 computeGain 方法传入角度即可获取对应的增益值。例如：\ndouble signalPower = 10.0; // 原始信号功率 double theta = 0.5; // 当前方向角 double gain = antennaPattern.computeGain(theta); double receivedPower = signalPower * gain; // 加权后的接收功率 优化建议\n多线程支持：可以对 computeGain 进行多线程优化，适合批量计算多个方向增益。 文件输入输出：将计算结果写入文件或从文件读取方向角。 图形化输出：将计算结果导出为数据文件，用于可视化方向图。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "高斯方向图模型",
    "uri": "/em/antenna-pattern/02.%E9%AB%98%E6%96%AF%E6%96%B9%E5%90%91%E5%9B%BE%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Log",
    "content": "12 3\n将基于运动基元的A*算法从四旋翼无人机改进适配到固定翼无人机 参考的基于运动基元的四旋翼无人机A*算法：\nhttps://github.com/HKUST-Aerial-Robotics/Fast-Planner/blob/master/fast_planner/path_searching/src/kinodynamic_astar.cpp\n总体思路\n分析四旋翼A*算法的核心部分：了解其状态表示、控制输入、运动模型和运动基元生成方式。\n理解固定翼无人机的动力学特性：明确其状态变量、控制输入、运动学/动力学模型，以及物理和操作限制。\n整合调整：在前两步的基础上，重新定义状态和控制输入，修改运动基元生成方法，调整启发式函数和代价函数，确保算法的合理性和可行性。\n1. 四旋翼A*算法概述 1.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 速度：$\\mathbf{v} = [v_x, v_y, v_z]^T$ 状态向量：$\\mathbf{s} = [\\mathbf{p}, \\mathbf{v}]^T$，共6维。 1.2 控制输入\n加速度：$\\mathbf{a} = [a_x, a_y, a_z]^T$ 控制输入集：在最大加速度范围内进行离散化，生成一系列可能的加速度向量。 1.3 运动模型\n假设加速度在时间段$\\tau$内恒定，使用匀加速运动方程进行状态转移： $$ \\begin{cases} \\mathbf{p}(t+\\tau) = \\mathbf{p}(t) + \\mathbf{v}(t) \\tau + \\frac{1}{2} \\mathbf{a} \\tau^2 \\\\ \\mathbf{v}(t+\\tau) = \\mathbf{v}(t) + \\mathbf{a} \\tau \\end{cases} $$1.4 运动基元生成\n对控制输入$\\mathbf{a}$和持续时间$\\tau$进行离散化，生成一系列可能的运动基元。 在节点扩展时，应用这些运动基元进行状态转移，生成新节点。 2. 固定翼无人机动力学特性 2.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 航向角：$\\chi$（水平面内的方向） 俯仰角（航迹角）：$\\gamma$（垂直方向的角度） 速度大小：$v$（通常假设恒定或在一定范围内） 状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$，共5维。 2.2 控制输入\n航向角变化率：$\\dot{\\chi}$ 航迹角变化率：$\\dot{\\gamma}$ 控制输入向量：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 2.3 运动学模型\n假设速度$v$恒定，固定翼无人机的运动学方程为：\n$$ \\begin{cases} \\dot{x} = v \\cos \\gamma \\cos \\chi \\\\ \\dot{y} = v \\cos \\gamma \\sin \\chi \\\\ \\dot{z} = v \\sin \\gamma \\\\ \\dot{\\chi} = \\dot{\\chi} \\\\ \\dot{\\gamma} = \\dot{\\gamma} \\end{cases} $$2.4 动力学限制\n最小速度限制：$v_{\\min}$，避免失速。 最大速度限制：$v_{\\max}$ 最大航向角变化率：$|\\dot{\\chi}| \\leq \\dot{\\chi}_{\\max}$ 最大航迹角变化率：$|\\dot{\\gamma}| \\leq \\dot{\\gamma}_{\\max}$ 3. 方案整合与调整 3.1 状态和控制输入的重新定义\n状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$ 控制输入：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 3.2 运动基元的生成\n控制输入离散化：\n航向角变化率 $\\dot{\\chi}$：\n$$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 航迹角变化率 $\\dot{\\gamma}$： $$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 组合控制输入集：\n$$ \\mathcal{U}_D = \\left\\{ (\\dot{\\chi}, \\dot{\\gamma}) \\ \\big| \\ \\dot{\\chi} \\in \\dot{\\chi}_D, \\ \\dot{\\gamma} \\in \\dot{\\gamma}_D \\right\\} $$ 时间步长的确定：设定固定的时间步长$\\tau$，或者根据无人机的速度和环境动态调整。\n状态转移：\n使用数值积分方法（如四阶Runge-Kutta方法）在时间步长$\\tau$内对运动学方程进行积分，计算新状态$\\mathbf{s}(t+\\tau)$。\n状态更新函数：\nvoid stateTransit(const Eigen::VectorXd\u0026 state0, Eigen::VectorXd\u0026 state1, const Eigen::Vector2d\u0026 control_input, double tau) { double v = speed_; // 固定翼无人机的速度 double chi0 = state0(3); double gamma0 = state0(4); double dot_chi = control_input(0); double dot_gamma = control_input(1); // 更新航向角和航迹角 double chi1 = chi0 + dot_chi * tau; double gamma1 = gamma0 + dot_gamma * tau; // 使用平均值近似或数值积分计算位置更新 double avg_chi = (chi0 + chi1) / 2; double avg_gamma = (gamma0 + gamma1) / 2; double x1 = state0(0) + v * cos(avg_gamma) * cos(avg_chi) * tau; double y1 = state0(1) + v * cos(avg_gamma) * sin(avg_chi) * tau; double z1 = state0(2) + v * sin(avg_gamma) * tau; state1.resize(5); state1 \u003c\u003c x1, y1, z1, chi1, gamma1; } 3.3 节点扩展\n扩展函数：\nvoid expandNode(PathNodePtr current_node, std::vector\u003cPathNodePtr\u003e\u0026 successors) { // 获取当前状态 Eigen::VectorXd state0 = current_node-\u003estate; // 遍历所有可能的控制输入 for (const auto\u0026 dot_chi : dot_chi_values) { for (const auto\u0026 dot_gamma : dot_gamma_values) { Eigen::Vector2d control_input(dot_chi, dot_gamma); Eigen::VectorXd state1; // 状态转移 stateTransit(state0, state1, control_input, tau); // 检查速度限制（如果速度可变） // 检查物理可行性，如最小转弯半径 // 碰撞检测 if (!isCollisionFree(state0, state1)) { continue; } // 创建新节点 PathNodePtr new_node = new PathNode(); new_node-\u003estate = state1; new_node-\u003einput = control_input; new_node-\u003eduration = tau; new_node-\u003eparent = current_node; // 计算代价 new_node-\u003eg_score = current_node-\u003eg_score + costFunction(state0, state1, control_input, tau); new_node-\u003ef_score = new_node-\u003eg_score + heuristic(state1); // 加入后继节点列表 successors.push_back(new_node); } } } 3.4 代价函数和启发式函数\n代价函数：考虑航向角和航迹角变化率的代价，以及时间代价。 $$ \\text{Cost} = w_{\\chi} |\\dot{\\chi}| + w_{\\gamma} |\\dot{\\gamma}| + w_t \\tau $$ 启发式函数：使用三维Dubins路径的长度作为启发式估计。\nDubins路径：在已知最小转弯半径的情况下，计算从当前状态到目标状态的最短路径长度。\n启发式函数实现：\ndouble heuristic(const Eigen::VectorXd\u0026 state) { // 计算当前状态到目标状态的Dubins路径长度 double h = computeDubinsPathLength(state, goal_state_, min_turn_radius_); return h; } 3.5 碰撞检测\n离散采样：在状态转移过程中，对轨迹进行离散采样，检查每个采样点是否与障碍物发生碰撞。\n碰撞检测函数：\nbool isCollisionFree(const Eigen::VectorXd\u0026 state0, const Eigen::VectorXd\u0026 state1) { int num_checks = 10; // 采样点数量 for (int i = 1; i \u003c= num_checks; ++i) { double t = (double)i / num_checks * tau; Eigen::VectorXd intermediate_state; stateTransit(state0, intermediate_state, state1.segment(3,2) - state0.segment(3,2), t); Eigen::Vector3d position = intermediate_state.head(3); if (!isPositionValid(position)) { return false; } } return true; } 3.6 节点结构调整\n节点结构：根据新的状态和控制输入，调整节点的定义。\nclass PathNode { public: Eigen::Vector3i index; // 栅格索引 Eigen::VectorXd state; // 状态向量 [x, y, z, chi, gamma] double g_score, f_score; Eigen::Vector2d input; // 控制输入 [dot_chi, dot_gamma] double duration; PathNode* parent; char node_state; // 构造函数和析构函数 }; 3.7 A*算法流程\n搜索主循环：与传统A*算法类似，使用开启集和关闭集管理节点，按照 $f = g + h$ 的代价进行节点扩展和选择。\n算法步骤：\n初始化开启集，将起始节点加入开启集。 当开启集非空时： 从开启集中取出 $f$ 值最小的节点作为当前节点。 如果当前节点达到目标状态（或在容忍范围内），则回溯路径，结束搜索。 将当前节点加入关闭集。 扩展当前节点，生成后继节点。 对于每个后继节点： 如果节点在关闭集中，跳过。 如果节点不在开启集中，或找到更优路径，更新节点信息并加入开启集。 4. 方案可行性分析 4.1 动力学合理性\n重新定义的状态和控制输入符合固定翼无人机的动力学特性。 运动基元的生成考虑了固定翼的物理限制，如最小转弯半径和速度限制。 4.2 算法有效性\n通过使用合适的启发式函数（Dubins路径长度），保证算法的效率和最优性。 在节点扩展时进行碰撞检测，确保路径的可行性和安全性。 4.3 实际应用性\n方案中各部分的实现细节，如状态转移函数、碰撞检测和启发式函数，都可以在实际代码中具体实现。 方案兼顾了计算效率和规划质量，可以适用于实时路径规划。 5. 示例参数设置 速度：$v = 15 \\ \\text{m/s}$\n最大航向角变化率：$\\dot{\\chi}_{\\max} = \\frac{\\pi}{6} \\ \\text{rad/s}$（30度/秒）\n最大航迹角变化率：$\\dot{\\gamma}_{\\max} = \\frac{\\pi}{18} \\ \\text{rad/s}$（10度/秒）\n时间步长：$\\tau = 1 \\ \\text{s}$\n控制输入离散化步长：\n$\\Delta_{\\chi} = \\frac{\\dot{\\chi}_{\\max}}{2}$ $\\Delta_{\\gamma} = \\frac{\\dot{\\gamma}_{\\max}}{2}$ 控制输入集合：\nstd::vector\u003cdouble\u003e dot_chi_values = {-dot_chi_max, -dot_chi_max/2, 0, dot_chi_max/2, dot_chi_max}; std::vector\u003cdouble\u003e dot_gamma_values = {-dot_gamma_max, -dot_gamma_max/2, 0, dot_gamma_max/2, dot_gamma_max}; 代价函数权重：\n$w_{\\chi} = 1.0$ $w_{\\gamma} = 1.0$ $w_t = 0.1$ 最小转弯半径：\n$$ R_{\\min} = \\frac{v}{\\dot{\\chi}_{\\max}} $$ 6. 实现注意事项 6.1 数值积分方法\n由于航向角和航迹角在时间内线性变化，可以使用解析积分或简单的数值积分方法。 6.2 速度的可变性\n如果需要考虑速度的变化，可以将速度作为状态变量，并引入油门控制输入。 6.3 启发式函数的一致性\n确保启发式函数不超过实际代价，保持算法的可完备性和最优性。 6.4 碰撞检测的精度\n根据环境的复杂程度，调整采样点数量，以在精度和计算效率之间取得平衡。 总结 通过综合以上方案，我们成功地将基于四旋翼运动基元的A*算法调整为适用于固定翼无人机的版本。关键的调整在于：\n重新定义状态和控制输入：符合固定翼无人机的动力学特性。\n修改运动基元生成方式：基于固定翼的运动学模型，生成物理可行的运动基元。\n调整代价函数和启发式函数：考虑固定翼的运动特性，使用Dubins路径作为启发式估计。\n确保算法的可行性和有效性：通过碰撞检测和合理的参数设置，生成安全可行的路径。\n该方案兼顾了理论合理性和实际可行性，可用于固定翼无人机的路径规划，实现自主导航和避障功能。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "基于运动基元的A*算法",
    "uri": "/log/page1/index.html"
  }
]
