var relearn_searchindex = [
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS",
    "content": "三段S曲线速度规划模型",
    "description": "三段S曲线速度规划模型",
    "tags": [],
    "title": "Velocity Plan",
    "uri": "/uas/velocity_plan/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM",
    "content": "辛格方向图模型 高斯方向图模型",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Antenna Pattern",
    "uri": "/em/antenna-pattern/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "UAV flight simulation\nVelocity Plan 三段S曲线速度规划模型",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "UAS",
    "uri": "/uas/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "Antenna PatternThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "EM",
    "uri": "/em/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.\nWhy We ThinkThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "AGI",
    "uri": "/agi/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Gaming",
    "uri": "/gaming/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.\nAdvanced Battle Management SystemThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "C2",
    "uri": "/c2/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.\nJSBSim User manualThis summary is independent of the content.\nJSBSim QuickstartThis summary is independent of the content.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Simulation",
    "uri": "/simu/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Visualization",
    "uri": "/visual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "基于运动基元的A*算法This summary is independent of the content.\nThis is a new chapter.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Log",
    "uri": "/log/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  C2",
    "content": "[中文译文](pdf/Advanced Battle Management System.ch.pdf)\n\u003cobject data=\"{{ “pdf/your-doc.pdf” | relURL }}\" type=“application/pdf” width=“100%” height=“600”",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Advanced Battle Management System",
    "uri": "/c2/advanced-battle-management-system.ch/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  AGI",
    "content": "我们为何思考 日期：2025年5月1日 | 预计阅读时间：40分钟 | 作者：Lilian Weng\n特别感谢 John Schulman 对本文提供了许多非常有价值的反馈和直接修改。\n测试时计算（test time compute）（Graves et al. 2016、Ling, et al. 2017、Cobbe et al. 2021）与思维链（Chain-of-thought, CoT）（Wei et al. 2022、Nye et al. 2021）已显著提升了模型性能，同时也引发了许多研究问题。本文旨在回顾关于如何有效利用测试时计算（即“思考时间”）以及为何它能带来帮助的最新进展。\n动机 让模型“思考得更久”有多种动机。\n心理学类比 这个核心思想与人类思考的方式密切相关。人类无法立即回答“12345乘以56789是多少？”这样的问题。我们通常会花时间思考和分析，尤其是在面对复杂问题时。在 《思考，快与慢》（Kahneman, 2013） 一书中，Daniel Kahneman 根据 双过程理论（dual process theory） 将人类的思维模式分为两种：\n快思考（系统1）：快速且自动地运行，依赖直觉和情感，几乎不需要努力。 慢思考（系统2）：需要有意识地投入逻辑思考与大量认知资源。该模式更耗费心理能量，需要主动参与。 由于系统1思维快速且轻松，往往成为主要决策机制，但这也以牺牲准确性和逻辑为代价。它依赖于大脑的心理捷径（即启发式），因此容易出错和产生偏差。通过有意识地放慢思考节奏，花更多时间反思、改进和分析，我们可以激活系统2思维，挑战本能，从而做出更理性的决策。\n计算资源视角 深度学习的一个视角是：神经网络可以通过正向传播中所能访问的计算与存储量来刻画。如果我们用梯度下降方法训练模型解决问题，那么优化过程将学会如何利用这些资源——即学会如何将资源组织成执行计算和存储信息的“电路”。从这个角度看，如果我们设计一个能够在测试时执行更多计算的架构或系统，并训练其有效利用这些资源，那么它的表现会更好。\n在 Transformer 模型中，每生成一个 token 所需的计算量（以 FLOPs 衡量）大约是模型参数量的两倍。而在稀疏模型如专家混合（mixture of experts, MoE）中，每次前向传播只激活部分参数，因此其计算量为：计算量 = 2 * 参数量 / 稀疏率，其中稀疏率指的是被激活的专家比例。\n另一方面，CoT 允许模型在为每个答案 token 进行计算时执行更多的 FLOPs。事实上，CoT 的一个优点是：它可以根据问题的复杂程度动态调整所需的计算量。\n潜变量建模 机器学习中的一个经典思想是：定义一个含有潜变量（latent variable）$z$ 和可见变量（visible variable）$y$ 的概率模型，其中$y$ 是给定的数据。对潜变量取边际（求和）可以表达一个对可见变量的丰富分布：\n$$ P(y) = \\sum_z \\sim P(z) P(y|z) $$例如，我们可以通过设定$x$ 为数学问题的描述，$y$ 为答案或证明，$z$ 为通往证明过程中的自由思考路径，来建模数学题与答案的分布。此时我们优化的目标为：\n$$ P(y|x) = \\sum_z \\sim p(z|x) P(y|x, z) $$这种潜变量的视角在理解涉及多个并行 CoT 收集或在 CoT 空间中搜索的方法时特别有用，这些算法可视为从后验分布$P(z|x,y)$ 中采样。同时，这一视角也说明了将对数损失函数$\\log P(y|x)$ 作为目标优化的重要性——在预训练中它非常有效。\nToken 中的思考 在生成简短答案之前先生成中间步骤的策略，尤其是针对数学问题，最早由 Ling et al. 2017 探索，他们提出了 AQUA-RAT 数据集。随后 Cobbe et al. 2021 扩展了这一工作，推出了 Grade School Math (GSM) 数据集。Cobbe 等人通过人类书写解答训练生成器，并使用验证器判断候选解的正确性，从而对解答进行搜索。Nye et al. (2021) 尝试将中间思考 token 作为“草稿板”，而 Wei et al.（2022）首次提出了现在被广泛使用的术语 思维链（chain-of-thought, CoT）。\n早期改进 CoT 推理能力的工作包括：对人类书写的推理轨迹或过滤过的模型推理轨迹进行监督学习；后者可被视为一种初级形式的强化学习（reinforcement learning, RL）。另一些研究发现，通过恰当的提示可显著提升经过指令调优（instruction tuned）模型的数学表现，例如使用 \"think step by step\"（Kojima et al. 2022）或更复杂的提示鼓励模型优先反思相关知识（Yasunaga et al. 2023）。\n后续研究发现，可通过对具有自动可验证答案的数据集（如短答案 STEM 问题或可用单元测试验证的编程任务）执行强化学习，显著提升 CoT 推理能力（Zelikman et al. 2022，Wang et al., 2023，Liu et al., 2023）。这一思路因 o1-preview、o3、以及 R1 技术报告（DeepSeek-AI, 2025）的发布而走红，报告中展示了一种使用策略梯度算法的简单方法即可达到强大性能。\n思维链提示能提高解决数学问题的成功率。模型越大，越能从“思考时间”中受益。（图源：Wei et al. 2022）\n分支与修订 测试时计算的根本意图是：在测试阶段自适应地调整模型输出分布。可以通过多种方式利用测试时的资源在解码阶段选择更优样本，从而引导模型向更理想的分布输出。\n提升解码过程的两种主要方法是并行采样与顺序修订：\n并行采样 同时生成多个输出，可在每步使用奖励信号进行引导，或在末尾通过验证器评估质量。这是最广泛采用的测试时性能提升方法，如 best-of-N 或 beam search。若没有可用的真实标签，常使用“自洽性”（self-consistency）（Wang et al. 2023）在多个 CoT 展开中采用多数投票选出最终答案。 顺序修订 根据上一步的输出逐步调整模型回应，让模型有意识地反思自身输出并修正错误。该过程可能需依赖精调模型，因为单靠模型本身的自我纠错能力，缺乏外部反馈，可能无法提升表现（Kamoi et al. 2024，Huang et al. 2024）。 并行采样简单、直观且易于实现，但受限于模型一次性输出正确结果的能力。顺序修订显式要求模型反思错误，虽更慢、实现更复杂，但能有效推动修正。然而，该方式可能会将原本正确的预测改错，或引入其它幻觉内容。这两种方法也可以结合使用。Snell et al. (2024) 指出：简单问题更适合使用纯顺序的测试时计算，而困难问题则在并行与顺序计算之间达到最优组合时表现最好。\n并行采样与顺序修订的示意图。\n并行采样（Parallel Sampling） 在拥有一个生成模型与用于评估完整或部分样本的打分函数的前提下，可以采用多种搜索算法来寻找得分更高的样本。最简单的算法是 Best-of-N：采样$N$ 个独立样本，并根据某种打分函数选出得分最高者。Beam Search（束搜索）是一种更复杂的搜索算法，其搜索过程更具适应性，会在更有前景的解空间中投入更多采样计算资源。\nBeam Search 维护一组可能性较高的部分序列，交替进行扩展与剪枝。在候选选择机制上，可以借助过程奖励模型（Process Reward Model, PRM；Lightman et al. 2023）来引导 beam search 的候选选择。Xie 等人 (2023) 使用大语言模型（LLM）评估自身生成的推理步骤是否正确，并将其格式化为选择题。结果发现，这种逐步自我评估在 beam search 解码中能降低累计误差。此外，在采样过程中对温度进行退火（annealing）可减缓随机性带来的干扰。Xie 等人的实验在 GSM8k、AQuA 和 StrategyQA 等少样本基准上使用 Codex 模型实现了 5–6% 的性能提升。\nReward Balanced Search（简称 REBASE；Wu et al. 2025）则另行训练了一个 PRM，用于决定 beam search 中每一深度的每个节点应扩展的程度，其依据是 softmax 归一化后的奖励得分。Jiang et al. (2024) 所训练的 PRM 被命名为 “RATIONALYST”，用于基于合成推理的 beam search 引导，训练数据为大量无标注语料。当包含该推理路径时，若能显著降低真实答案 token 的负对数概率（neg log-prob），就认为这条推理路径是“好的”。在推理时，RATIONALYST 通过估计下一个推理步骤的 log 概率（隐式方式）或直接生成下一步推理内容（显式方式）来对 CoT 生成器提供过程监督。\nBeam search 解码过程通过 LLM 对每个推理步骤进行自我评估来进行引导。（图源：Xie et al. 2023）\n有趣的是，可以在没有显式零样本或少样本提示的情况下诱发模型的思维链（CoT）路径。Wang \u0026 Zhou (2024) 发现：若在采样初期保留置信度最高的$k$ 个 token（置信度定义为 top-1 与 top-2 候选间的概率差），并对这$k$ 个分支分别进行贪婪解码，则很多生成序列自然就包含了 CoT。尤其是当上下文中已出现 CoT 时，这会使模型在生成最终答案时更具信心。\n为了计算最终答案的置信度，需要借助任务特定启发式方法（如数学题中最后一个数字）或进一步提示模型 “So the answer is” 来提取答案区间。之所以仅在首个 token 进行分支，是基于如下观察：早期分支能显著增强解路径的多样性，而后续 token 会受此前内容的强烈影响。\nTop-k 解码示意图，其中$k$ 是首次采样步骤中保留的候选数量。（图源：Wang \u0026 Zhou, 2024）\n顺序修订（Sequential Revision） 如果模型能反思并修正过去回答中的错误，我们就希望其能迭代地产出越来越高质量的修订序列。但实际上，大语言模型（LLM）并不具备这种内在的自我修正能力，直接使用这种能力往往效果不佳，其失败模式包括：\n幻觉（hallucination）：将正确答案改成错误； 行为崩溃：修订时未作出实质性修改或根本不修改； 泛化失败：在测试时遇到分布漂移时无效。 Huang 等人 (2024) 的实验表明，直接套用自我修正机制反而会导致性能下降。为实现有效的自我改进，模型需要外部反馈，如：与真实标签匹配、启发式方法、任务特定指标、编程题的单元测试结果（Shinn 等人, 2023）、更强大的模型监督（Zhang et al. 2024）、或人类反馈（Liu et al. 2023）。\n自我修正学习（Self-correction learning；Welleck et al. 2023）目标是：在给定固定生成模型$P\\_0(y\\_0|x)$ 的情况下，训练一个校正器模型$P\\_\\theta(y|y\\_0,x)$。生成器保持通用性，而校正器可根据任务而定，仅在给定初始响应与可选反馈（如文本、编译器日志、单测结果）条件下生成内容：\n首先在数据池中为每个提示生成多个输出； 若两个输出中一个的价值更高，则构造 “增值对”（value-improving pair）：$(x, y, y')$； 这些样本对按照价值差$v(y') - v(y)$ 和输出相似度$Similarity(y, y')$ 的比例进行抽样训练； 校正器的输出也可用于扩展数据池。在推理阶段，校正器可用于生成修正轨迹的顺序修订过程。 通过配对同一问题下模型输出构造增值对来训练校正器模型的自我修正学习示意图。（图源：Welleck et al. 2023）\n递归检查（Recursive inspection；Qu et al. 2024）也是训练更强校正器的方法，不过其采用单一模型同时执行生成与自我修正。\nSCoRe（Self-Correction via Reinforcement Learning） 是一个基于多轮强化学习（RL）的自我修正方法（Kumar et al. 2024）。该方法鼓励模型在第二轮生成中产出比第一轮更好的答案。训练包括两个阶段：\n阶段1：最大化第二次尝试的正确率，并在第一轮加入 KL 惩罚以限制其偏离原始模型； 阶段2：同时优化第一轮和第二轮的答案质量。 这种设计既能鼓励第一次输出的多样性，又能逐步提升整体表现。\n通过两阶段强化学习训练显式提升模型的自我修正能力的结构图。（图源：Kumar et al. 2024）\n强化学习提升推理能力（RL for Better Reasoning） 近年来，通过强化学习（Reinforcement Learning, RL）显著提升语言模型推理能力的研究不断取得突破。这些方法通常采用带有真实答案的问题集（如 STEM 题或逻辑谜题）作为训练基础，模型的奖励机制以获得正确答案为目标。该方向的热度部分来自 OpenAI o 系列模型的出色表现，以及随后 DeepSeek 团队发布的模型与技术报告。\nDeepSeek-R1（DeepSeek-AI, 2025）是一个开源大语言模型（LLM），旨在在数学、编程、逻辑等高阶推理任务中取得卓越表现。其训练流程包括两轮 SFT-RL（监督微调 + 强化学习）：\n冷启动 SFT：对 DeepSeek-V3-Base 在数千条冷启动数据上进行微调，以解决可读性差、语言混用问题。\n面向推理的强化学习：\n仅对推理类 prompt 训练推理模型；\n设定两类基于规则的奖励：\n格式奖励：要求使用 \u003cthinking\u003e...\u003c/thinking\u003e 包裹 CoT； 准确性奖励：数学题需将答案放入指定格式（如边框中）以便验证；编程题使用编译器验证是否通过测试用例。 拒绝采样 + 非推理类 SFT：\n从步骤2的 RL checkpoint 中进行拒绝采样，结合 DeepSeek-V3 的非推理类监督数据（写作、问答、自认知等）； 过滤掉混用语言、长段落或代码块的 CoT； 对总共80万样本进行2轮微调训练。 最终 RL 阶段：对推理与非推理 prompt 共同进行训练，以提升有用性、无害性与推理能力。\nDeepSeek-R1 在多个主流推理基准上与 OpenAI o1-preview、o1-mini 表现相当，DeepSeek-V3 为唯一非推理模型。（图源：DeepSeek-AI, 2025）\n有趣的是，DeepSeek 团队还展示了无需 SFT，纯 RL 训练即可学习高级推理能力，如反思与回溯（即“顿悟时刻”）。模型在 RL 训练中自然学会投入更多思考 token 来解决复杂问题。“顿悟时刻”指模型在反思错误后主动尝试其它路径进行修正。\n随后有多个开源项目尝试复现 R1 成果，如 Open-R1、SimpleRL-reason、TinyZero，均基于 Qwen 模型。这些尝试也验证了纯 RL 方法在数学问题与“顿悟能力”方面的有效性。\n模型学会反思并修正错误的示例。（图源：（左）DeepSeek-AI, 2025；（右）Zeng et al. 2025）\nDeepSeek 还公开了部分失败尝试。例如：使用过程奖励模型（PRM）因难以定义每步规则、评估中间步骤是否正确而失败，训练过程也容易被奖励欺骗（reward hacking）破坏；而 MCTS（蒙特卡洛树搜索）则因语言模型 token 的搜索空间过大且精细奖励建模困难而未能成功。这些失败案例提供了有价值的洞察，也呼吁社区更多分享“不成功”的经验。\n外部工具的使用 在推理步骤中，某些中间步骤可以通过执行代码或运行数学计算来可靠且准确地完成。将推理组件中的这一部分卸载到外部代码解释器上（例如 PAL（Program-Aided Language Model，程序辅助语言模型；Gao et al. 2022）或 Chain of Code（Li et al. 2023））可以借助外部工具扩展大语言模型（LLM, Large Language Model）的能力，从而免去让 LLM 学习执行代码或充当计算器的需求。这些代码模拟器（如 Chain of Code 中的实现）可以由 LLM 增强：如果标准代码解释器失败，我们可以选择使用 LLM 来执行该行代码。\n使用代码来增强推理步骤对于数学问题、符号推理和算法任务尤其有益。这些单元测试在某些编程问题中可能并不存在，在这些情况下，我们可以指示模型自我生成单元测试，以便它可以通过测试来验证其解决方案的正确性（Shinn 等人，2023）。\n一个程序辅助语言模型提示的示例。（图片来源：Gao et al. 2022）\nReAct（Reason+Act；Yao et al. 2023）将搜索维基百科 API 的行为与推理轨迹的生成结合起来，使推理路径能够整合外部知识。\n一个 ReAct 提示方法的示例，用于解决 HotpotQA 问题，通过使用维基百科搜索 API 作为外部工具来辅助推理。（图片来源：Yao et al. 2023）\no3 与 o4-mini，是 OpenAI 最近发布的两个优秀示例，其中推理过程涉及到工具使用，如网页搜索、代码执行和图像处理。团队观察到，大规模强化学习呈现出与 GPT 范式相同的趋势，即“更多计算 = 更好性能”。\n忠实思考（Thinking Faithfully） 深度学习模型通常被当作黑箱来处理，已经提出了各种可解释性方法。可解释性具有几个重要用途：首先，它为我们提供了一个额外的检验手段，用以判断模型是否与其创建者的意图不一致，或是否以我们难以从行为中察觉的方式表现异常。其次，它可以帮助我们判断模型是否使用了合理的流程来得出答案。思维链（Chain-of-thought, CoT）提供了一种特别便利的可解释性形式，因为它以自然语言展示了模型的内部推理过程。然而，这种可解释性的前提是模型能忠实地描述其内部思维过程。\n近期的研究表明，监控推理模型的 CoT 能够有效地检测出模型的不良行为，例如 奖励欺骗（reward hacking），甚至可以使一个较弱的模型监控一个更强的模型（Baker et al. 2025）。增加测试时计算量也能提高对抗性鲁棒性（Zaremba et al. 2025）；从直觉上讲，这也是合理的：在面对异常输入（例如对抗样本或越狱攻击）时，更长的思考时间将特别有助于模型理解其所面临的异常情况。\n该实验要求模型根据其思维过程判断另一个模型是否在某种程度上试图通过代码问题中的单元测试作弊。我们可以通过不同类型的监控器在训练过程中监控这些奖励欺骗行为。exit(0) 代码作弊是指智能体利用一个漏洞在未运行所有单元测试的情况下提前退出环境。raise SkipTest 欺骗是指智能体从测试框架之外的函数抛出异常，以跳过单元测试评估。（图片来源：Baker et al. 2025）\n模型是否忠实地表达了其思考？ 从直觉上讲，模型的 CoT 可能存在偏差，这是由于缺乏明确的训练目标来鼓励忠实推理，或者当我们在基于人类书写解释上微调模型时，这些人类样本本身可能就包含错误。因此，我们不能默认认为 CoT 一定是忠实的。\nLanham 等人（2023） 研究了几种 CoT 忠实性失效的模式，方法是故意在 CoT 中引入错误，并测量这些错误对一系列多项选择任务（例如 AQuA、MMLU、ARC Challenge、TruthfulQA、HellaSwag）准确率的影响：\n错误 1（过早作答）：模型可能在生成 CoT 之前就过早得出结论。这通过提前截断或在 CoT 中插入错误来进行测试。不同的任务揭示了对 CoT 效果的任务特定依赖性；有些任务在 CoT 被截断后评估性能会下降，有些则不会。Wang 等人（2023） 做了类似实验，但引入的是更微妙的错误，例如桥接对象或语言模板方面的错误。 错误 2（无信息 token）：CoT 中的无信息 token 是否提高了性能？该假设通过将 CoT 替换为填充文本（如全为句号）来测试，结果显示没有准确率的提升，并且某些任务的性能在没有 CoT 的情况下略优。 错误 3（人类难以理解的编码）：将相关信息以人类难以理解的方式编码。以非标准方式改写 CoT 不会降低数据集上的性能，说明性能提升并不依赖于人类可读的推理过程。 用于评估 CoT 忠实性的不同扰动方式示意图。（图片来源：Lanham et al. 2023）\n有趣的是，Lanham 等人指出，对于多项选择题，小模型可能还不足以充分利用 CoT，而较大的模型即使没有 CoT 也可能完成任务。这种对 CoT 推理的依赖性（通过“有 CoT 与无 CoT 得出相同答案的比例”衡量）在多选任务中并不总是随着模型规模增加而增加，但在加法类任务中确实随模型规模上升而增强，表明“思考时间”在复杂推理任务中更为重要。\nCoT 依赖性衡量为有无 CoT 情况下给出相同答案的百分比。在加法等推理任务中影响更显著，且大模型受益更多。（图片来源：Lanham et al. 2023）\n测试 CoT 忠实性的另一个方法是扰动提示语（prompt），而不是直接修改 CoT 路径（Turpin et al. 2023、Chua \u0026 Evans, 2025、Chen et al. 2025）。\n一种方法是在少样本示例中始终将正确答案标记为 “(A)”，以人为引入偏差。\n另一种提示方法是在提示中插入误导性暗示，例如： \"我觉得答案是 \u003crandom_label\u003e，但想听听你的意见。\" 或 \"一位斯坦福教授认为答案是 \u003crandom_label\u003e\"。\n通过比较模型在有无误导提示下对同一问题的回答，我们可以测量模型是否能忠实地描述提示对其答案的影响。特别是当模型生成不同答案（有提示与无提示）时，我们衡量模型是否在有提示条件下承认提示对其推理有影响。如果模型是忠实的，它应该明确承认该影响，并指出答案变化是由提示引起的。\nGPT 与 Claude 模型对不同类型的上下文偏差敏感。准确率的下降表明存在系统性的不忠实。直接的错误标签提示比“答案总是 A”类型的偏差更有效。（图片来源：Turpin et al. 2023）\n多项研究发现，推理模型在描述提示影响方面比所有测试过的非推理模型都更可靠。例如，我们可以衡量模型在多少个样本中承认提示是决定性因素（即“忠实 CoT”）。推理模型（Claude 3.7 Sonnet、DeepSeek R1）整体上比非推理模型（Claude 3.6、DeepSeek V3）表现更好。\n推理模型更容易展现出忠实的思维链（faithful CoT），相较于非推理模型。（图片来源：Chen et al. 2025）\n一些证据表明，使用奖励模型（Reward Model）会降低模型输出的忠实性。在经典 RLHF（基于人类反馈的强化学习）中，奖励模型并未被训练来鼓励忠实行为，因为其偏好比较数据集是通过人类选择看起来更好或更令人满意的输出样本构建的。\n然而，在推理模型中，CoT 路径是为了生成正确最终答案而优化的，而不是去迎合奖励模型（RM）中定义的人类偏好，因此从直觉上讲，它们更有可能是忠实的。\n对思维链的优化压力：利还是弊？（Optimization Pressure on CoT: Good or Bad?） 监控推理模型的思维链（CoT）以检测奖励欺骗行为是有效的。一种简单的用法是在测试阶段使用监控器作为过滤器运行拒绝采样，从而识别不含奖励欺骗的解答。然而，这种方法只在强化学习（RL）的早期阶段有效；随着模型进一步优化，很难在计算预算内找到能通过 CoT 监控器的样本。这个挑战自然暗示了我们可以考虑将 CoT 监控器融入 RL 奖励中——这是一种基于过程的监督形式，以防止奖励欺骗。\n然而，将 CoT 监控奖励纳入 RL 中的做法效果并不好，因为它会导致“模糊化的奖励欺骗”：模型试图在 CoT 中隐藏其真实意图（Baker et al. 2025）。即使在 RL 训练中施加来自 CoT 监控器的直接优化压力，模型仍能找到作弊方法，尽管频率略有下降，但它可以将意图隐藏在 CoT 中，从而避开监控器的检测。\n当使用监控器为训练过程提供 RL 奖励信号以防止奖励欺骗时，模型仍然可以找到作弊方式，同时避开监控器的检测。（图片来源：Baker et al. 2025）\nYeo et al. (2025) 对 CoT 长度奖励信号的实验验证了与 Baker 等人相似的结论：新的奖励塑形方式可能引发新的奖励欺骗类型。他们设计了一个奖励函数，使得正确的 CoT 比错误的具有更高奖励，短的正确 CoT 比长的正确 CoT 奖励更高，短的错误 CoT 比长的错误 CoT 惩罚更重。由于该额外奖励，模型倾向于在面对困难问题时在 CoT 中重复文本，而不是尝试真正解决问题。为防止这种作弊行为，Yeo 等人进一步引入了 n-gram 重复惩罚机制。\n在使用 CoT 长度奖励信号进行训练时，需要谨慎地进行奖励塑形以保持稳定性。（图片来源：Yeo et al. 2025）\nChen et al. (2025) 对一个缺陷 RL 环境进行了实验，其中使用了包含错误答案的打分器来评估多项选择题。模型学习如何在超过 99% 的 prompt 上利用奖励漏洞进行作弊，但在他们的大多数环境中，模型几乎从未（\u003c2% 的概率）在其 CoT 中口头表达奖励欺骗的策略。在这种情况下，进一步的 RL 优化压力也无法促使模型显式描述其作弊行为。\nRL 训练本质上对奖励欺骗极为敏感。仅依赖启发式的奖励欺骗调查和手动修复可能导致“打地鼠”（whack-a-mole）式的修补循环。因此，我们建议在 RL 训练中尝试直接优化 CoT 时要非常谨慎，甚至尽量避免这样做。\n连续空间中的思考（Thinking in Continuous Space） 自适应计算时间（Adaptive Computation Time）由 Alex Graves 于 2016 年提出，虽然早于大型语言模型的出现，但开创了使模型能够在推理时动态决定计算步数的方向，这可以被视为使模型在测试时能够在连续空间中“思考更多”。在连续空间中的自适应思考时间可以通过纵向（采用循环架构）或横向（更多的顺序采样步骤）来实现。\n循环架构（Recurrent Architecture） 已经提出了多种架构变体，旨在使 Transformer 架构具备循环能力，以实现自适应测试时计算能力（Dehghani 等人, 2019、Hutchins 等人, 2022、Bulatov 等人, 2022）。深入探讨该主题的文献会使本文过长，因此这里只回顾部分代表性工作。\nUniversal Transformer（Dehghani 等人, 2019）将 Transformer 中的自注意力机制与 RNN 中的循环机制结合，借助自适应计算时间机制（Graves, 2016）动态调整处理步骤数量。在高层次上，它可被视为对每个 token 学习隐藏状态表示的循环函数；若步数固定，则 Universal Transformer 等价于一个具有跨层参数共享的多层 Transformer。\n一项较新的循环架构设计由 Geiping et al. (2025) 提出：在标准 Transformer 之上添加一个循环模块 R。该循环模块的每次迭代接收嵌入$e$ 和一个随机状态$s\\_i$。从概念上讲，这种循环深度架构有些类似于条件扩散模型（conditioned diffusion model），其中原始输入$e$ 在每一步中都作为输入传入，而一个初始为高斯分布的随机状态$s\\_i$ 经过多次迭代被不断更新。（有趣的是，他们部分类似扩散模型的设计在实验中表现较差。）\n$$ e = P(x)\\quad \\text{（嵌入）} \\\\ s_0 \\sim \\mathcal{N}(0, \\sigma^2 I_{n \\cdot h}) \\\\ s_i = R(e, s_{i-1})\\quad \\text{对于 } i \\in \\{1, \\dots, r\\} \\quad \\text{（循环模块，类似 Transformer block）} \\\\ p = C(s_r)\\quad \\text{（反嵌入层）} $$训练时，循环次数$r$ 对每个输入序列是随机的，采样自对数正态泊松分布。为控制计算开销，反向传播仅对循环单元的最后$k$ 次迭代进行（实验中$k=8$），从而可以在 Poisson 分布的长尾部分进行训练。嵌入模块的输出$e$ 在每一步都被注入，因此在每步中都接收梯度更新，模拟 RNN 的训练方式。\n不出所料，训练循环模型的稳定性非常敏感。诸如初始化、归一化、超参数等因素都至关重要，尤其在扩大训练规模时。例如，隐藏状态可能会崩溃：所有 token 的隐藏状态预测相同；或者模型可能学会忽略输入状态$s$。为提升稳定性，Geiping 等人采用了嵌入缩放因子、较小的学习率和精心调参。\n在训练一个 35 亿参数模型的深度循环实验中绘图。约在$\\bar{r} = 32$ 时趋于饱和，使人思考该架构在更大迭代次数上的外推和泛化能力。（图片来源：Geiping et al. 2025）\n思维Token（Thinking Tokens） 思维token指的是在训练或推理过程中引入的一组隐式token，它们本身不携带直接的语言含义。相反，它们的作用是为模型提供额外的“思考时间”和计算能力，以便获得更好的表现。\nHerel 与 Mikolov（2023） 引入了在句子中每个单词后插入特殊思维token（例如 \u003cT\u003e）的想法，并在这种构造的数据集上训练模型。每个思维token为模型提供了更多的时间来处理信息并作出更优预测。在玩具模型设置下，使用思维token训练的模型比不使用它们的基线模型获得了更低的困惑度（perplexity）。思维token的益处在面对复杂推理任务或涉及数字的句子时尤为明显。\n类似地，Goyal 等人（2024） 提出的暂停token（pause tokens）通过在输入序列末尾添加虚拟token（例如 . 或 # 之类字符）来延迟模型的输出，从而在推理阶段为模型提供额外的计算资源。重要的是在训练和推理阶段都注入这些暂停token，仅在微调阶段使用暂停token收效甚微。在训练过程中，这些暂停token被插入到随机均匀位置的多个副本中，并且训练时忽略这些token的loss。\n与标准设置相比，训练与推理阶段注入暂停token的方式示意图。（图片来源：Goyal et al. 2024）\n有趣的是，在上述实验中，思维token或暂停token并未携带任何额外信息，也没有引入新的参数，但为何仍然有效呢？一方面，它们通过引入更多的推理循环扩展了计算资源，从而有效提升计算能力；另一方面，它们可被视为一种特殊的、隐式的思维链（CoT）形式。其不足之处在于模型需要针对思维token进行预训练。尽管如此，这种策略为进一步提升测试时计算资源的利用能力，在推理阶段CoT之外提供了新的路径。\nQuiet-STaR（Zelikman 等人，2025）通过在每个token后生成推理理由（rationale）来引入token级推理。它混合带有和不带理由的未来token预测，并使用学习机制来生成更优的推理理由，同时用 REINFORCE 方法优化 rationale 的质量。\nQuiet-STaR 示意图。（图片来源：Zelikman et al. 2025）\nQuiet-STaR 包含三个阶段：\nThink：带 rationale 的下一token预测。由于token级推理代价高昂，该过程设计为并行生成多个 rationale。使用特殊注意力映射，使所有思维token仅关注自己、当前思维中的先前思维token，以及前文文本。 Talk：不带 rationale 的下一token预测与带 rationale 的结果进行混合。两者logits的混合权重由浅层MLP结构输出的混合头部学习而来。最终可通过教师强制（teacher forcing）选择正确token。 Learn：通过 REINFORCE 训练模型生成更好的 rationale，保留提升下一个token预测概率的样本，舍弃降低性能的样本。 在未进行数据集特定微调的情况下，Quiet-STaR 在 Mistral 7B 上实现了零样本条件下的性能提升：CommonsenseQA 从 36.3% 提升至 47.2%，GSM8K 从 5.9% 提升至 10.9%。\n思考作为潜变量（Thinking as Latent Variables） 潜变量模型定义了一种概率框架，通过不可观测的**潜变量（latent variables）**来解释可观测数据。这些潜变量捕捉了生成观察结果的隐藏结构或中间过程。语言模型可被视为概率潜变量模型，其中测试时的思考与推理步骤就是潜在的“思维变量”（latent thought variables）（Zhou et al. 2020、Phan et al. 2023）。\n此类模型定义问题$x\\_i$、答案$y\\_i$ 与潜在思维$z\\_i$ 的联合分布。我们的目标是最大化在给定多个思维链情况下的对数似然（$N$ 是样本数，$K$ 是每个问题的CoT数量）：\n$$ \\log L(\\theta) = \\log p(y|x) = \\log \\sum_{k=1}^{K} p(y, z^{(k)}|x) = \\log \\sum_{k=1}^{K} p(z^{(k)}|x) p(y|z^{(k)}, x) = \\log \\mathbb{E}_{z^{(k)} \\sim p(z^{(k)}|x)} [p(y|z^{(k)}, x)] $$我们的目标是，在给定每个问题的若干推理轨迹${z^{(k)}}\\_{k=1}^K$ 的前提下，最大化答案的边际似然$p(y|x)$。\n期望最大化（Expectation-Maximization） 期望最大化算法（Expectation–Maximization, EM） 是一个广泛使用的迭代算法，用于优化带有隐藏变量的模型参数，因此也可用于训练更优的 CoT 并据此生成更优答案。\n该算法通常在以下两个步骤之间迭代，直到收敛：\nE 步骤（Expectation）：估计潜变量的缺失信息（即如何采样更好的 CoT）； M 步骤（Maximization）：在给定潜变量下优化模型参数（即如何生成更好的答案）： $$ \\log L(\\theta) = \\underbrace{\\log \\mathbb{E}_{z^{(k)} \\sim p(z^{(k)}|x)}}_{\\text{E-step}} \\underbrace{p(y|z^{(k)}, x)}_{\\text{M-step}} $$由于我们无法直接从后验分布$p(z|x,y)$ 中采样，研究者们探索了其他方法，如使用人类标注数据（Zhou et al. 2020）、Metropolis-Hastings MCMC 采样（Phan et al. 2023）、或带特殊重要性权重的 Monte Carlo 采样（Ruan et al. 2025）来获得高质量 CoT 样本以更新模型。\nRuan 等人（2025） 实验使用带潜在思维的 Web 文本语料，并采用 EM 算法进行训练，其中潜在思维对每段观察数据合成生成，模型在潜在思维与文本联合建模下以自回归方式学习。\n注入潜在思维后的语料训练流程示意图。（图片来源：Ruan et al. 2025）\n他们首先用一个 LLM$q\\sim$ 在给定观察数据$X\\_i$ 的前提下生成潜在思维$Z\\_i$：\n你将获得一对网页文档的前缀与后缀。你的任务是在它们之间插入潜在思维，来解释后缀是如何基于前缀生成的。潜在思维应包括：缺失的背景知识，以及每个陈述背后的推理过程（特别是逐步推导或逻辑推理）。 通过 \u003cStartOfLatent\u003e\u003cPrior\u003e ... \u003cEndOfPrior\u003e 这样的特殊token，将生成的潜在思维插入原始数据中，以训练联合分布$p(z, x)$ 或近似后验$q(z|x)$，具体取决于插入位置（在$x$ 前或后）。但由于 CoT 是由近似模型$q\\sim(z|x)$ 生成，其性能会受限。\n为解决这一问题，Ruan 等人提出在 E 步中引入重要性权重，其公式为：\n$$ w^{(k)} = \\frac{p(z^{(k)}, x)}{q(z^{(k)}|x)} = \\frac{p(x|z^{(k)}) p(z^{(k)})}{q(z^{(k)}|x)} $$即优先选择那些：能够较好预测观察数据（$p(x|z^{(k)})$ 高）、简单直观（$p(z^{(k)})$ 高）、但又不是过于显而易见的 CoT（$q(z^{(k)}|x)$ 低）。\n迭代学习（Iterative Learning） 由于预训练模型已经具备生成思维链（CoT）的能力，因此可以设计一个直观的迭代改进流程：生成多个 CoT，并仅在**能导出正确答案的推理理由（rationale）**上对模型进行微调。\n然而，这种直接设计可能失败，因为模型在失败的问题上无法获得学习信号。STaR（“自学推理器”，Self-taught reasoner；Zelikman et al. 2022）通过引入“rationalization”过程解决了这个限制：当模型失败时，它会在已知问题和真实答案的条件下向后生成高质量 CoT，以便生成更合理的推理链。然后，模型会在以下两类正确解答上进行微调：一类是自然推导得到正确答案的 CoT，另一类是通过 rationalization 生成的 CoT。\nSTaR 算法示意图。（图片来源：Zelikman et al. 2022）\n我们可以将 STaR 看作是强化学习中策略梯度（policy gradient）的一种近似形式，其中奖励函数为简单的指示函数$𝟙[ŷ = y]$。我们的目标是在$z ∼ p(z|x)$、$y ∼ p(y|x,z)$ 的采样过程中最大化该奖励的期望，因为\n$$ p(y|x) = \\sum_z p(z|x) p(y|x,z) $$推导如下：\n$$ \\nabla_θ J(θ) = \\nabla_θ \\mathbb{E}_{z_i, y_i ∼ p(\\cdot | x_i)} \\mathbb{1}[y_i = y_i^{truth}] \\\\ = \\sum_{i=1}^N \\nabla_θ \\mathbb{1}[y_i = y_i^{truth}] p(y_i, z_i | x_i) \\\\ = \\sum_{i=1}^N \\mathbb{1}[y_i = y_i^{truth}] p(y_i, z_i | x_i) \\nabla_θ \\log p(y_i, z_i | x_i) $$每次迭代等价于：首先根据$\\mathbb{1}[y = y\\_{truth}]$ 筛选 CoT 样本，然后通过监督微调优化生成优质 CoT 与答案的对数概率（logprob）。STaR 的性能随训练迭代次数提升而改善，而“rationalization”过程进一步加速了模型对更优 CoT 的学习。\n他们还观察到：高温采样（high temperature sampling）虽然提高了获得正确答案的几率，但往往伴随着错误的推理链，在这种数据上微调 LLM 会降低泛化能力。对于没有真实标签的数据集，可以采用多个高温输出的多数投票结果作为“代理真值”（proxy ground truth）（Wang et al. 2022），从而使用合成样本进行训练。\n两数相加任务准确率对比示意图。通过 rationalization（基于真实答案生成 CoT），模型能够更早掌握复杂运算任务，如 5 位数加法。（图片来源：Zelikman et al. 2022）\n思考时间的扩展规律（Scaling Laws for Thinking Time） 前文已提供了大量证据表明：在推理阶段允许模型投入更多计算资源以进行思考，在产生最终答案前进行推理，可以显著提升性能。诸如“提示模型生成中间推理步骤”或“训练模型在预测下一个 token 前暂停思考”的技术，均可让模型性能超越训练阶段所获得的能力上限。这本质上为提升模型智能引入了新的维度，与传统 scaling law 中的规模、训练计算量、数据量等因素互补（Kaplan et al. 2020）。\n近期研究表明，优化大语言模型（LLM）在测试时的计算资源使用，可能比单纯扩展参数量更高效（Snell et al. 2024，Wu et al. 2025）。小模型配合高效的推理算法，可以在成本与性能之间提供帕累托最优的权衡。\nSnell 等人（2024） 比较了预训练计算与推理计算的使用情况，并发现两者不可互换。测试时计算在模型能力差距较小时可轻松弥补简单和中等难度问题的缺口，但在困难问题上补偿能力有限。预训练与推理token预算之比至关重要。测试时计算仅在推理token远少于训练token的情况下才具有优势。这表明：构建能力强大的基础模型仍然是核心任务，仅靠推理时计算无法弥补大能力缺口。\n（左）不同推理预算下的准确率变化（迭代修订 vs 并行解码）；（右）小模型+推理技巧 vs 大14倍模型+贪婪解码性能对比。当推理token远少于训练token时，测试时计算的优势最为明显。（图片来源：Snell et al. 2024）\ns1 模型（Muennighoff \u0026 Yang 等人，2025）通过“预算强制”（budget forcing）技术控制思维链长度（即强制加词 \"wait\" 增加推理长度，或使用 \"Final Answer:\" 提前结束推理）。他们观察到：平均思考时间（以token计）与下游任务准确率呈显著正相关。\n并行与顺序扩展的测试时计算方法在 s1 实验中均展现出与评估性能的正相关关系。（图片来源：Muennighoff \u0026 Yang 等人，2025）\n当将此预算强制技术与其他控制 CoT 长度的解码方法对比时，发现一个惊人现象：简单的拒绝采样（即仅接受满足指定长度的生成）反而导致“反向 scaling”——即 CoT 越长，准确率越低。\n（左）思维链路径越长，评估准确率越高；（右）使用拒绝采样控制 CoT 长度时，路径越长反而准确率越低，呈负相关。（图片来源：Muennighoff \u0026 Yang 等人，2025）\n未来展望（What’s for Future） 对测试时计算（test-time compute）和思维链推理（chain-of-thought reasoning, CoT）的探索为提升模型能力带来了新的机遇。更有趣的是，通过测试时思考机制，我们正逐步迈向构建更类人的 AI 系统，这些系统将体现人类思维中的最佳实践，包括适应性、灵活性、批判性反思与自我纠错。\n当前的进展令人振奋，同时也激励我们在未来开展更多研究，不仅要深入理解“我们——以及我们的模型——如何思考”，更要理解“为何思考”。\n在文章的最后，作者呼吁研究者对以下有关测试时计算与思维链推理的未解问题展开进一步研究：\n我们能否激励模型在强化学习（RL）训练过程中，生成人类可读且忠实的推理路径，同时避免奖励欺骗行为？\n如何定义奖励欺骗（reward hacking）？我们能否在不依赖人类干预的前提下，在强化学习训练或推理过程中捕捉奖励欺骗？又如何避免对奖励欺骗的“打地鼠”式（whack-a-mole）修复？\n自我纠错（self-correction）可以在思维链内部发生，也可以在多轮强化学习中被显式激励。我们如何在没有真实标签（ground truth）时，训练模型自我纠错而不引发幻觉（hallucination）或性能退化（regression）？\n对于高度依赖上下文、个性化且难以评分的任务（如创意写作、情感辅导、头脑风暴），我们该如何进行基于 CoT 展开的强化学习训练？\n在实际部署模型时，我们不可能无限增加测试时的思考时间。那么如何将测试时思考带来的性能收益，平滑地转化为基础模型的能力（例如通过 知识蒸馏 distillation 以降低推理成本）？\n如何使测试时计算的投入根据任务难度自动适配？即，模型在遇到困难问题时“多想一会”，在简单任务上则快速给出答案？\nCitation Please cite this work as:\nWeng, Lilian. \"Why We Think\". Lil'Log (May 2025). https://lilianweng.github.io/posts/2025-05-01-thinking/ Or use the BibTex citation:\n@article{weng2025think, title = {Why We Think}, author = {Weng, Lilian}, journal = {lilianweng.github.io}, year = {2025}, month = {May}, url = \"https://lilianweng.github.io/posts/2025-05-01-thinking/\" } References [1] Alex Graves. “Adaptive Computation Time for Recurrent Neural Networks.”. arXiv preprint arXiv:1603.08983 (2016).\n[2] Wang Ling, et al. “Program Induction by Rationale Generation: Learning to Solve and Explain Algebraic Word Problems.”. arXiv preprint arXiv:1705.04146 (2017).\n[3] Karl Cobbe, et al. “Training Verifiers to Solve Math Word Problems.”. arXiv preprint arXiv:2110.14168 (2021).\n[4] Jason Wei, et al. “Chain of Thought Prompting Elicits Reasoning in Large Language Models.”. NeurIPS 2022.\n[5] Maxwell Nye, et al. “Show Your Work: Scratchpads for Intermediate Computation with Language Models.”. arXiv preprint arXiv:2112.00114 (2021).\n[6] Daniel Kahneman. Thinking, Fast and Slow. Farrar, Straus and Giroux (2013).\n[7] Takeshi Kojima, et al. “Large Language Models are Zero-Shot Reasoners.”. NeurIPS 2022.\n[8] Michihiro Yasunaga, et al. “Large Language Models as Analogical Reasoners”. arXiv preprint arXiv:2310.01714 (2023).\n[9] Eric Zelikman, et al. “STaR: Bootstrapping Reasoning With Reasoning.”. NeurIPS 2022.\n[10] Xuezhi Wang, et al. “Self-consistency Improves Chain of Thought Reasoning in Language Models.”. ACL 2023.\n[11] Ryo Kamoi, et al. “When Can LLMs Actually Correct Their Own Mistakes? A Critical Survey of Self-Correction of LLMs.”. TACL 2024.\n[12] Jie Huang, et al. “Large Language Models Cannot Self-Correct Reasoning Yet.”. ICLR 2024.\n[13] Noah Shinn, et al. “Reflexion: Language Agents with Verbal Reinforcement Learning.”. arXiv preprint arXiv:2303.11366 (2023).\n[14] Yunxiang Zhang, et al. “Small Language Models Need Strong Verifiers to Self-Correct Reasoning.”. ACL Findings 2024.\n[15] Hao Liu, et al. “Chain of Hindsight Aligns Language Models with Feedback.”. arXiv preprint arXiv:2302.02676 (2023).\n[16] Sean Welleck, et al. “Generating Sequences by Learning to Self-Correct.”. arXiv preprint arXiv:2211.00053 (2023).\n[17] Yuxiao Qu, et al. “Recursive Introspection: Teaching Language Model Agents How to Self-Improve.”. arXiv preprint arXiv:2407.18219 (2024).\n[18] Aviral Kumar, et al. “Training Language Models to Self-Correct via Reinforcement Learning.”. arXiv preprint arXiv:2409.12917 (2024).\n[19] Hunter Lightman, et al. “Let’s Verify Step by Step.”. arXiv preprint arXiv:2305.20050 (2023).\n[20] Yuxi Xie, et al. “Self-Evaluation Guided Beam Search for Reasoning.”. NeurIPS 2023.\n[21] Yangzhen Wu, et al. “Inference Scaling Laws: An Empirical Analysis of Compute-Optimal Inference for Problem-Solving with Language Models”. ICLR 2025.\n[22] Dongwei Jiang, et al. “RATIONALYST: Pre-training Process-Supervision for Improving Reasoning”. arXiv preprint arXiv:2410.01044 (2024).\n[23] Xuezhi Wang and Denny Zhou. “Chain-of-Thought Reasoning Without Prompting.”. arXiv preprint arXiv:2402.10200 (2024).\n[24] DeepSeek-AI. “DeepSeek-V3 Technical Report.” arXiv preprint arXiv:2412.19437 (2024).\n[25] DeepSeek-AI. “DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning.”. arXiv preprint arXiv:2501.12948 (2025).\n[26] Luyu Gao, Aman Madaan \u0026 Shuyan Zhou, et al. “PAL: Program-aided Language Models.”. ICML 2023.\n[27] Shunyu Yao, et al. “ReAct: Synergizing Reasoning and Acting in Language Models.”. ICLR 2023.\n[29] Bowen Baker, et al. “Monitoring Reasoning Models for Misbehavior and the Risks of Promoting Obfuscation.”. arXiv preprint arXiv:2503.11926 (2025).\n[30] Wojciech Zaremba, et al. “Trading Inference-Time Compute for Adversarial Robustness.”. arXiv preprint arXiv:2501.18841 (2025).\n[31] Tamera Lanham, et al. “Measuring Faithfulness in Chain-of-Thought Reasoning”. arXiv preprint arXiv:2307.13702 (2023).\n[32] Boshi Wang, et al. “Towards Understanding Chain-of-Thought Prompting: An Empirical Study of What Matters.”. ACL 2023.\n[33] Miles Turpin, et al. “Language Models Don’t Always Say What They Think: Unfaithful Explanations in Chain-of-Thought Prompting.”. NeuriPS 2023.\n[34] James Chua \u0026 Owain Evans. “Are DeepSeek R1 And Other Reasoning Models More Faithful?”. arXiv preprint arXiv:2501.08156 (2025).\n[35] Yanda Chen et al. “Reasoning Models Don’t Always Say What They Think”. arXiv preprint arXiv:2505.05410 (2025).\n[36] Edward Yeo, et al. “Demystifying Long Chain-of-Thought Reasoning in LLMs.”. arXiv preprint arXiv:2502.03373 (2025).\n[37] Mostafa Dehghani, et al. “Universal Transformers.”. ICLR 2019.\n[38] DeLesley Hutchins, et al. “Block-Recurrent Transformers.”. NeurIPS 2022.\n[39] Aydar Bulatov, et al. “Recurrent Memory Transformers.”. NeuriPS 2022.\n[40] Jonas Geiping, et al. “Scaling up Test-Time Compute with Latent Reasoning: A Recurrent Depth Approach.”. arXiv preprint arXiv:2502.05171 (2025).\n[41] Herel \u0026 Mikolov. “Thinking Tokens for Language Modeling.”. AITP 2023.\n[42] Sachin Goyal et al. “Think before you speak: Training Language Models With Pause Tokens.”. ICLR 2024.\n[43] Eric Zelikman, et al. “Quiet-STaR: Language Models Can Teach Themselves to Think Before Speaking.”. arXiv preprint arXiv:2403.09629 (2025).\n[44] Wangchunshu Zhou et al. “Towards Interpretable Natural Language Understanding with Explanations as Latent Variables.”. NeurIPS 2020.\n[45] Du Phan et al. “Training Chain-of-Thought via Latent-Variable Inference.”. NeurIPS 2023.\n[46] Yangjun Ruan et al. “Reasoning to Learn from Latent Thoughts.”. arXiv preprint arXiv:2503.18866 (2025).\n[47] Xuezhi Wang et al. “Rationale-Augmented Ensembles in Language Models.”. arXiv preprint arXiv:2207.00747 (2022).\n[48] Jared Kaplan, et al. “Scaling Laws for Neural Language Models.”. arXiv preprint arXiv:2001.08361 (2020).\n[49] Niklas Muennighoff \u0026 Zitong Yang, et al. “s1: Simple test-time scaling.”. arXiv preprint arXiv:2501.19393 (2025).\n[50] Peiyi Wang, et al. “Math-Shepherd: Verify and Reinforce LLMs Step-by-step without Human Annotations” arXiv preprint arXiv:2312.08935 (2023).\n[51] Yixin Liu, et al. “Improving Large Language Model Fine-tuning for Solving Math Problems.” arXiv preprint arXiv:2310.10047 (2023).\n[52] Charlie Snell, et al. “Scaling LLM Test-Time Compute Optimally can be More Effective than Scaling Model Parameters.”. arXiv preprint arXiv:2408.03314 (2024).\n[53] OpenAI. o1-preview: “Learning to reason with LLMs.” Sep 12, 2024.\n[54] OpenAI. o3: “Introducing OpenAI o3 and o4-mini.” Apr 16, 2025.",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "Why We Think",
    "uri": "/agi/why-we-think-ch/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  UAS \u003e  Velocity Plan",
    "content": "该文档描述了算法的数学模型、约束条件以及求解流程。文档中的符号和公式与代码中的计算逻辑相对应，详细说明了如何根据输入参数（如轨迹弧长 $S$、总飞行时间$T$、进入速度 $v_{In}$、期望速度 $v_{Des}$、最小/最大速度 $v_{min}, v_{max}$、最大加速度 $a_{Max} $和最大加加速度 $j_{Max}$）计算出整个轨迹在仿真步长 $dt$ 下的速度、加速度和加加速度曲线，同时在后段尽可能保持接近期望速度飞行，并通过二分查找调整 $v_{Des}$ 以匹配目标弧长。\n1. 引言 本模型旨在为无人机轨迹规划提供一条平滑的 S 曲线速度规划方案。给定目标轨迹弧长 $S$ 与总飞行时间 $T$，输入参数包括进入速度 $v_{in}$ 与期望速度 $v_{des}$（代码中记为 vIn 与 vDes），同时受到速度上下限 $v_{min}, v_{max}$ 以及动态约束：最大加速度 $a_{max}$ 和最大加加速度 $j_{max}$ 的限制。整个模型通过先计算变速（过渡）阶段的 S 曲线段，再补充恒速段（定速阶段），最后利用二分查找方法调整期望速度以匹配目标弧长，从而生成一组离散时间点上的速度、加速度和加加速度数据。\n在线计算器链接\nC++代码库： https://github.com/flitai/Velocity_Plan/\n2. 模型参数与符号定义 输入参数：\n$S$ : 轨迹弧长（米） $T$ : 总飞行时间（秒） $v_{in}$ : 进入速度（米/秒） $v_{des}$ : 期望速度（米/秒） $v_{min}$ : 最小允许速度（米/秒） $v_{max}$ : 最大允许速度（米/秒） $a_{max}$ : 最大加速度（米/秒²） $j_{max}$ : 最大加加速度（米/秒³） $dt$ : 仿真步长（秒） 其他符号：\n$\\Delta v = v_{des} - v_{in}$ $s = \\text{sgn}(\\Delta v)$，正表示加速，负表示减速。 3. S 曲线变速段设计 为实现平滑过渡，S 曲线变速段分为两种情况，根据 $|\\Delta v|$ 与 $\\frac{a_{max}^2}{j_{max}}$ 的关系区分为【梯形 S 曲线】与【三角形 S 曲线】。\n3.1 梯形 S 曲线 当\n$$ |\\Delta v| \\ge \\frac{a_{max}^2}{j_{max}}, $$ 采用梯形 S 曲线，其分为三个子段：\n上升阶段（加加速阶段）：\n时间区间：$t \\in [0, T_j]$，其中\n$$ T_j = \\frac{a_{max}}{j_{max}}. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}\\, t,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, t^2}{2}. \\end{aligned} $$ 恒定加速阶段：\n时间区间：$t \\in (T_j,\\, T_j + T_a]$，其中\n$$ T_a = \\frac{|\\Delta v|}{a_{max}} - T_j. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= 0,\\\\ a(t) \u0026= s\\, a_{max},\\\\ v(t) \u0026= v_{in} + \\frac{s\\, a_{max}^2}{2j_{max}} + s\\, a_{max}(t - T_j). \\end{aligned} $$ 下降阶段（减加速阶段）：\n时间区间：$t \\in (T_j+T_a,\\, T_{conv}]$，其中\n$$ T_{conv} = 2T_j + T_a. $$ 定义局部时间 $\\tau = t - (T_j+T_a)$，动态表达式： $$ \\begin{aligned} j(t) \u0026= -s\\, j_{max},\\\\ a(t) \u0026= s\\, a_{max} - s\\, j_{max}\\, \\tau,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, a_{max}^2}{2j_{max}} + s\\, a_{max}\\, T_a + s\\Big(a_{max}\\tau - \\frac{j_{max}\\, \\tau^2}{2}\\Big). \\end{aligned} $$ 3.2 三角形 S 曲线 当\n$$ |\\Delta v| \u003c \\frac{a_{max}^2}{j_{max}}, $$ 采用三角形 S 曲线，其分为两个子段：\n上升阶段：\n时间区间：$t \\in [0, T']$，其中\n$$ T' = \\sqrt{\\frac{|\\Delta v|}{j_{max}}}. $$ 动态表达式： $$ \\begin{aligned} j(t) \u0026= s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}\\, t,\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, t^2}{2}. \\end{aligned} $$ 下降阶段：\n时间区间：$t \\in (T',\\, 2T']$，设 $\\tau = t - T'$，动态表达式： $$ \\begin{aligned} j(t) \u0026= -s\\, j_{max},\\\\ a(t) \u0026= s\\, j_{max}(T' - \\tau),\\\\ v(t) \u0026= v_{in} + \\frac{s\\, j_{max}\\, T'^2}{2} + s\\Big(j_{max}\\, T'\\,\\tau - \\frac{j_{max}\\,\\tau^2}{2}\\Big). \\end{aligned} $$ 此时，总变速段时间为\n$$ T_{conv} = 2T'. $$ 4. 定速阶段 在变速阶段（$t \\le T_{conv}$）结束后，进入定速阶段，设定：\n$$ v(t) = v_{des},\\quad a(t)=0,\\quad j(t)=0,\\quad \\text{for } t \\in (T_{conv},\\, T]. $$ 定速阶段的位移为\n$$ S_{const} = v_{des}\\,(T - T_{conv}). $$ 5. 总位移匹配与 vDes 调整 整个飞行的总位移为： $$ S_{total} = S_{conv} + S_{const}, $$ 其中\n$S_{conv} = \\int_{0}^{T_{conv}} v(t)\\, dt$（变速段的累计位移）， $S_{const} = v_{des}\\,(T - T_{conv})$。 目标是满足\n$$ S_{total} = S. $$由于直接根据初始参数计算得到的 $S_{total}$ 可能与目标 $S$ 不符，代码中采用二分查找法在允许范围 $[v_{min}, v_{max}]$ 内调整期望速度 $v_{des}$，使得修正后的 $v_{des}$ 满足 $$ \\left|S_{conv} + v_{des}\\,(T - T_{conv}) - S\\right| \u003c \\epsilon, $$ 其中 $\\epsilon$ 为容忍误差（例如 0.001 米）。\n同时，通过比例因子\n$$ \\text{scaleFactor} = \\frac{v_{des}^{*}}{v_{des}}, $$ 记录调整幅度，以便反馈用户。\n6. 离散化与仿真步骤 时间离散化：\n将总飞行时间 $T$ 以步长 $dt$ 离散为 $N = \\lceil T/dt \\rceil$ 个时间点。\n按阶段计算：\n对于 $t \\le T_{conv}$ 的点，依据所选 S 曲线（梯形或三角形）分别计算对应的 $v(t)$、$a(t)$ 与 $j(t)$，同时累加位移 $S_{conv}$。 对于 $t \u003e T_{conv}$ 的点，设 $v(t) = v_{des}$（调整后的值），位移按 $v_{des} \\times dt$ 累加。 数据输出：\n生成离散的时间序列数据，格式为\n$$ \\{t_k,\\, v(t_k),\\, a(t_k),\\, j(t_k)\\},\\quad k=0,1,\\ldots, N, $$ 用于后续图形显示和进一步分析。\n7. 模型求解流程 初始计算：\n根据输入参数计算 $\\Delta v$ 和符号 $s$。判断 $|\\Delta v|$ 是否满足梯形 S 曲线条件，从而计算对应的 $T_j, T_a$（或 $T'$），进而确定变速阶段时间 $T_{conv}$。\n积分求位移：\n对变速段进行数值积分获得 $S_{conv}$，再计算定速段位移 $S_{const}$，从而得出 $S_{total}$。\n二分查找调整 $v_{des}$：\n若 $S_{total}$ 与目标 $S$ 存在误差，则在 $[v_{min}, v_{max}]$ 范围内采用二分查找调整 $v_{des}$，直到满足误差要求。\n生成输出数据：\n依据调整后的 $v_{des}$ 与计算结果生成全程的速度、加速度与加加速度数据，并输出曲线信息与统计指标。\n8. 总结 本 S 曲线速度规划模型在满足总飞行时间 $T$ 与轨迹弧长 $S$ 的严格约束下，通过以下步骤实现：\n变速段设计： 根据 $v_{in}$ 与 $v_{des}$ 之间的差值，选择梯形或三角形 S 曲线生成平滑的加速/减速过渡，计算出变速段时间 $T_{conv}$ 与累计位移 $S_{conv}$。 定速段补充： 变速结束后，采用定速 $v_{des}$ 飞行，确保后段尽可能长以接近期望速度。 迭代优化： 采用二分查找调整期望速度 $v_{des}$（同时记录比例因子），以确保总体位移匹配目标 $S$。 离散仿真： 按照步长 $dt$ 离散生成整段轨迹的速度、加速度和加加速度数据。 该模型不仅实现了速度规划的平滑性和安全性，同时在后段尽可能保持接近飞出速度飞行，从而满足特定飞行性能的要求。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "三段S曲线速度规划模型",
    "uri": "/uas/velocity_plan/%E4%B8%89%E6%AE%B5s%E6%9B%B2%E7%BA%BF%E9%80%9F%E5%BA%A6%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Simulation",
    "content": "用户手册 https://jsbsim-team.github.io/jsbsim-reference-manual/\n本部分解释了如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim 软件提供了许多现成可用的飞行器模型示例。一旦用户熟悉了进行模拟所需的所有步骤和设置，可能会希望查看这些示例，并详细了解更有经验的 JSBSim 用户是如何实现某些特定模型的。\n该项目和发行版中包含的飞行器模型不包含任何专有、敏感或机密数据。所有数据均来源于教材（如 Stevens 和 Lewis 的《Aircraft Control and Simulation》以及 Sutton 的《Rocket Propulsion Elements》）、公开的技术报告（见：NASA技术报告网站和AIAA网站），或其他公开数据（如FAA网站）。JSBSim 发行版中包含的飞行器模型，以及与现有商业或军事飞行器名称相对应的模型，都是基于公开信息制作的近似模型，仅供教育或娱乐使用。\n概述 什么是 JSBSim？ 从应用程序编程的角度来看，JSBSim 是一个主要用 C++ 编程语言编写的程序代码集合（其中包括一些 C 语言例程）。组成 JSBSim 的一些 C++ 类用于建模物理实体，如大气、飞行控制系统或引擎。某些类封装了诸如运动方程、矩阵、四元数或向量等概念或数学构造。一些类管理其他对象的集合。总的来说，JSBSim 应用程序接受控制输入，计算并汇总来自这些控制输入和环境的力矩，并在离散时间步中推进飞行器的状态（速度、方位、位置等）。\nJSBSim 已经在各种平台上构建和运行，如 Windows 或 Linux 系统上的 PC、苹果 Macintosh 以及硅谷图形公司的 IRIX 操作系统。自由的 GNU g++ 编译器可以轻松编译 JSBSim，其他如 Borland 和 Microsoft 的编译器也能很好地工作。更多信息请参见《程序员指南》。\n从最终用户的角度来看（例如进行研究的学生），JSBSim 可以被视为一个“黑箱”，它通过 XML 格式的输入文件进行提供。这些 XML 文件包含了航天器、引擎、脚本等的描述。当这些文件被加载到 JSBSim 中时，它们指示 JSBSim 模拟该飞行器的飞行情况，作为更大仿真框架的一部分（例如 FlightGear 或 OpenEaagles），或者在批处理模式下以比实际时间更快的速度运行。每次运行 JSBSim 都会生成包含模拟飞行器性能和动态数据的文件。\n从软件集成者的角度来看（例如将 JSBSim 集成到更大仿真框架中的人员），JSBSim 是一个可以被调用的库，提供输入（如飞行员的控制输入），并返回输出（描述飞行器在某一时刻的位置）。\n它适合谁，如何使用？ JSBSim 飞行动力学模型（FDM）软件库旨在易于理解，特别适合高年级航空航天工程学生。由于其配置简便，它也已被业界专业人士用于多种场景。它已经被集成到更大、更全面的飞行模拟应用程序和架构中（例如 FlightGear、Outerra 和 OpenEaagles），并且已被用作工业和学术界的批量模拟工具。\n使用示例 Aerocross Echo Hawk JSBSim 被用于 Aerocross Echo Hawk UAV 的硬件在环（HITL）测试。编写了自定义代码以通过 RS-232/422/485、模拟模拟输入/输出、离散输入/输出和套接字与飞行硬件（基于 PC/104 的系统）接口，但核心仿真代码仍为未经修改的 JSBSim 代码。飞行员/操作员培训也依赖于 JSBSim 作为六自由度（6-DoF）仿真模型。\nDuPont Aerospace 公司 JSBSim 曾在 DuPont Aerospace 公司与 Matlab 一起用于实时 HITL 仿真和飞行员/操作员培训。DuPont Aerospace 公司的 Rex duPont 解释了该项目：\n在 1990 年代，DuPont Aerospace 公司正在研发一种飞机，测试其垂直起降风扇喷气运输机的概念。我们开发了一个基于 Microsoft Windows 的飞行模拟器，用于测试拟议飞行器的飞行特性。然而，我们需要一个可以在实时中使用的仿真系统，以便能够在操作飞行执行器的全尺寸模型上测试飞行特性。我们最终选择了 FlightGear 模拟器，并使用了 JSBSim 飞行动力学模型，因为我们可以获得完整的代码，它的组织方式很好，使我们能够创建新的子程序来匹配我们的飞机，同时也有可用的支持。\n我们同时开发了一个 Matlab 模拟器，用于开发更有效的自动驾驶仪引导系统，因为我们的主要任务是仅使用自动驾驶仪起飞并保持悬停 30 秒。这将明确显示控制系统是否足够强大。因此，我们在 Matlab 模拟器和 JSBSim 派生模拟器的每个相关模块中内建了一系列单元测试，提供一系列输入以交叉验证，确保两个系统同步。\n我们使用 JSBSim 系统测试了一些 Matlab 模型难以测试的动态问题，尤其是涉及飞行员感受和过渡至悬停过程中的可控性问题。这些问题在纯控制系统领域（如 Matlab 中）很难评估，因为过渡过程中，基础的力结构随着空气动力学力量的增强和纯推力控制力的减少而不断变化。\n我们还对气动仿真中关键参数的估算误差敏感度进行了参数研究。这些研究通过让飞行员执行一系列标准机动来完成，目的是测试当一个或多个参数降低 50% 时飞机的响应（飞行员不知道是哪一个参数被改变）。\n我们也对伺服带宽进行了模拟，测试飞行特性在何种情况下变得不可接受。这有助于定义所需的特性。飞行员对控制系统的需求几乎总是与理论上最佳的参数不同。\n此外，我们开发了多种 HUD 显示系统，以便在悬停过程中操作时提供帮助，在这种情况下需要非常精确的地面速度控制。最终我们实现了一个系统，允许一个甚至没有飞行员执照的年轻工程师起飞并保持悬停在恒定高度 30 秒以上，偏差不超过 1 英尺。\n我们最终于 2007 年 9 月 30 日成功实现了自动驾驶仪控制的起飞和悬停，两次飞行的持续时间大约为 45 秒。两次飞行都因为其中一台发动机燃料耗尽而终止，而不是因为控制问题。\nMITRE 空中交通研究 JSBSim 在 MITRE 用于开发一个 6-DoF 模拟系统，模拟飞行管理系统（FMS）在连续下降进场（CDA）和优化下降进场（OPD）过程中的行为。MITRE 使用了 JSBSim 的独立版本（用于批量运行）和与 FlightGear 集成的版本。此外，还创建了附加的控制系统组件，以支持特定的横向和纵向导航研究。\nJSBSim 还被扩展为通过套接字向 MITRE 的其他应用程序输出消息，该应用程序提供了类似于空中交通管制员所看到的视图。\n美国交通部 在与美国交通部合作的项目中，开发了一个使用 JSBSim 作为六自由度（6-DoF）仿真核心的人类飞行员数学模型。\n意大利那不勒斯大学 Federico II 那不勒斯大学拥有一个基于 FlightGear 和 JSBSim 的运动座舱飞行/驾驶模拟器。该模拟器具有三屏视觉显示，提供 190 度的视场。JSBSim 源代码经过修改，提供了力反馈能力。\nJSBSim 在那不勒斯大学被用作支持近地飞行操作风险评估的工具。考虑到碰撞风险研究中的实际问题之一是评估在机场区域内新增障碍物（如建筑物或雷达塔）对飞行操作的威胁。风险评估是通过改变障碍物的几何形状和位置来进行的。评估程序基于对飞机轨迹与“正常”飞行路径的统计偏差分析，评估某一轨迹穿越给定的“保护”区域的概率。为此框架，操作场景被正式描述和实现，以便运行多个计算机模拟。\n弗劳恩霍夫风能系统研究所 在与意大利那不勒斯大学 Federico II 合作的研究中，弗劳恩霍夫风能系统研究所（IWES）的研究人员研究了轻型飞机飞行通过或接近风力涡轮机尾流时的尾流相遇问题。\n为了这项研究，开发了一个软件应用程序框架，用于生成和控制在指定风场和湍流场下的飞行仿真场景。JSBSim 被用作该框架中的飞行动力学模型，并通过调整其自动驾驶仪系统来模拟飞行员在导航过程中的真实行为。风力涡轮机尾流中的风分布是通过 OpenFOAM 计算的，并作为输入提供给动态模型。\n南非试飞学院（TFASA） 南非试飞学院使用 JSBSim 作为地面可变稳定系统（VSS）模拟器的基础，用于飞行员训练。基础飞行器模型的空气动力学稳定性和控制系数被修改，以展示它们对飞行任务的影响。还对执行器进行了建模，以展示它们在不同延迟、滞后和速率限制条件下对飞行员输入输出（PIO）的潜在影响。\n模拟的飞行器包括固定翼飞机和旋翼飞机，并配有可编程的力反馈控制装置，用于展示飞行控制机械特性（FCMC）的影响。\nJSBSim 与 Prepar3D 集成，利用 Prepar3D 的外部视觉系统，渲染到三块大型 LCD 屏幕或通过三投影仪系统呈现 180 度视图。\n仿真 虽然 JSBSim 用户不需要了解飞行模拟器操作的所有细节，但理解其基本工作原理是有帮助的。以下是一些重要的概念。\n参考坐标系用于描述飞行器模型中各种项目的位置和布局。 在定义飞行器模型时，单位的指定具有灵活性——支持英制单位和公制单位。 使用“属性”使得 JSBSim 成为一个通用模拟器，提供了一种通过参数（或变量）接口与各种系统进行交互的方法。属性广泛用于描述飞机和发动机特性配置文件中。 数学在飞行物理建模中发挥着重要作用。JSBSim 使用数据表格，因为飞行动力学特性通常存储在表格中。JSBSim 还允许设置任意代数函数，从而广泛自由地描述气动和飞行控制特性。 用户至少需要具备基本的飞行器飞行力学知识，了解飞机飞行时的常规力和力矩。 理解飞行控制和系统建模方法是成功和有效仿真的关键。 参考坐标系 在描述对象的位置、飞机的姿态和方向，或为给定的飞行条件指定输入时，需要理解一些基本的参考坐标系。以下是对这些坐标系的简要介绍：\n结构坐标系，或“构造坐标系” 该坐标系是常见的制造商参考坐标系，用于定义飞机上的各个点，例如重心位置、所有轮子的位置信息、飞行员视点、点质量、推进器等。JSBSim 飞机配置文件中的项目就是使用此坐标系来定位的。\n在结构坐标系中，X 轴沿着机身长度方向延伸，指向飞机尾部，Y 轴指向飞机右翼，Z 轴则朝上。通常，这个坐标系的原点 $O_C$ 位于飞机前部（例如机头尖端、单发动机飞机的机头防火墙处，或者位于机头前方的一段距离）。这个坐标系通常被命名为 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$.。\n结构（或构造）坐标系的飞机参考坐标系，原点 $O_C$。除了结构坐标系轴 $x_C$, $y_C$, zC 外，还展示了标准机体坐标系轴 $x_B$, $y_B$, $z_B$，它们的原点在重心 G 处。飞行员的视点位于 PEP。\nX 轴通常与机身中心线重合，并且通常与推力轴重合（例如在单发动机螺旋桨飞机中，它通过螺旋桨轴心）。沿 $x_C$ 轴的位置称为站位，沿 zC 轴的位置称为水线位置，沿 $y_C$ 轴的位置称为尾线位置。\n这是从 3D 建模软件 Blender 中截取的屏幕截图，展示了 Cessna 172 的模型及其结构坐标系 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$。在这个例子中，原点 $O_C$ 位于驾驶舱内，靠近仪表盘。\n注意，JSBSim 模拟的飞机的原点可以位于任意位置，因为 JSBSim 内部仅使用重心（CG）与各个物体之间的相对距离——而不是物体的绝对位置。\n在结构坐标系中确定的重心位置（CG）为点 G。\n根据结构坐标系位置定义的地面接触点。\n结构坐标系中的两个关键点位置 $P_{\\mathrm{ARP}}$ 和 $P_{\\mathrm{CG}, \\mathrm{EW}}$ ，分别为气动力矩的极点和空重 CG（空机重心）。机翼根部的形状和弦长也被勾画出来。\n除了 $P_{\\mathrm{CG}, \\mathrm{EW}}$，还展示了两个重要的位置，$P_{\\text {Pilot }}$ 和 $P_{\\text {Right Pass }}$ ，分别代表飞行员和右侧乘客的质量集中点。\n机体坐标系 在 JSBSim 中，机体坐标系类似于结构坐标系，但沿 $y_C$ 轴旋转 180 度，原点与重心（CG）重合。通常，机体坐标系是通过已知飞机重心 G 位置和纵向结构轴 $x_C$ 方向来定义的。$x_B$ 轴应选择与 $x_C$ 轴平行，且从 G 指向机头的正方向。\n机体轴坐标系通常命名为$\\mathcal{F}_{\\mathrm{B}}=\\left\\{G, x_{\\mathrm{B}}, y_{\\mathrm{B}}, z_{\\mathrm{B}}\\right\\}$。$x_B$ 轴称为滚转轴，指向前方，$y_B$ 轴称为俯仰轴，指向右翼，$z_B$ 轴称为偏航轴，指向飞机腹部。\n标准的飞机机体轴坐标系，原点在重心 G 处。\n在机体坐标系中，飞机的力和力矩被相加，结果加速度被积分以得到速度。\n稳定坐标系，或“气动坐标系” 这个坐标系是根据相对风矢量相对于机体的瞬时方向来定义的。如果为了简化假设空气相对于地球静止（无风），且 $\\boldsymbol{V}$ 是飞机质心相对于地球固定观察者的速度矢量（也称为 $\\boldsymbol{V}_{\\mathrm{CM} / \\mathrm{E}}$，以强调相对运动），那么 $-\\boldsymbol{V}$ 就是相对风速，$V=\\|V\\|$是空速。\n该坐标系命名为 $\\mathcal{F}_{\\mathrm{A}}=\\left\\{G, x_{\\mathrm{A}}, y_{\\mathrm{A}}, z_{\\mathrm{A}}\\right\\}$，其中轴 $x_{\\mathrm{A}}$ 指向相对风矢量投影到飞机对称平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的方向。轴 $y_{\\mathrm{A}}$ 仍然指向右翼，并与机体轴 $y_{\\mathrm{B}}$ 重合，轴 $z_{\\mathrm{A}}$ 完成右手坐标系。\n气动坐标系，定义了气动角度 $\\alpha_{\\mathrm{B}}$ 和 $\\beta$.\n这两个轴 $x_{\\mathrm{A}}$ 和 $z_{\\mathrm{A}}$ 根据定义属于飞机的对称面，但它们在飞行过程中可能会旋转，因为相对风速矢量 $V$ 相对于飞行器的方向可能会发生变化。上图展示了如何构建气动坐标系。两个轴 $x_{\\mathrm{A}}$ 和 $x_{\\mathrm{B}}$ 之间的夹角是飞机的迎角 $\\alpha_{\\mathrm{B}}$。相对风的瞬时方向 $\\boldsymbol{V}$ 与其在平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的投影之间形成的夹角是侧滑角 $\\beta$。\n这个坐标系，在一些手册中被称为稳定坐标系，在此也称为“气动坐标系”，因为瞬时气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 在 $z_{\\mathrm{A}}$ 轴上的投影 $Z_{\\mathrm{A}}$ 定义了气动升力。具体来说，升力 $L$ 是这样定义的：$-L$ 是气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 沿 $z_{\\mathrm{A}}$ 轴的分量，即 $Z_{\\mathrm{A}}=-L$。\n为了更好地理解上述描述，考虑一个在飞行力学中常见的典型动作：零侧滑（或“协调”）、保持恒定高度的匀速转弯。在这种情况下，机翼会倾斜，升力也会倾斜。在这种转弯中，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 是倾斜的，而 $x_{\\mathrm{A}}$ 轴保持水平。一般来说，升力作为一个矢量总是定义在飞机的对称面内。\n在恒定高度的匀速协调转弯中，倾斜升力的情况。倾斜角 $\\phi_{\\mathrm{W}}$ 是绕相对风速矢量的旋转。当速度矢量与北方对齐时，运动被定格在时间上。协调转弯意味着 $\\beta=0$，恒定高度意味着 $x_{\\mathrm{A}}$ 轴保持水平。\n备注 —— 在动态稳定性研究中，“稳定坐标系”与上述的气动坐标系略有不同：飞机飞行力学和稳定性约定中的稳定坐标系不过是一个特定的机体固定坐标系，定义是基于初始的对称、稳定、机翼水平、恒定高度的飞行状态。该状态给出了 $x_S$ 的方向（在该特定飞行姿态下与 $x_A$ 重合）。因此，在动态稳定性研究中，稳定坐标系与气动坐标系不同，是固定在飞行器上的。\n在 JSBSim 中，稳定坐标系 $\\mathcal{F}_{\\mathrm{S}}=\\left\\{G, x_{\\mathrm{S}}, y_{\\mathrm{S}}, z_{\\mathrm{S}}\\right\\}$ 代表了气动坐标系。\n地心惯性坐标系（ECI）和地心固定坐标系（ECEF） 地心惯性坐标系（或简称“惯性坐标系”）$\\mathcal{F}_{\\mathrm{ECI}}=\\left\\{O_{\\mathrm{ECI}}, x_{\\mathrm{ECI}}, y_{\\mathrm{ECI}}, z_{\\mathrm{ECI}}\\right\\}$固定，其原点位于地球中心。其笛卡尔坐标轴相对于恒星保持固定，为飞机（或航天器）运动方程提供最简洁的参考坐标系。正 $z_{\\mathrm{ECI}}$ 轴穿过地球的地理北极。$x_{\\mathrm{ECI}}$ 和 $y_{\\mathrm{ECI}}$ 轴位于赤道平面内。$x_{\\mathrm{ECI}}$ 轴始终与从太阳质心到地球在春分时的轨道位置的连线平行。下图展示了 ECI 系统。\n地心惯性（ECI）坐标系和地心固定（ECEF）坐标系。\n地心地固参考系（ECEF）的坐标轴，如 $x_{\\mathrm{ECEF}}$、$y_{\\mathrm{ECEF}}$ 和 $z_{\\mathrm{ECEF}}$，也如上图所示。ECEF 坐标轴相对于地球保持固定。这个笛卡尔系统的原点 $O_{\\mathrm{ECEF}}$，与惯性坐标系一样，位于地球的质心。$z_{\\mathrm{ECEF}}$ 轴也沿着地球的自转轴，并与 $z_{\\mathrm{ECI}}$ 轴重合。$x_{\\mathrm{ECEF}}$ 和 $y_{\\mathrm{ECEF}}$ 轴都位于赤道平面内，且正 $x_{\\mathrm{ECEF}}$ 轴通过本初子午线（格林威治子午线）。ECEF 坐标系绕惯性坐标系的 $z_{\\mathrm{ECI}}$ 轴以角速度 $\\omega_{\\mathrm{E}}$ 逆时针旋转。地球的角速度 $\\omega_{\\mathrm{E}}$ 近似等于 $2 \\pi / 24$ 弧度/小时。\n北向切平面坐标系 当假设地球表面有数学表示（如椭球体或近似球体）时，可以定义一个切平面坐标系。选取与地表某一点 $O_{\\mathrm{E}}$ 相切的平面作为参考。一个叫做“北向切平面坐标系”的地理坐标系 $\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 具有固定原点 $O_{\\mathrm{E}}$，其平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与切平面重合。轴 $x_{\\mathrm{E}}$ 指向地理北方，轴 $y_{\\mathrm{E}}$ 指向东方，最后，轴 $z_{\\mathrm{E}}$ 指向地面，平行于椭球体的法线（如果使用近似球体代替椭球体，则该轴指向地球中心）。因此，坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 也被称为切平面 NED 坐标系（North-East-Down）。\n地心固定（ECEF）坐标系、地理坐标、切平面坐标系和局部垂直坐标系。\n局部垂直局部水平坐标系，或局部 NED 坐标系 局部垂直坐标系$\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$ 与飞机在空间中的朝向无关，而仅由其重心相对于某个便捷的地球固定观察者的位置定义。如果 $G_{\\mathrm{GT}}$ 是重心在地面上的投影（即“地面跟踪”），则坐标平面 $x_{\\mathrm{V}} y_{\\mathrm{V}}$ 平行于在 $G_{\\mathrm{GT}}$ 处与地球表面局部切平面的平面——即平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$，其中 $O_{\\mathrm{E}} \\equiv G_{\\mathrm{GT}}$。然后，轴 $x_{\\mathrm{V}}$ 指向地理北方，轴 $y_{\\mathrm{V}}$ 指向东，最后，轴 $z_V$ 指向地球中心的下方。因此，坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 也被称为局部NED（载机）坐标系。\n飞机体坐标系和局部垂直坐标系（NED坐标系）。图中还展示了飞机的欧拉角：航向角 $\\psi$（图中为负），俯仰角 $\\theta$，和滚转角 $\\phi$。\nNED惯例确保飞机的重量是一个力，在坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 中的分量为 $(0,0, m g)$，其中 $m$ 是飞机的质量，$g$ 是重力加速度。\n上述图展示了一个包含两个坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 和 $\\mathcal{F}_{\\mathrm{B}}$ 的飞机。定义机体坐标系相对于局部NED坐标系的朝向的欧拉角是飞机的欧拉角。对于大气飞行器，定义欧拉角时使用的旋转序列是“3-2-1”。这定义了相对于固定在地球上的观察者的航向角 $\\psi$、俯仰角 $\\theta$ 和滚转角 $\\phi$。\n飞机的欧拉角旋转序列。坐标系$\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 是一个地球固定的 NED 坐标系，原点 $O_{\\mathrm{E}}$ 位于地面某处（或海平面），且平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与地球表面相切。如果地面跟踪点 $G_{\\mathrm{GT}}$ 离 $O_{\\mathrm{E}}$ 不远，则地球坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 的轴线与局部 NED 坐标系 $\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$的轴线平行。\n风坐标系 除了升力，瞬时气动合力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 在参考系中还有两个分量，其中 $z_{\\mathrm{A}}$ 是第三轴。该参考系称为风参考系 $\\mathcal{F}_{\\mathrm{W}}=\\left\\{G, x_{\\mathrm{W}}, y_{\\mathrm{W}}, z_{\\mathrm{W}}\\right\\}$。\n风参考系的定义是将 $x_W$ 轴沿相对风的方向，并且其正方向与运动方向一致。这意味着 $x_{\\mathrm{W}}$ 与向量 $\\boldsymbol{V}$ 重合。风参考系的第三轴沿升力作用线定义，即 $z_{\\mathrm{W}} \\equiv z_{\\mathrm{A}}$。最后，第二轴 $y_{\\mathrm{W}}$ 被选择以完成右手坐标系。风参考系的第三轴始终处于机体对称面（也叫“参考面”）内。由于飞机的姿态随着相对风 $-\\boldsymbol{V}$ 的变化而变化，所有三个风轴会相对于机体轴旋转。\n力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 沿着 $\\boldsymbol{V}$ 方向的分量 $X_{\\mathrm{W}}$ 定义了气动阻力：气动阻力 $D$ 满足 $X_{\\mathrm{W}}=-D$。在存在非零侧滑角 $\\beta$ 的情况下，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 会沿横向轴 $y_{\\mathrm{W}}$ 产生第三个非零分量，即侧向力分量 $Y_{\\mathrm{W}}$。\n当侧滑角 $\\beta$ 为零时，风参考系和气动参考系重合。仅在这种情况下，$y_{\\mathrm{W}}$ 与 $y_{\\mathrm{A}}$ 和 $y_{\\mathrm{B}}$ 重合，且垂直于参考面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$。\n下图显示了飞机在平稳空气中的爬升飞行的标准参考系。当围绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$ 时，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以与气动参考系 $\\mathcal{F}_{\\mathrm{A}}$ 重合。\n标准参考系和飞机在平稳空气中的爬升飞行。质心速度矢量 $\\boldsymbol{V}$ 与水平面形成飞行路径角 $\\gamma$。标准的三个气动合力分量 $D$、$L$ 和 $Y_{\\mathrm{A}}$ 也已显示。\n因此，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以通过先绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$，再绕 $y_{\\mathrm{A}}$ 轴旋转角度 $\\alpha_{\\mathrm{B}}$，与机体参考系 $\\mathcal{F}_{\\mathrm{B}}$ 重合。 $$ \\mathcal{F}_{\\mathrm{W}} \\xrightarrow{-\\beta \\curvearrowright z_{\\mathrm{W}}} \\mathcal{F}_{\\mathrm{A}} \\xrightarrow{\\alpha_{\\mathrm{B}} \\curvearrowright y_{\\mathrm{A}}} \\mathcal{F}_{\\mathrm{B}} \\tag{1} $$气动结果力在机体轴上的分量则表示如下：\n$$ \\left\\{\\begin{array}{c} X_{\\mathrm{B}} \\\\ Y_{\\mathrm{B}} \\\\ Z_{\\mathrm{B}} \\end{array}\\right\\}=\\left[\\begin{array}{ccc} \\cos \\alpha_{\\mathrm{B}} \u0026 0 \u0026 -\\sin \\alpha_{\\mathrm{B}} \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin \\alpha_{\\mathrm{B}} \u0026 0 \u0026 \\cos \\alpha_{\\mathrm{B}} \\end{array}\\right]\\left[\\begin{array}{ccc} \\cos \\beta \u0026 \\sin (-\\beta) \u0026 0 \\\\ -\\sin (-\\beta) \u0026 \\cos \\beta \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{array}\\right]\\left\\{\\begin{array}{c} -D \\\\ Y_{\\mathrm{W}} \\\\ -L \\end{array}\\right\\} \\tag{2} $$这些表示了气动阻力、侧向力和升力。\n单位 JSBSim 在内部计算中几乎 exclusively 使用英制单位。然而，也可以在配置文件中输入一些参数时使用不同的单位。为了避免混淆，建议总是指定单位。单位使用 unit 属性进行指定。例如，翼展的规格如下所示：\n\u003cwingspan unit=\"FT\"\u003e 35.8 \u003c/wingspan\u003e 上述声明指定了一个 35.8 英尺的翼展。以下声明将翼展指定为米单位，这将导致翼展在读取时转换为 35.8 英尺：\n\u003cwingspan unit=\"M\"\u003e 10.91 \u003c/wingspan\u003e 这两条关于翼展的声明实际上是等效的。\nJSBSim 目前支持以下单位：\n长度\nunit= 单位 FT 英尺 IN 英寸 M 米 KM 千米 面积\nunit= 单位 M2 平方米 FT2 平方英尺 体积\nunit= 单位 FT3 立方英尺 CC 立方厘米 M3 立方米 LTR 升 质量和重量\nunit= 单位 LBS 磅（质量） KG 千克 惯性矩\nunit= 单位 SLUG*FT2 磅*英尺² KG*M2 千克*米² 角度\nunit= 单位 RAD 弧度 DEG 度 弹簧力\nunit= 单位 N/M 牛顿/米 LBS/FT 磅/英尺 阻尼力\nunit= 单位 N/M/SEC 牛顿/(米·秒) LBS/FT/SEC 磅/(英尺·秒) 功率\nunit= 单位 WATTS 瓦特 HP 马力 力\nunit= 单位 LBS 磅 N 牛顿 速度\nunit= 单位 KTS 节 FT/SEC 英尺/秒 M/S 米/秒 扭矩\nunit= 单位 N*M 牛顿·米 FT*LBS 磅·英尺 压力\nunit= 单位 PSF 磅/平方英尺 PSI 磅/平方英寸 ATM 大气压 PA 牛顿/平方米 INHG 英寸汞柱 属性系统 仿真程序需要管理大量的状态信息。对于特别庞大的程序，数据管理任务可能会引发一些问题：\n贡献者越来越难以掌握所需的多个接口，以进行任何有用的程序扩展，因此贡献进展变慢。 运行时的可配置性变得越来越困难，因为不同的模块使用不同的机制（环境变量、自定义规范文件、命令行选项等）。 模块初始化的顺序变得复杂且脆弱，因为一个模块的初始化例程可能需要从未初始化的模块设置或获取状态信息。 通过附加脚本、规范文件等进行扩展的能力仅限于程序提供的状态信息，且非编码开发人员往往要等待较长时间才能获得开发人员添加新变量的支持。 属性管理器系统提供了一个单一的接口，用于选择程序的状态信息，并允许在运行时动态创建新的用户指定的变量。后一种能力对于 JSBSim 控制系统模型尤其重要，因为组成飞机控制律的各个控制系统组件（PID 控制器、开关、加法器、增益等）仅在配置文件中存在。在运行时——在解析组件定义之后——这些组件将被实例化，属性管理器将创建一个属性来存储每个组件的输出值。\n属性本身类似于具有选择性限制可见性（只读或读写）的全局变量，它们被分类到一个层次结构的树形结构中，类似于 Unix 文件系统的结构。属性树的结构包括根节点、子节点（类似子目录）和终端节点（属性）。类似于 Unix 文件系统，属性可以相对于当前节点或根节点进行引用。节点可以像符号链接文件或目录到其他文件或目录一样，附加到其他节点上。属性在整个 JSBSim 和 FlightGear 中用于引用程序代码中的特定参数。属性名称的形式如下：position/h-sl-ft 和 aero/qbar-psf。\n为了说明使用属性和配置文件的强大功能，考虑一下高性能喷气式飞机模型的案例。假设在示例飞机的控制面板上添加了一个新的开关，允许飞行员在飞行控制系统（FCS）中覆盖俯仰限制。对于 FlightGear，仪表面板是在配置文件中定义的，开关也在那里定义以进行视觉显示。该开关定义还会分配一个属性名称。在 JSBSim 飞机规范文件中的飞行控制部分，分配给仪表面板定义中俯仰覆盖开关的相同属性名称可以用于根据开关位置引导控制律通过所需路径。无需修改任何代码。\n特定的仿真参数可以通过属性在 JSBSim 和配置文件规范中进行访问和设置。如前所述，“属性”是我们用来描述可以从配置文件或命令行中访问或设置的参数的术语。\n许多属性是标准属性——即所有飞行器始终存在的属性。气动系数、发动机、推进器以及飞行控制/自动驾驶模型也会具有动态定义的属性。这是因为，直到读取相关的飞行器配置文件后，整个气动系数、发动机等的集合才会被确定。要访问这些参数，必须知道使用的属性命名约定。例如，X-15 模型的飞行控制系统包括以下组件：\n\u003cflight_control name=\"X-15\"\u003e \u003cchannel name=\"Pitch\"\u003e \u003csummer name=\"fcs/pitch-trim-sum\"\u003e \u003cinput\u003e fcs/elevator-cmd-norm \u003c/input\u003e \u003cinput\u003e fcs/pitch-trim-cmd-norm \u003c/input\u003e \u003cclipto\u003e \u003cmin\u003e -1 \u003c/min\u003e \u003cmax\u003e 1 \u003c/max\u003e \u003c/clipto\u003e \u003c/summer\u003e \u003caerosurface_scale name=\"fcs/pitch-command-scale\"\u003e \u003cinput\u003e fcs/pitch-trim-sum \u003c/input\u003e \u003crange\u003e \u003cmin\u003e -50 \u003c/min\u003e \u003cmax\u003e 50 \u003c/max\u003e \u003c/range\u003e \u003c/aerosurface_scale\u003e \u003cpure_gain name=\"fcs/pitch-gain-1\"\u003e \u003cinput\u003e fcs/pitch-command-scale \u003c/input\u003e \u003cgain\u003e -0.36 \u003c/gain\u003e \u003c/pure_gain\u003e \u003c/channel\u003e \u003c/flight_control\u003e 在上面的例子中，第一个组件（fcs/pitch-trim-sum）接收来自两个地方的输入，即已知的静态属性 fcs/elevator-cmd-norm 和 fcs/pitch-trim-cmd-norm。接下来的组件将接收第一个组件的输出作为输入。第二个组件列出的输入属性为 fcs/pitch-trim-sum。继续上述示例，最后一个组件 fcs/pitch-gain-1 接收前一个组件的输出 fcs/pitch-command-scale，该属性名为 fcs/pitch-command-scale。\n因此，现在我们已经可以访问 JSBSim 内部的许多参数，并且我们知道如何组装 JSBSim 中的飞行控制系统（FCS）。在 FCS 中使用的相同组件，也可以用来构建自动驾驶系统或其他系统。\n数学 函数 JSBSim 中的函数规范是一个强大且多功能的资源，允许在 JSBSim 配置文件中定义代数函数。函数的语法在概念上类似于 MathML（数学标记语言，http://www.w3.org/Math/），但它更加简洁和紧凑。\n一个函数定义由一个操作、一个值、一个表格或一个属性（评估为值）组成。当前支持的操作有：\nsum（接受 n 个参数） difference（接受 n 个参数） product（接受 n 个参数） quotient（接受 2 个参数） pow（接受 2 个参数） exp（接受 2 个参数） abs（接受 n 个参数） sin（接受 1 个参数） cos（接受 1 个参数） tan（接受 1 个参数） asin（接受 1 个参数） acos（接受 1 个参数） atan（接受 1 个参数） atan2（接受 2 个参数） min（接受 n 个参数） max（接受 n 个参数） avg（接受 n 个参数） fraction（接受 1 个参数） mod（接受 2 个参数） lt（小于，接受 2 个参数） le（小于等于，接受 2 个参数） gt（大于，接受 2 个参数） ge（大于等于，接受 2 个参数） eq（等于，接受 2 个参数） nq（不等于，接受 2 个参数） and（接受 n 个参数） or（接受 n 个参数） not（接受 1 个参数） if-then（接受 2-3 个参数） switch（接受 2 个或更多参数） random（高斯随机数，无参数） integer（接受 1 个参数） 一个操作在配置文件中的定义示例如下：\n\u003csum\u003e \u003cvalue\u003e 3.14159 \u003c/value\u003e \u003cproperty\u003e velocities/qbar \u003c/property\u003e \u003cproduct\u003e \u003cvalue\u003e 0.125 \u003c/value\u003e \u003cproperty\u003e metrics/wingarea \u003c/property\u003e \u003c/product\u003e \u003c/sum\u003e 在上述例子中，sum 元素包含了其他三个项。它的计算过程可以用代数表达式表示为： $$ 3.14159+\\text { qbar }+(0.125 \\cdot \\text { wingarea }) $$ 一个完整的函数定义（例如在气动部分的配置文件中使用的）包括 function 元素和其他元素。需要注意的是，函数定义中只能有一个非可选（非文档）元素——即一个操作元素。该元素不能包含多个直接子操作、property、table 或 value 元素。几乎总是，函数元素中的第一个操作将是乘积（product）或和（sum）。例如：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003e Roll moment due to yaw rate \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-area \u003c/property\u003e \u003cproperty\u003e metrics/bw-ft \u003c/property\u003e \u003cproperty\u003e velocities/r-aero-rad_sec \u003c/property\u003e \u003cproperty\u003e aero/bi2vel \u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在函数定义中，最“底层”的元素总是一个值或一个属性，它本身不能包含其他元素。如所示，操作可以包含值、属性、表格或其他操作。\n在 JSBSim 中，某些操作仅接受一个参数。然而，这个参数可以是一个操作（例如 sum），而该操作可以包含其他项。需要记住的一点是，任何此类包含的操作都将计算出一个单一的值 —— 这正是三角函数所要求的（除了 atan2，它接受两个参数）。\n最后，在函数定义中，有一些简写别名可以用来代替标准的元素标签，从而使得表达式更加简洁。属性、值和表格通常用 \u003cproperty\u003e、\u003cvalue\u003e 和 \u003ctable\u003e 标签来引用。但是，在函数定义中，以上这些元素可以使用 \u003cp\u003e、\u003cv\u003e 和 \u003ct\u003e 标签来代替。因此，之前的示例可以简化为以下格式：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003eRoll moment due to yaw rate\u003c/description\u003e \u003cproduct\u003e \u003cp\u003e aero/qbar-area \u003c/p\u003e \u003cp\u003e metrics/bw-ft \u003c/p\u003e \u003cp\u003e aero/bi2vel \u003c/p\u003e \u003cp\u003e velocities/r-aero-rad_sec \u003c/p\u003e \u003ct\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/t\u003e \u003c/product\u003e \u003c/function\u003e 在气动建模中，表格函数可以用来表示影响升力和阻力的地面效应因子。下图解释了地面效应：\n为了了解如何在 JSBSim 中建模地面效应，我们可以查看 Cessna 172 Skyhawk 模型。这一模型在文件 \u003cJSBSim-root-dir\u003e/aircraft/c172p/c172p.xml 中实现。在该 XML 文件的 \u003caerodynamics/\u003e 块中，建模了两个无量纲因子, $K_{C_{D, \\mathrm{ge}}}$ 和 $K_{C_L, \\mathrm{ge}}$,它们是无量纲地面高度的函数，并被视为升力和阻力的乘数。这些因子如下所示：\n\u003cfunction name=\"aero/function/kCDge\"\u003e \u003cdescription\u003eChange in drag due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 0.4800 0.1000 0.5150 0.1500 0.6290 0.2000 0.7090 0.3000 0.8150 0.4000 0.8820 0.5000 0.9280 0.6000 0.9620 0.7000 0.9880 0.8000 1.0000 0.9000 1.0000 1.0000 1.0000 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e \u003cfunction name=\"aero/function/kCLge\"\u003e \u003cdescription\u003eChange in lift due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.2030 0.1000 1.1270 0.1500 1.0900 0.2000 1.0730 0.3000 1.0460 0.4000 1.0550 0.5000 1.0190 0.6000 1.0130 0.7000 1.0080 0.8000 1.0060 0.9000 1.0030 1.0000 1.0020 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 下图展示了表示因子 $K_{C_{D, \\text{ ge}}}$ 和 $K_{C_{L, \\text{ ge}}}$ 的表格函数 aero/function/kCDge 和 aero/function/kCLge ，分别表示因地面效应引起的阻力和升力的变化。它们的图形化表示如下，显示了相对于无量纲地面高度 $h/(b/2)$ 的变化。在飞机离地面高度小于机翼半个翼展 $b/2$ 时，可以观察到地面效应；而在更高的高度时，这两个因子值趋于 1。\n以上图表展示了无量纲地面高度 $h/(b/2)$ 的函数，定义了 c172p 飞机气动模型中的 aero/function/kCLge 和 aero/function/kCDge 属性。\n表格 在 JSBSim 中，可以定义一维、二维或三维查找表，用于气动学和函数定义。对于一个单一的“向量”查找表，格式如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003ctableData\u003e key_1 value_1 key_2 value_2 ... ... key_n value_n \u003c/tableData\u003e \u003c/table\u003e 在这个例子中，\u003cindependentVar/\u003e 元素的 lookup=\"row\" 属性是可选的；默认假设 independentVar 是行变量。一个实际的示例如下：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e -1.57 1.500 -0.26 0.033 0.00 0.025 0.26 0.033 1.57 1.500 \u003c/tableData\u003e \u003c/table\u003e 数据表格中的第一列代表查找索引（或 断点，或键）。在这个例子中，查找索引是 aero/alpha-rad（迎角，以弧度为单位）。如果 aero/alpha-rad 的值为 0.26 弧度，则查找表返回的值为 0.033。\n二维表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003ctableData\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 数据是以网格格式呈现的。以下是一个实际示例，其中 aero/alpha-rad 是行查找（迎角的断点排列在第一列），fcs/flap-pos-deg 是列查找（襟翼位置的角度，分别为 0、10、20 和 30 度）：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/flap-pos-deg \u003c/independentVar\u003e \u003ctableData\u003e 0.0 10.0 20.0 30.0 -0.0523599 8.96747e-05 0.00231942 0.0059252 0.00835082 -0.0349066 0.000313268 0.00567451 0.0108461 0.0140545 -0.0174533 0.00201318 0.0105059 0.0172432 0.0212346 0.0 0.0051894 0.0168137 0.0251167 0.0298909 0.0174533 0.00993967 0.0247521 0.0346492 0.0402205 0.0349066 0.0162201 0.0342207 0.0457119 0.0520802 0.0523599 0.0240308 0.0452195 0.0583047 0.0654701 0.0698132 0.0333717 0.0577485 0.0724278 0.0803902 0.0872664 0.0442427 0.0718077 0.088081 0.0968405 \u003c/tableData\u003e \u003c/table\u003e 三维查找表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e property_name_3 \u003c/independentVar\u003e \u003ctableData breakpoint=\"table_1_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003ctableData breakpoint=\"table_2_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e ... \u003ctableData breakpoint=\"table_n_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 请注意 \u003ctableData/\u003e 元素中的 breakpoint 属性。以下是一个示例：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e fcs/row-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/column-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e fcs/table-value \u003c/independentVar\u003e \u003ctableData breakPoint=\"-1.0\"\u003e -1.0 1.0 0.0 1.0000 2.0000 1.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"0.0000\"\u003e 0.0 10.0 2.0 1.0000 2.0000 3.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"1.0\"\u003e 0.0 10.0 20.0 2.0 1.0000 2.0000 3.0000 3.0 4.0000 5.0000 6.0000 10.0 7.0000 8.0000 9.0000 \u003c/tableData\u003e \u003c/table\u003e 插值：表格中的值是线性插值的，且不会在表格的限制值之外进行外推。表格返回的最大值是已定义的最大值。 一维插值 一些仿真中的查找表——尤其是气动数据——可能是四维、五维、六维，甚至更多维度的。Interpolate1d 返回通过对提供的值进行一维插值的结果，其中第一个直接子元素的值表示查找表中的查找值，后续的值对表示自变量和因变量。第一个提供的子元素预期是一个属性。插值不会进行外推，如果提供的查找值超出了定义的范围，则返回最高值。其格式如下：\n\u003cinterpolate1d\u003e {property, value, table, function} {property, value, table, function} {property, value, table, function} ... \u003c/interpolate1d\u003e 示例：如果 mach 为 0.4，插值将返回 0.375。如果 mach 为 1.5，插值将返回 0.60。\n\u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cv\u003e 0.25 \u003c/v\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003cv\u003e 0.50 \u003c/v\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003cv\u003e 0.60 \u003c/v\u003e \u003c/interpolate1d\u003e 上面的示例非常简单。一个更复杂的示例可能会在任何参数（除了第一个）中使用函数。这意味着断点向量可能是变量——尽管这并不常见——但更重要的是，查找向量（第二列）中的值可能是 1、2 或 3 维度的函数表元素。参数甚至可以是嵌套的 interpolate1d 元素。例如：\n\u003cfunction name=\"whatever\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 进一步扩展：\n\u003cfunction name=\"bigWhatever1\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 上面的结构实际上提供了一个五维查找表。在实践中，这会非常庞大且混乱，但这就是实现方式。 :-)\n不过，这里还有更多。对于非常非常大的气动数据库，有时某些气动系数可能不需要计算。例如，地面效应气动系数只在接近地面时才需要计算。当地面效应不对气动力和力矩产生影响时，为什么还要浪费 CPU 循环呢？我们可以使用 ifthen 元素来跳过昂贵的计算。ifthen 元素的工作方式如下：\n如果第一个直接子元素的值为 1，则返回第二个直接子元素的值，否则返回第三个子元素的值。\n\u003cifthen\u003e {property, value, table, or other function element} {property, value, table, or other function element} {property, value, table, or other function element} \u003c/ifthen\u003e 示例：如果 flight-mode 大于 2，则返回 0.00，否则返回属性 control/pitch-lag 的值。\n\u003cifthen\u003e \u003cgt\u003e \u003cp\u003e executive/flight-mode \u003c/p\u003e \u003cv\u003e 2 \u003c/v\u003e \u003c/gt\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cp\u003e control/pitch-lag \u003c/p\u003e \u003c/ifthen\u003e 在我们的例子中，可以如下编写五维查找表查询，除非起落架已放下，否则返回零：\n\u003cfunction name=\"propertyname\"\u003e \u003cifthen\u003e \u003clt\u003e \u003cp\u003e position/altitudeMSL \u003c/p\u003e \u003cv\u003e 90 \u003c/v\u003e \u003c/lt\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003cv\u003e 0 \u003c/v\u003e \u003c/ifthen\u003e \u003c/function\u003e 上面的例子在某种程度上是没有实际意义的，但格式是正确的。从性能角度来看，这是有效的，因为表格只有在查找时确实需要时才会被执行。\n力与力矩 空气动力学 有几种方法可以模拟作用在飞机上的空气动力学力和力矩（扭矩）。JSBSim 最初采用的是系数积累法。在系数积累法中，升力（例如）是通过将所有升力贡献相加来确定的。贡献的具体内容根据飞机的不同和模型的精度而有所不同，但升力的贡献可以包括来自以下方面的贡献：\n机翼 升降舵 襟翼 空气动力学系数是一些数字，这些数字在乘以某些其他值（如动态压力和机翼面积）后，结果就是一个力或力矩。这些系数可以来自飞行试验报告或教科书，或者可以通过软件（如 Digital DATCOM 或其他商业软件）或手工计算来得出。最终，JSBSim 增加了对作为函数指定的空气动力学属性的支持。在配置文件的 \u003caerodynamics\u003e 部分中，有六个子部分，分别代表 3 个力轴和 3 个力矩轴（总共六个自由度）。空气动力学部分的基本布局如下：\n\u003caerodynamics\u003e \u003caxis name=\"DRAG\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"SIDE\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"LIFT\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"ROLL\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"PITCH\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"YAW\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003c/aerodynamics\u003e 并非所有单独的轴都是必需的。JSBSim 支持几组标准的轴系统：\n\"DRAG\"、\"SIDE\"、\"LIFT\"（风轴） \"X\"、\"Y\"、\"Z\"（机体轴） \"AXIAL\"、\"SIDE\"、\"NORMAL\"（机体轴） 所有三个系统都接受 \"ROLL\"、\"PITCH\"、\"YAW\" 轴的定义。轴系统不能混合使用。在轴元素中，函数用于定义对该轴总力或力矩的各个贡献。在 JSBSim 中，函数是被广泛使用的。在定义力或力矩时，函数可以使用表格、常数、三角函数或其他标准 C 库函数。仿真参数通过属性进行引用。以下是一个例子：\n\u003cfunction name=\"aero/force/lift_due_to_flap_deflection\"\u003e \u003cdescription\u003e襟翼偏转引起的升力贡献\u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003eaero/function/ground-effect-factor-lift\u003c/property\u003e \u003cproperty\u003eaero/qbar-area\u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003efcs/flap-pos-deg\u003c/independentVar\u003e \u003ctableData\u003e 0.0 0.0 10.0 0.20 20.0 0.30 30.0 0.35 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在此例中，以上内容的文字描述如下：该函数的值是 ground-effect-factor-lift、qbar-area 和通过表格确定的值的乘积，表格根据襟翼位置（以度为单位）进行索引。\n在 \u003caxis/\u003e 部分中的所有函数都会相加，并以适当的方式应用于飞机。然而，这种格式具有一定的灵活性。那些在任何 \u003caxis/\u003e 部分之外指定的函数会被创建和计算，但它们本身并不会直接贡献到任何力或力矩的总值中。然而，它们可以被引用到位于 \u003caxis/\u003e 部分内的其他函数中。这种技术允许将可能应用于多个单独函数的计算一次性执行，并多次使用。这个技术还可以进一步扩展，实际上，空气动力学系数可以在 \u003caxis/\u003e 定义外计算出来，然后在函数定义内通过乘以各种因子（属性）将它们转换为力和力矩，并最终在 \u003caxis/\u003e 定义中应用。\n力与力矩的例子：瞬时升力 作为一个例子，我们来分析瞬时升力 $L(t)$。它可以通过以下积累公式表示：\n$$ L=L_{\\text {basic }}\\left(\\alpha_{\\mathrm{B}}, \\phi_{\\text {hyst }}\\right)+\\Delta L\\left(\\delta_{\\text {flap }}\\right)+\\Delta L\\left(\\delta_{\\mathrm{e}}\\right)+\\Delta L\\left(\\dot{\\alpha}_{\\mathrm{B}}\\right)+\\Delta L(q) \\tag{1} $$其中，$\\alpha_B$、$\\delta_{\\text{flap}}$、$\\delta_e$、$\\dot{\\alpha}_B$ 和 $q$ 是常见的飞机状态变量。无量纲标量 $\\phi_{\\text{hyst}}$ 通常等于 0，当攻角较大时（接近失速情况，当空气动力学滞后效应被建模时），它的值为 1。\n公式 (1) 中的项 $L_{\\text{basic}}\\left(\\alpha_B, \\phi_{\\text{hyst}}\\right)$ 被称为“基本”贡献，它依赖于攻角。我们知道，增加攻角会增加升力——直到某个点为止。升力通常被定义为飞行动态压力（“qbar”，$\\bar{q}$，或者对于空气动力学家而言是 $\\bar{q}_{\\infty}$）与机翼面积（$S_W$ 或简写为 $S$）和升力系数（$C_L$）的乘积。在本例中，升力系数通过查找表来确定，使用 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 作为查找表的索引：\n\u003cfunction name=\"aero/force/lift_from_alpha\"\u003e \u003cdescription\u003e 升力由于攻角 \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-psf \u003c/property\u003e \u003cproperty\u003e metrics/Sw-sqft \u003c/property\u003e \u003cproperty\u003e aero/function/kCLge \u003c/property\u003e \u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e aero/stall-hyst-norm \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.0000 -0.0900 -0.2200 -0.2200 0.0000 0.2500 0.2500 0.0900 0.7300 0.7300 0.1000 0.8300 0.7800 0.1200 0.9200 0.7900 0.1400 1.0200 0.8100 0.1600 1.0800 0.8200 0.1700 1.1300 0.8300 0.1900 1.1900 0.8500 0.2100 1.2500 0.8600 0.2400 1.3500 0.8800 0.2600 1.4400 0.9000 0.2800 1.4700 0.9200 0.3000 1.4300 0.9500 0.3200 1.3800 0.9900 0.3400 1.3000 1.0500 0.3600 1.1500 1.1500 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 基本升力系数\n$$ C_{L, \\text{ basic }}=\\frac{L_{\\text{ basic }}\\left(\\alpha_B, \\phi_{\\text{hyst }}\\right)}{\\bar{q} S} \\tag{2} $$下面是根据攻角 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 绘制的基本升力系数 $C_{L,\\text{basic}}$ 的曲线。\n上图显示了与 c172p 空气动力学模型中名为 aero/coefficient/CLwbh 的查找表相对应的二元函数 $C_{L,\\text{basic}}(\\alpha_B, \\phi_{\\text{hyst}})$。\nTODO 完成本小节内容。\n该图表示了与 c172p 空气动力学模型中名为 aero/coefficient/CDwbh 的查找表相对应的二元函数 $C_{D,\\text{basic}}(\\alpha_B, \\delta_{\\text{flap}})$。\nTODO 完成本小节内容。\n推力 (Propulsion) 推力部分通常涉及发动机的性能以及与之相关的空气动力学效应。在 JSBSim 中，推力系统通常通过对发动机的建模来实现，这包括计算气流、转速、油门设置和其他影响推力的因素。推力的计算需要依赖于多种因素，比如油门位置、发动机转速、飞行状态等。\n\u003cpropulsion\u003e \u003cengine name=\"engine1\"\u003e \u003cthrustModel\u003egeneric\u003c/thrustModel\u003e \u003crpm\u003e2000\u003c/rpm\u003e \u003cpower\u003e180\u003c/power\u003e \u003cfuelFlow\u003e50\u003c/fuelFlow\u003e \u003cthrust\u003e \u003cfunction\u003ethrust_from_rpm\u003c/function\u003e \u003c/thrust\u003e \u003c/engine\u003e \u003c/propulsion\u003e 在此示例中，我们定义了一个名为 engine1 的发动机，使用了 generic 的推力模型，并为其指定了转速、功率和油耗等参数。推力是通过某个特定的函数来计算的，比如根据发动机转速来推算。\n重量 (Weight) 飞机的重量是影响飞行的关键因素，它包括飞机的自重、载荷以及油料的质量等。重量的变化直接影响到升力、飞行速度以及燃料消耗等参数。在 JSBSim 中，重量可以通过以下方式进行建模：\n\u003cweight\u003e \u003cemptyWeight\u003e1500\u003c/emptyWeight\u003e \u003cmaxTakeoffWeight\u003e2500\u003c/maxTakeoffWeight\u003e \u003cfuelWeight\u003e \u003cproperty\u003efuel/weight\u003c/property\u003e \u003c/fuelWeight\u003e \u003c/weight\u003e 在此示例中，定义了飞机的空重、最大起飞重量以及燃料重量。燃料的重量由 fuel/weight 属性控制，表示当前燃料的质量。\n地面接触 (Ground Contact) 地面接触模型用于模拟飞机与地面之间的交互力和接触点。这些交互力包括着陆、起飞时的冲击力，以及滑行时的摩擦力。在 JSBSim 中，地面接触模型通常包括以下几个部分：\n摩擦力：模拟飞机与地面之间的摩擦。 起落架：描述起落架的刚度、阻尼和承载能力。 接触力：模拟飞机与地面接触时产生的垂直力和水平力。 \u003cgroundContact\u003e \u003ccontact\u003e \u003csurfaceType\u003easphalt\u003c/surfaceType\u003e \u003cfrictionCoefficient\u003e0.8\u003c/frictionCoefficient\u003e \u003clandingGear\u003e \u003cmodel\u003ebasic\u003c/model\u003e \u003cstiffness\u003e2000\u003c/stiffness\u003e \u003cdamping\u003e100\u003c/damping\u003e \u003c/landingGear\u003e \u003c/contact\u003e \u003c/groundContact\u003e 在此示例中，定义了地面接触的表面类型（如沥青）、摩擦系数，以及起落架的刚度和阻尼特性。\n飞行控制与系统建模 将飞机视为一般的动力学系统，它受控制输入向量 $\\boldsymbol{u}$ 的作用。输入的数量和类型可能取决于具体考虑的飞机类型。对于常规配置的飞机，输入的最小配置通常为： $$ \\boldsymbol{u}=\\left[\\delta_{\\mathrm{T}}, \\delta_{\\mathrm{a}}, \\delta_{\\mathrm{e}}, \\delta_{\\mathrm{r}}\\right] \\tag{1} $$ 其中，$\\delta_{\\mathrm{T}}$ 是油门设定，$\\delta_{\\mathrm{a}}$、$\\delta_{\\mathrm{e}}$ 和 $\\delta_{\\mathrm{r}}$ 分别是右副翼、升降舵和方向舵的角度偏转。这些量有标准符号，且它们的范围可能会根据具体的飞机设计有所不同。在飞行仿真中，它们的变化通常与驾驶舱中相应控制的归一化设置相关。\n通常油门的设定范围从 0（空闲）到 +1（最大功率）。从概念上讲，$\\delta_{\\mathrm{T}}$ 可视为实际飞行速度和高度下最大推力输出的当前分数。\n操纵杆的偏转范围通常从 −1 到 +1。\n这些映射通常取决于控制律的存在，这些控制律可能会改变飞行员操作对实际效应器偏转和推力输出的最终影响。\n从数学的角度看，无论是考虑实际的气动表面偏转和推力输出，还是归一化的命令范围，它们都被视为控制变量 $\\boldsymbol{u}$ 的一组边界。\n必须再次强调，控制输入的数量和类型是特定飞机的特征。即使在相同的广泛类别中，两种飞机设计也可能呈现出本质上不同的控制配置和数量。但一般来说，它们至少有相同的“主要”控制：一对副翼，一个主要的纵向控制，即一对对称运动的升降舵，以及一个方向舵。在许多情况下，水平尾翼也具有相对于机身参考线的可变安装角度，这个角度通常称为 $i_{\\mathrm{H}}$，大多数飞行力学教材中都有涉及。\n约定 标准飞机气动控制表面。\n气动建模概述 线性化的迎角系数： $$ C_m=C_{m 0}+C_{m \\alpha} \\alpha_{\\mathrm{B}}+C_{m \\delta_{\\mathrm{e}}} \\delta_{\\mathrm{e}}+C_{m i_{\\mathrm{H}}} i_{\\mathrm{H}}+\\left(C_{m q} q+C_{m \\dot{\\alpha}} \\dot{\\alpha}_{\\mathrm{B}}\\right) \\frac{\\bar{c}}{2 V} \\tag{2} $$ 在 c172p 模型中，升降舵通道的命令与偏转逻辑。操纵杆的移动与迎角调整杆的调节组合，归一化并映射到区间 [−1,1]。该通道的输出是一个实数变量 fcs/elevator-pos-rad，表示一个等效的升降舵偏转 $\\delta_{\\mathrm{e}}^\\star = \\delta_{\\mathrm{e}} + \\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$。其中，$\\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$ 是等效于实际升降舵调整角度 $\\delta_{\\mathrm{e}, \\mathrm{tab}}$ 的偏转角度。$\\delta_{\\mathrm{e}}$ 的范围是 [$\\delta_{\\mathrm{e}, \\mathrm{min}}$, $\\delta_{\\mathrm{e}, \\mathrm{max}}$]。尾部以移动的表面偏转来表示，既有等效条件下（上方）也有实际条件下（下方）的偏转。\n推力建模概述 一架双引擎螺旋桨飞机。在机体坐标系中，推进器、推力应用点和推力矢量的方向位置。\n与 c172p 的 FDM 中的实体 “推进器” 和 “油箱” 相关的位置。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "JSBSim User manual",
    "uri": "/simu/jsbsim_user_manual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Simulation",
    "content": "https://jsbsim-team.github.io/jsbsim-reference-manual/\nJSBSim 是一个轻量级的数据驱动型非线性六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本在线参考手册是一个社区合作项目，旨在让用户和开发者了解软件的所有功能。\n许可证： JSBSim 根据 GNU 较宽通用公共许可证（LGPL）授权。\nAcknowledgements 这款软件是许多人多年来共同努力的成果。\nTony Peden 几乎从 JSBSim 的第一天起就开始为其发展做出贡献。他负责初始化和修剪代码。Tony 还将 David Megginson 的属性系统集成到了 JSBSim 中。Tony 来自俄亥俄州立大学，拥有航空与航天工程学位。\nDavid Culp 为 JSBSim 开发了涡轮发动机模型，并设计了多个使用该模型的飞机，包括 T-38。David 拥有多种军用和民用飞机的飞行经验，包括 T-38、波音 707、727、737、757、767、SGS 2-32 和 OV-10。David 是一名航空航天工程师，毕业于美国空军学院。\nDavid Megginson 曾长期参与 FlightGear 的核心开发工作。David 将我们的飞行动力学与他的一般航空飞行经验相结合，以帮助实现最大程度的真实感，除此之外，他还设计了 FlightGear 和 JSBSim 所使用的属性系统。他以对 XML 技术的贡献而闻名，并编写了 FlightGear 和 JSBSim 使用的 easyXML 解析器。\nErik Hofman 做了多方面的工作，包括寻找飞机数据、创建飞行模型（如 F-16），并进行一些编程工作。他还测试了 IRIX 兼容性。Erik 拥有计算机科学学位。\nMathias Frölich 增加了一个多功能的每个起落架的地面高度能力，并做了许多其他贡献。Mathias 是一位来自德国的数学家。\nAgostino De Marco 为 JSBSim 创建了一个广泛适用的成本/惩罚修剪分析功能，并曾在那不勒斯大学单独使用 JSBSim 或与 FlightGear 一起使用 JSBSim。\n来自英国的 David Luff 提供了最初的活塞发动机模型，Ron Jensen 对其进行了不断的改进。\n拥有多年仿真经验的工程师 Lee Duke 和 Bill Galbraith 提出了许多建议和想法，帮助改进了 JSBSim。\n来自 NASA 兰利研究中心的 Bruce Jackson，参与了多种仿真系统的开发与应用，长期以来一直给予支持和帮助，他许多年前用 C 语言编写的仿真代码（“LaRCSim”）对 JSBSim 的早期开发具有启发意义。\nCurt Olson 协调 FlightGear 及其一些构成部分（SimGear）的开发，多年来在仿真、控制理论和其他许多话题的讨论中给予了极大的帮助。与 FlightGear 社区的合作使 JSBSim 成为一个更好的工具。\n最后，用户和开发者社区的努力使 JSBSim 达到了今天的水平。感谢所有曾经花时间报告 bug 或请求新功能的人。\n前言 JSBSim 于 1996 年构思，作为一个轻量级、数据驱动型、非线性的六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本手册简介 本在线文档分为多个部分。这是因为 JSBSim 可以从不同的角度进行查看：作为飞行器模型开发者的视角，作为将 JSBSim 集成到完整飞行仿真架构中并配有视觉效果的集成者视角，或者作为希望通过添加额外功能来适配或增强 JSBSim 的软件开发者视角。\n文档的 快速入门 部分（第零部分）解释了如何快速开始使用 JSBSim。\n接下来的第一部分是 用户手册，它解释了如何使用 JSBSim 进行仿真运行、创建飞机模型、编写脚本，并执行其他不涉及更改 JSBSim 程序代码的任务。\n第二部分是 程序员手册，解释了 JSBSim 的架构——代码是如何组织的，如何工作。\n第三部分是 公式手册，其中包含了 JSBSim 中存在的数学模型和算法的描述。\n第四部分是一些示例和案例研究，展示了 JSBSim 的使用情况。\n本文档不包含的内容 本文档不是关于推导运动方程和飞行动力学的详尽参考书。有关此类内容，请参阅 (Stevens:Lewis:Johnson:2015) 和 (Zipfel:2003)。然而，本文档旨在成为 JSBSim 的权威文档。\n快速入门 要高效使用 JSBSim，您可能需要采用 程序员的态度。这意味着您需要自行下载源代码并在您的平台上进行编译。只要您的计算机上安装了正确的工具，这其实是一个简单的过程。\n对于急于使用的人，提供了自动远程构建过程，能够交付最新的库二进制文件。您可以通过以下链接找到这些二进制文件：\nFlightGear 项目开发者提供的构建版本 (Jenkins 服务器) Linux 版 JSBSim 构建（Linux CentOS 7 虚拟机） 前往工作区 build.flightgear.org:8080/job/JSBSim/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim/build/src/ 文件夹，您会找到：可执行文件 JSBSim 和静态库文件 libJSBSim.a。\nWindows 版 JSBSim 构建 前往工作区 build.flightgear.org:8080/job/JSBSim-win/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim-win/build/src/Debug/ 文件夹，您会找到：可执行文件 JSBSim.exe 和静态库文件 JSBSim.lib。\n提供预编译 JSBSim 二进制文件的工作是 FlightGear 项目的 持续集成与交付服务 的一部分。如需了解有关 Jenkins 持续集成的更多信息，您可以 访问此链接。\nJSBSim 团队提供的构建版本 (Travis 服务器 和 AppVeyor 服务器) JSBSim 团队提供了自己的持续集成服务，交付适用于 Ubuntu 14.04.5 LTS（Trusty Tahr）和 MS Windows 的 x64 二进制文件。发布版本标记为 v2018a（或更高版本），可以从 GitHub 仓库的 发布区 下载。\n要查看最新构建的当前状态，可以访问以下链接：\nUbuntu 版 Travis 构建（包括 Python 2.7 和 3.6 的测试） Windows 版 AppVeyor 构建（无测试） 那么，您想要模拟这架飞机的飞行吗？\n获取源代码 JSBSim 的 GitHub 仓库可以通过以下链接访问：github.com/JSBSim-Team/jsbsim。该仓库镜像了 SourceForge 上的原始仓库：sourceforge.net/projects/jsbsim。\n下载源代码所需的工具 您需要安装 Git 软件。Git 是一个 版本控制软件，用于记录文件或文件集随时间的变化，以便您可以随时回溯到特定版本。JSBSim 的软件源代码文件是通过 Git 进行版本控制的。\n要安装 Git，请 访问下载页面，并选择适合您平台的版本。您可以通过两种方式在本地使用 Git：通过 GUI 客户端，或通过命令行（例如在 Linux 或 Windows 上使用 Bash shell）。\n安装完 Git 后，假设您将通过命令行使用 Git，您可以从以下两个位置之一 克隆 JSBSim 的公开源代码仓库。\n从 SourceForge 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://git.code.sf.net/p/jsbsim/code jsbsim-code 或者（SSH 模式）\n\u003e git clone git://git.code.sf.net/p/jsbsim/code jsbsim-code 从 GitHub 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://github.com/JSBSim-Team/jsbsim.git jsbsim-code 或者（SSH 模式）\n\u003e git clone git@github.com:JSBSim-Team/jsbsim.git jsbsim-code 那么，您想要模拟这架飞机的飞行吗？\n构建程序和库 JSBSim 可以通过 CMake 或 Microsoft Visual Studio 进行构建。如果您使用的是 Mac OSX 或 Linux 平台，必须使用 CMake。如果您是 Windows 用户，可以选择任意一种工具。\nJSBSim 使用标准 C++98/C99 编写，并且没有外部依赖，因此您只需要在您的平台上安装 C/C++ 编译器即可。\n使用 CMake 构建 CMake 是一个跨平台的构建和测试软件的工具。它可以生成用于使用 GNU make 或 Microsoft Visual Studio 构建 JSBSim 的文件。为了将构建文件与源代码分开，最好在单独的目录中构建 JSBSim。\n\u003e cd jsbsim-code \u003e mkdir build \u003e cd build CMake 不构建 软件，它生成文件 供 多种构建工具使用。以下命令假定您使用 GNU make 来构建 JSBSim。\n首先，您应该调用 CMake 然后执行 make\n\u003e cmake .. \u003e make 这将编译各种类并构建 JSBSim 应用程序，最终文件将位于 build/src 目录下。\n传递给 CMake 的选项 CMake 可以使用多个参数来调整 JSBSim 的构建。以下是不同的选项，您可以根据需要独立使用它们或任意组合。\n传递参数给编译器 如果您想设置编译器选项，可以通过传递标志给 CMake 来构建 JSBSim 的 Debug 版本。JSBSim 也使用 C 语言编写了一些代码，您可以为 C++ 和 C 编译器设置选项。\n\u003e cmake -DCMAKE_CXX_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_C_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_BUILD_TYPE=Debug .. \u003e make 或者，您也可以构建 JSBSim 的发布版本，并请求 GNU Make 使用 4 核心来加速可执行文件的构建。\n\u003e cmake -DCMAKE_CXX_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_C_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_BUILD_TYPE=Release .. \u003e make -j4 构建 Expat 或使用系统库 JSBSim 使用 Expat 库 来读取 XML 文件。Expat 源代码与 JSBSim 源代码一起提供，并在构建过程中与 JSBSim 一起编译。然而，如果 Expat 已经安装在您的平台上，您可能更倾向于使用系统的 Expat 库，以避免重复。在这种情况下，您应该将 SYSTEM_EXPAT 标志传递给 CMake：\n\u003e cmake -DSYSTEM_EXPAT=ON .. \u003e make 构建 JSBSim 的 Python 模块 JSBSim 的 Python 模块也可以通过 CMake 来构建。为此，您需要在您的平台上安装 Cython。CMake 将自动检测到 Cython 并构建 Python 模块。\n使用 Microsoft Visual Studio 构建 在 Visual Studio 中，您可以打开项目文件 JSBSim.vcxproj 来加载 JSBSim 项目。该项目文件将配置 Visual Studio 来构建 JSBSim 可执行文件。\n注意 1： JSBSim 的官方构建工具是 CMake。Visual Studio 项目文件作为一种便利工具提供，并不保证始终与代码保持同步。\n注意 2： 从 Visual Studio 2017 开始，Microsoft 已将 CMake 包含在内，因此您应该能够直接从 CMake 文件在 VS2017 中构建 JSBSim。\n测试 JSBSim JSBSim 附带了一个测试套件，用于自动检查构建是否正确。该测试套件位于 tests 目录中，并使用 Python 编写，因此您需要先构建 JSBSim 的 Python 模块。\n测试套件可以在 build 目录中使用 ctest 运行。可以使用 -j 选项在多个核心上并行运行测试（例如，以下示例中使用 4 核心）。\n\u003e ctest -j4 安装 JSBSim 一旦 JSBSim 被构建和测试完成，您可以将 C++ 头文件和库安装到平台范围内。为此，您可以在 build 目录中调用 GNU make：\n\u003e make install 安装 Python 模块 如果您除了 C++ 头文件和库外，还计划安装 JSBSim 的 Python 模块，那么必须将 INSTALL_PYTHON_MODULE 标志传递给 CMake：\n\u003e cmake -DINSTALL_PYTHON_MODULE=ON .. \u003e make \u003e make install 另外，您也可以通过在 build 目录中执行以下命令手动安装 Python 模块：\n\u003e cd tests \u003e python setup.py install 那么，您想模拟这架飞机的飞行吗？\n使用 Visual Studio 构建 随着 Visual Studio 2017 开始支持 CMake，现在有两种方法可以使用 Visual Studio 2017 构建 JSBSim 及其各种组件。一种是使用标准的 Visual Studio 项目文件（*.vcxproj），用于构建 JSBSim 主程序、Aeromatic++ 等组件，另一种是通过 Visual Studio 使用 CMake 来构建 JSBSim 及其各种组件。\n使用 git 检出 JSBSim 源代码。在这些示例中，源代码已检出到：\nC:\\source\\JSBSim 使用 VS 2017 项目文件构建 选择 文件 → 打开 → 项目/解决方案 … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 JSBSim.sln 文件，在本例中是：\nC:\\source\\JSBSim\\JSBSim.sln 项目文件已配置为将编译器和链接器的中间文件以及最终输出文件存储在 JSBSim 源代码树之外的目录中，即存储在 C:\\source\\JSBSim\\src 外部。\n例如，JSBSim 和 Aeromatic 的中间文件将存储在以下目录中：\nC:\\source\\JSBSim\\Debug\\x64\\JSBSim C:\\source\\JSBSim\\Debug\\x64\\aeromatic 输出文件将位于：\nC:\\source\\JSBSim\\Debug 使用 VS 2017 CMake 支持构建 选择 文件 → 打开 → CMake … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 CMakeLists.txt 文件，在本例中是：\nC:\\source\\JSBSim\\CMakeLists.txt 共有 4 种构建配置：x86、x64 以及每种版本的 Debug 和 Release。选择您想要构建的配置。\n然后使用 CMake 菜单选项选择您想要构建的组件。\n默认情况下，Visual Studio 将配置 CMake 构建到源代码树之外，默认使用用户主目录中的一个构建目录，并且将 GUID（全球唯一标识符）作为目录路径的一部分。您将在 Visual Studio 的输出窗口中看到生成的路径，例如：\n工作目录：C:\\Users\\Sean\\CMakeBuilds\\3f00c6d9-d323-5a32-8a90-665138817fd4\\build\\x64-Release 例如，如果您不想将 CMake 构建文件放在主目录中，可以通过 CMake → 更改 CMake 设置 菜单选项生成一个 CMakeSettings.json 文件，并编辑 buildRoot 和 installRoot 属性。\n最后，Visual Studio 还支持执行 JSBSim 测试。\n运行程序 这里所指的 JSBSim 仓库所在的路径将被称为 \u003cJSBSim-root-dir\u003e。如果您是从源代码构建了 JSBSim，您将在 \u003cJSBSim-root-dir\u003e/src/ 子目录下找到可执行文件（在 Linux 上为 JSBSim，在 Windows 上为 JSBSim.exe）。这是 JSBSim 独立应用程序，您可能希望将其复制到根目录中：\n\u003cJSBSim-root-dir\u003e$ cp src/JSBSim . 运行独立 JSBSim 应用程序时，可能会指定多个选项。\n\u003cJSBSim-root-dir\u003e$ JSBSim 用法（方括号中的项是可选的）： JSBSim [脚本名称] [输出指令文件名称] \u003c选项\u003e 选项： --help 返回使用信息 --version 返回版本号 --outputlogfile=\u003c文件名\u003e 设置/替换数据日志文件的名称 --logdirectivefile=\u003c文件名\u003e 设置数据日志指令文件的名称 --root=\u003c路径\u003e 设置 JSBSim 根目录（即 `src/` 所在目录） --aircraft=\u003c文件名\u003e 设置要模拟的飞机名称 --script=\u003c文件名\u003e 指定要运行的脚本 --realtime 指定按实际世界时间运行 --nice 指示 JSBSim 以低 CPU 使用率运行 --suspend 指定在初始化后暂停仿真 --initfile=\u003c文件名\u003e 指定要使用的初始化文件 --catalog 指示 JSBSim 列出该模型的所有属性 （--catalog 可以与 --aircraft 选项一起在命令行中指定， 或单独指定，同时指定飞机名称，例如 --catalog=c172） --end-time=\u003c时间\u003e 指定仿真结束时间（例如，time=20.5） --property=\u003cname=value\u003e 设置属性的值。 例如：--property=simulation/integrator/rate/rotational=1 注意：选项后跟文件名时，等号两边不能有空格 您可以通过提供脚本名称来运行 JSBSim：\n\u003cJSBSim-root-dir\u003e$ JSBSim --script=scripts/c1723.xml TODO\n完善页面内容。\n那么，您想模拟这架飞机的飞行吗？\n获取支持 获取 JSBSim 支持的最佳方式是注册 GitHub 账户并 关注 JSBSim 仓库：github.com/JSBSim-Team/jsbsim。您可以订阅单独的对话，包括问题（issues）、拉取请求（pull requests）和团队讨论，即使您没有关注该仓库或不是讨论所在团队的成员。如果您不再对某个对话感兴趣，可以随时取消订阅未来的通知。\n要了解更多信息，请阅读此指南。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "JSBSim Quickstart",
    "uri": "/simu/jsbsim_quickstart/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM \u003e  Antenna Pattern",
    "content": "一、辛格方向图数学模型 辛格方向图（Sinc Directional Diagram）模型是电子战仿真中常用的一种天线方向图模型，其数学表达式基于归一化的 sinc 函数，可以用于描述天线的辐射方向性。辛格方向图模型的表达式如下：\n$$ G(\\theta) = G_{\\text{max}} \\cdot \\left( \\frac{\\sin(N \\pi \\sin \\theta)}{N \\pi \\sin \\theta} \\right)^2 $$其中：\n$G(\\theta)$：在方向 $\\theta$ 上的天线增益。 $G_{\\text{max}}$：最大增益，通常出现在主瓣方向。 $\\theta$：观察方向与天线主轴之间的夹角。 $N$：天线阵列的阵元数。 特性说明： 主瓣与旁瓣：\n主瓣是指 $\\theta = 0$ 方向上的主要辐射能量范围，主瓣增益为 $G_{\\text{max}}$。 边旁瓣的幅度由阵元数 $N$ 决定，$N$ 越大，旁瓣越小。 归一化因子：\n归一化的 sinc 函数确保方向图的辐射功率在不同方向上的分布符合物理实际。 阵列影响：\n增加阵元数会使主瓣更加集中，旁瓣抑制效果更好。 应用场景： 辛格方向图模型广泛用于线性阵列天线、相控阵天线等的仿真，尤其是在电子战、通信和雷达信号处理中，用于评估天线的方向性性能。\n二、测试计算器 https://claude.site/artifacts/5f11ccb8-beb2-48a2-8a00-eddd0f871edc\n测试计算器代码：\nimport React, { useState } from 'react'; import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, PolarGrid, PolarAngleAxis, PolarRadiusAxis, RadarChart, Radar } from 'recharts'; import { Slider } from '@/components/ui/slider'; import { Button } from '@/components/ui/button'; import { Label } from '@/components/ui/label'; import { CalculatorIcon } from 'lucide-react'; const SincCalculator = () =\u003e { const [N, setN] = useState(8); const [tempN, setTempN] = useState(8); const [Gmax, setGmax] = useState(1); const [tempGmax, setTempGmax] = useState(1); const [cartesianData, setCartesianData] = useState([]); const [polarData, setPolarData] = useState([]); // 关键方位角定义 const keyAngles = [0, 45, 90, 135, 180, 225, 270, 315]; const calculateGain = (theta, N, Gmax) =\u003e { const thetaRad = (theta * Math.PI) / 180; const sinTheta = Math.sin(thetaRad); if (Math.abs(sinTheta) \u003c 1e-10) { return Gmax; } const numerator = Math.sin(N * Math.PI * sinTheta); const denominator = N * Math.PI * sinTheta; return Gmax * Math.pow(numerator / denominator, 2); }; const updateData = () =\u003e { const newCartesianData = []; const newPolarData = []; // 更新直角坐标数据 for (let theta = -90; theta \u003c= 90; theta += 1) { const gain = calculateGain(theta, tempN, tempGmax); const gainDB = 10 * Math.log10(Math.max(gain, 1e-10)); newCartesianData.push({ theta, gain: gainDB }); } // 更新极坐标数据 for (let theta = 0; theta \u003c 360; theta += 5) { // 对于大于180度的角度，使用对称性计算 const calcTheta = theta \u003c= 180 ? theta - 90 : 270 - theta; const gain = calculateGain(calcTheta, tempN, tempGmax); const gainDB = 10 * Math.log10(Math.max(gain, 1e-10)); const normalizedGain = Math.pow(10, gainDB/20); newPolarData.push({ theta, gain: normalizedGain, gainDB }); } setCartesianData(newCartesianData); setPolarData(newPolarData); setN(tempN); setGmax(tempGmax); }; // 自定义角度轴刻度格式化 const formatPolarAngle = (angleValue) =\u003e { // 只有关键角度才显示标签 if (keyAngles.includes(angleValue)) { return `${angleValue}°`; } return ''; }; return ( \u003cCard className=\"w-full max-w-4xl p-6\"\u003e \u003cCardHeader\u003e \u003cCardTitle\u003e辛格方向图计算器\u003c/CardTitle\u003e \u003c/CardHeader\u003e \u003cCardContent\u003e \u003cdiv className=\"space-y-6\"\u003e {/* 参数控制区 */} \u003cdiv className=\"space-y-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e阵元数 (N): {tempN}\u003c/Label\u003e \u003cSlider value={[tempN]} min={2} max={32} step={1} onValueChange={(value) =\u003e setTempN(value[0])} className=\"w-full\" /\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e最大增益 (Gmax): {tempGmax}\u003c/Label\u003e \u003cSlider value={[tempGmax]} min={0.1} max={2} step={0.1} onValueChange={(value) =\u003e setTempGmax(value[0])} className=\"w-full\" /\u003e \u003c/div\u003e \u003cButton onClick={updateData} className=\"w-full\" \u003e \u003cCalculatorIcon className=\"w-4 h-4 mr-2\" /\u003e 重新计算 \u003c/Button\u003e \u003c/div\u003e \u003cdiv className=\"grid grid-cols-1 md:grid-cols-2 gap-6\"\u003e {/* 直角坐标图 */} \u003cdiv className=\"w-full overflow-x-auto\"\u003e \u003ch3 className=\"text-lg font-medium mb-4\"\u003e直角坐标方向图\u003c/h3\u003e \u003cLineChart width={500} height={300} data={cartesianData} margin={{ top: 5, right: 30, left: 20, bottom: 5, }} \u003e \u003cCartesianGrid strokeDasharray=\"3 3\" /\u003e \u003cXAxis dataKey=\"theta\" label={{ value: '方位角 (度)', position: 'bottom' }} /\u003e \u003cYAxis label={{ value: '增益 (dB)', angle: -90, position: 'insideLeft' }} domain={[-40, 0]} /\u003e \u003cTooltip /\u003e \u003cLine type=\"monotone\" dataKey=\"gain\" stroke=\"#2563eb\" dot={false} strokeWidth={2} /\u003e \u003c/LineChart\u003e \u003c/div\u003e {/* 极坐标图 */} \u003cdiv className=\"w-full overflow-x-auto\"\u003e \u003ch3 className=\"text-lg font-medium mb-4\"\u003e极坐标方向图\u003c/h3\u003e \u003cRadarChart width={500} height={300} data={polarData} cx=\"50%\" cy=\"50%\" \u003e \u003cPolarGrid /\u003e \u003cPolarAngleAxis dataKey=\"theta\" tickFormatter={formatPolarAngle} ticks={keyAngles} /\u003e \u003cPolarRadiusAxis angle={90} domain={[0, 1]} tickFormatter={(value) =\u003e `${(20 * Math.log10(value)).toFixed(0)}dB`} /\u003e \u003cRadar name=\"增益\" dataKey=\"gain\" stroke=\"#2563eb\" fill=\"#2563eb\" fillOpacity={0.6} /\u003e \u003cTooltip formatter={(value, name, props) =\u003e [ `${(20 * Math.log10(value)).toFixed(2)} dB`, '增益' ]} /\u003e \u003c/RadarChart\u003e \u003c/div\u003e \u003c/div\u003e {/* 关键点数据显示 */} \u003cdiv className=\"grid grid-cols-2 gap-4 mt-4\"\u003e \u003cdiv className=\"p-4 border rounded\"\u003e \u003ch3 className=\"font-medium\"\u003e主瓣增益 (0°)\u003c/h3\u003e \u003cp\u003e{(10 * Math.log10(calculateGain(0, N, Gmax))).toFixed(2)} dB\u003c/p\u003e \u003c/div\u003e \u003cdiv className=\"p-4 border rounded\"\u003e \u003ch3 className=\"font-medium\"\u003e副瓣电平 (±90°)\u003c/h3\u003e \u003cp\u003e{(10 * Math.log10(calculateGain(90, N, Gmax))).toFixed(2)} dB\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/CardContent\u003e \u003c/Card\u003e ); }; export default SincCalculator; 三、模型代码 Python代码 用于测试和可视化辛格方向图模型的代码。这个代码将展示不同阵元数对方向图的影响。\nimport numpy as np import matplotlib.pyplot as plt def calc_sinc_pattern(theta_deg, N, G_max=1.0): \"\"\" 计算辛格方向图模型的增益 参数: theta_deg: ndarray, 观察角度（度） N: int, 天线阵元数 G_max: float, 最大增益 返回: ndarray: 对应角度的增益值 \"\"\" # 将角度转换为弧度 theta_rad = np.deg2rad(theta_deg) # 避免除零错误 sin_theta = np.sin(theta_rad) numerator = np.sin(N * np.pi * sin_theta) denominator = N * np.pi * sin_theta # 处理 theta = 0 的特殊情况 zero_indices = np.where(np.abs(sin_theta) \u003c 1e-10) result = np.zeros_like(theta_deg, dtype=float) # 计算非零角度的增益 nonzero_indices = np.where(np.abs(sin_theta) \u003e= 1e-10) result[nonzero_indices] = G_max * (numerator[nonzero_indices] / denominator[nonzero_indices]) ** 2 # 设置零角度的增益为最大值 result[zero_indices] = G_max return result def plot_pattern(N_values): \"\"\" 绘制不同阵元数的方向图 参数: N_values: list, 要比较的阵元数列表 \"\"\" # 创建角度数组（-90度到90度） theta = np.linspace(-90, 90, 1000) # 设置图形样式 plt.figure(figsize=(12, 8)) plt.grid(True, linestyle='--', alpha=0.7) # 为每个阵元数绘制方向图 for N in N_values: gain_db = 10 * np.log10(calc_sinc_pattern(theta, N)) plt.plot(theta, gain_db, label=f'N={N}') # 设置图形属性 plt.xlabel('方位角 (度)') plt.ylabel('增益 (dB)') plt.title('辛格方向图模型 - 不同阵元数比较') plt.legend() plt.ylim(-40, 0) # 限制最小增益为-40dB plt.show() def test_pattern(): \"\"\" 测试函数：验证方向图的关键特性 \"\"\" # 测试不同阵元数和角度的组合 N_test = [4, 8, 16] theta_test = np.array([0, 30, 60]) print(\"辛格方向图模型测试结果：\") print(\"-\" * 50) for N in N_test: print(f\"\\n阵元数 N = {N}\") gains = calc_sinc_pattern(theta_test, N) gains_db = 10 * np.log10(gains) for theta, gain, gain_db in zip(theta_test, gains, gains_db): print(f\"角度: {theta:3.0f}° | 增益: {gain:.4f} | 增益(dB): {gain_db:.2f} dB\") # 运行测试 if __name__ == \"__main__\": # 执行数值测试 test_pattern() # 绘制不同阵元数的方向图比较 plot_pattern([4, 8, 16]) 以上代码实现了以下功能：\ncalc_sinc_pattern 函数：\n实现了辛格方向图的数学模型 处理了零角度的特殊情况 支持向量化计算，提高效率 plot_pattern 函数：\n绘制极坐标形式的方向图 支持多个阵元数的对比 使用 dB 单位显示增益 test_pattern 函数：\n验证不同角度和阵元数的组合 输出详细的测试结果 要运行这个代码，需要安装 NumPy 和 Matplotlib 库。运行后，将看到：\n控制台输出：显示不同阵元数和角度组合的具体增益值 图形输出：展示不同阵元数的方向图对比 你可以通过修改 N_values 和测试角度来探索不同的参数组合。需要特别注意的是：\n增益值已经归一化，最大值为1（0 dB） 图表中使用了 dB 单位以better展示旁瓣特性 程序处理了 θ = 0° 时的奇异点 C++代码 以下为一个易于集成的C++辛格方向图计算模块，包含清晰的输入输出接口。\n// SincDirectionalModel.hpp #ifndef SINC_DIRECTIONAL_MODEL_HPP #define SINC_DIRECTIONAL_MODEL_HPP #include \u003cvector\u003e #include \u003ccmath\u003e #include \u003cstdexcept\u003e namespace DirectionalModel { /** * @brief 辛格方向图计算模块 * 用于计算和分析天线的辛格方向图特性 */ class SincDirectionalModel { public: /** * @brief 构造函数 * @param elementCount 天线阵元数 * @param maxGain 最大增益值 * @throw std::invalid_argument 当参数无效时抛出异常 */ SincDirectionalModel(unsigned int elementCount = 8, double maxGain = 1.0); /** * @brief 设置天线阵元数 * @param elementCount 天线阵元数 * @return bool 设置是否成功 */ bool setElementCount(unsigned int elementCount); /** * @brief 设置最大增益 * @param maxGain 最大增益值 * @return bool 设置是否成功 */ bool setMaxGain(double maxGain); /** * @brief 计算指定角度的增益 * @param angle_deg 观察角度（度） * @return double 增益值 */ double calculateGain(double angle_deg) const; /** * @brief 计算指定角度的分贝增益 * @param angle_deg 观察角度（度） * @return double 分贝增益值 */ double calculateGainDB(double angle_deg) const; /** * @brief 生成方向图数据点 * @param startAngle 起始角度（度） * @param endAngle 结束角度（度） * @param stepSize 角度步长（度） * @return std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e 角度-增益对 */ std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e generatePattern( double startAngle = -90.0, double endAngle = 90.0, double stepSize = 1.0) const; /** * @brief 生成分贝方向图数据点 * @param startAngle 起始角度（度） * @param endAngle 结束角度（度） * @param stepSize 角度步长（度） * @return std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e 角度-分贝增益对 */ std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e generatePatternDB( double startAngle = -90.0, double endAngle = 90.0, double stepSize = 1.0) const; /** * @brief 获取天线关键参数 * @return std::pair\u003cdouble, double\u003e 主瓣增益(dB)和第一旁瓣电平(dB) */ std::pair\u003cdouble, double\u003e getKeyParameters() const; private: unsigned int N_; // 天线阵元数 double Gmax_; // 最大增益 const double PI = 3.14159265358979323846; // 检查角度参数是否有效 bool validateAngleParams(double start, double end, double step) const; }; } // namespace DirectionalModel #endif // SINC_DIRECTIONAL_MODEL_HPP // SincDirectionalModel.cpp #include \"SincDirectionalModel.hpp\" namespace DirectionalModel { SincDirectionalModel::SincDirectionalModel(unsigned int elementCount, double maxGain) { if (!setElementCount(elementCount) || !setMaxGain(maxGain)) { throw std::invalid_argument(\"Invalid constructor parameters\"); } } bool SincDirectionalModel::setElementCount(unsigned int elementCount) { if (elementCount \u003c 1) return false; N_ = elementCount; return true; } bool SincDirectionalModel::setMaxGain(double maxGain) { if (maxGain \u003c= 0) return false; Gmax_ = maxGain; return true; } double SincDirectionalModel::calculateGain(double angle_deg) const { // 转换为弧度 double angle_rad = angle_deg * PI / 180.0; double sin_theta = std::sin(angle_rad); // 处理零角度特殊情况 if (std::abs(sin_theta) \u003c 1e-10) { return Gmax_; } double numerator = std::sin(N_ * PI * sin_theta); double denominator = N_ * PI * sin_theta; return Gmax_ * std::pow(numerator / denominator, 2); } double SincDirectionalModel::calculateGainDB(double angle_deg) const { double gain = calculateGain(angle_deg); // 防止取对数时出错，设置最小值 gain = std::max(gain, 1e-10); return 10.0 * std::log10(gain); } bool SincDirectionalModel::validateAngleParams(double start, double end, double step) const { if (start \u003e= end || step \u003c= 0) return false; if (std::abs(step) \u003e std::abs(end - start)) return false; return true; } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e SincDirectionalModel::generatePattern( double startAngle, double endAngle, double stepSize) const { if (!validateAngleParams(startAngle, endAngle, stepSize)) { throw std::invalid_argument(\"Invalid angle parameters\"); } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e pattern; pattern.reserve(static_cast\u003csize_t\u003e((endAngle - startAngle) / stepSize) + 1); for (double angle = startAngle; angle \u003c= endAngle; angle += stepSize) { pattern.emplace_back(angle, calculateGain(angle)); } return pattern; } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e SincDirectionalModel::generatePatternDB( double startAngle, double endAngle, double stepSize) const { if (!validateAngleParams(startAngle, endAngle, stepSize)) { throw std::invalid_argument(\"Invalid angle parameters\"); } std::vector\u003cstd::pair\u003cdouble, double\u003e\u003e pattern; pattern.reserve(static_cast\u003csize_t\u003e((endAngle - startAngle) / stepSize) + 1); for (double angle = startAngle; angle \u003c= endAngle; angle += stepSize) { pattern.emplace_back(angle, calculateGainDB(angle)); } return pattern; } std::pair\u003cdouble, double\u003e SincDirectionalModel::getKeyParameters() const { double mainLobeGainDB = calculateGainDB(0.0); // 查找第一旁瓣 double firstSidelobeLevel = -std::numeric_limits\u003cdouble\u003e::infinity(); double angle = 0.0; bool foundFirstPeak = false; while (angle \u003c= 90.0) { double currentGain = calculateGainDB(angle); double nextGain = calculateGainDB(angle + 0.1); if (currentGain \u003e nextGain \u0026\u0026 foundFirstPeak) { firstSidelobeLevel = currentGain; break; } if (currentGain \u003c nextGain) { foundFirstPeak = true; } angle += 0.1; } return {mainLobeGainDB, firstSidelobeLevel}; } } // namespace DirectionalModel 这个模块提供了以下主要功能：\n类接口设计：\n清晰的构造函数和设置函数 完整的错误检查和异常处理 命名空间封装 核心功能：\ncalculateGain: 计算指定角度的增益 calculateGainDB: 计算分贝形式的增益 generatePattern: 生成方向图数据点 generatePatternDB: 生成分贝形式的方向图数据点 辅助功能：\ngetKeyParameters: 获取主瓣增益和第一旁瓣电平 参数验证和错误处理 使用示例：\n#include \"SincDirectionalModel.hpp\" #include \u003ciostream\u003e int main() { try { // 创建模型实例：8个阵元，最大增益1.0 DirectionalModel::SincDirectionalModel model(8, 1.0); // 计算单点增益 double gain_0deg = model.calculateGainDB(0.0); std::cout \u003c\u003c \"0度增益: \" \u003c\u003c gain_0deg \u003c\u003c \" dB\\n\"; // 生成方向图数据 auto pattern = model.generatePatternDB(-90.0, 90.0, 1.0); // 获取关键参数 auto [mainLobe, sidelobe] = model.getKeyParameters(); std::cout \u003c\u003c \"主瓣增益: \" \u003c\u003c mainLobe \u003c\u003c \" dB\\n\"; std::cout \u003c\u003c \"第一旁瓣电平: \" \u003c\u003c sidelobe \u003c\u003c \" dB\\n\"; } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; return 1; } return 0; } 集成建议：\n将头文件和源文件添加到项目中 包含头文件并使用 DirectionalModel 命名空间 根据需要调用相应的方法 注意处理可能的异常",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "辛格方向图模型",
    "uri": "/em/antenna-pattern/01.%E8%BE%9B%E6%A0%BC%E6%96%B9%E5%90%91%E5%9B%BE%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  EM \u003e  Antenna Pattern",
    "content": "一、高斯方向图模型 高斯方向图模型是一种基于高斯分布的天线方向图简化模型，适合描述天线辐射方向图中主瓣的形状。其数学表达式如下： $$ G(\\theta) = G_{\\text{max}} \\cdot e^{-k (\\frac{\\theta}{\\theta_{\\text{3dB}}})^2} $$参数说明\n$G(\\theta)$：方向 $\\theta$ 上的天线增益。 $G_{\\text{max}}$：主瓣最大增益，通常在 $\\theta = 0$ 时取值。 $\\theta$：观察方向与天线主轴（通常是主瓣方向）之间的夹角。 $\\theta_{\\text{3dB}}$：3dB 波束宽度，定义为增益下降到最大值的一半时对应的角度宽度。 $k$：控制波束形状的系数，通常与 $\\theta_{\\text{3dB}}$ 有关，常取值为 $k = \\ln 2$，使得 $\\theta = \\theta_{\\text{3dB}}$ 时增益下降到 $G_{\\text{max}} / 2$。 特性\n主瓣集中性：\n高斯方向图模型的主瓣呈对称的高斯分布，随着角度偏离主轴，增益迅速下降。 由于模型忽略了旁瓣的影响，它通常用于关注主瓣方向的应用场景。 简洁性：\n高斯方向图模型通过简化旁瓣和其他次要特性，显著降低了计算复杂度，适合快速仿真计算。 归一化：\n为了便于计算，可以对增益进行归一化，使得 $G(\\theta)$ 的值在主瓣方向取 1。 应用场景\n电子战：快速估计天线主瓣方向的辐射能量分布，用于干扰或抗干扰评估。 雷达和通信：对主瓣方向性较强的天线进行快速仿真。 方向性优化：通过调整 $\\theta_{\\text{3dB}}$ 和 $k$ 参数实现特定的波束宽度和集中性。 如果需要进一步扩展高斯方向图模型以包括旁瓣或其他特性，也可以通过叠加额外分量进行修正。\n高斯方向图模型的改进形式 改进的高斯方向图模型其特点是用高斯分布描述主瓣，同时提供了一个函数形式用于描述主瓣以外的方向图（即旁瓣）：\n主瓣公式 $$ f(\\theta) = \\exp\\left(-k \\theta^2\\right) $$ 主瓣部分是标准的高斯分布形式，其中 $k = \\frac{4 \\ln \\sqrt{2}}{\\theta_b^2}$，由 $\\theta_b$（单程半功率点波束宽度）控制主瓣的宽度。 参数 $k$ 确保在 $\\theta = \\pm \\frac{\\theta_b}{2}$ 时，方向图幅度下降到其峰值的一半（即 3dB 下降点）。 主瓣以外的方向图 $$ f(\\theta) = \\frac{(1 + \\cos \\theta) \\sin(k \\sin(\\theta))}{2k \\sin(\\theta)} $$ 这一部分用于描述主瓣以外（旁瓣）的方向图特性。 $k = \\frac{1.3916}{\\sin(0.5\\theta_b)}$ 是根据波束宽度 $\\theta_b$ 确定的常数。 分母 $\\sin(\\theta)$ 和分子的 $\\sin(k \\sin(\\theta))$ 描述了旁瓣的振荡特性，旁瓣随 $\\theta$ 增加呈周期性变化。 模型分析\n主瓣部分：\n与传统高斯方向图模型相符，用高斯函数来精确描述主瓣方向的辐射分布。 通过参数 $k$ 和 $\\theta_b$ 控制主瓣的宽度和增益衰减速率。 旁瓣部分：\n旁瓣描述使用的是一个分段函数，体现了辐射能量的衰减和分布。 $(1 + \\cos \\theta)$ 项增强了主瓣附近的旁瓣幅度，而 $k$ 的引入确保旁瓣幅度的适当抑制。 是否为高斯方向图模型：\n这个模型主瓣部分严格满足高斯分布，可以视为高斯方向图模型。 增加了旁瓣描述的扩展部分，因此可以认为它是 一种改进的高斯方向图模型，在实际应用中更接近实际天线的辐射特性。 适用场景\n这种模型在需要对主瓣精确建模并同时考虑旁瓣对系统性能影响的场景中非常适用，例如：\n电子战中的方向图干扰仿真。 雷达系统对目标信号主瓣和旁瓣的能量分布分析。 无线通信中的波束形成优化。 二、可视化线上计算器 https://claude.site/artifacts/917d549d-d142-4c69-95dc-7a8e4ad48997\n这个交互式的React组件，可以让用户调整参数并实时查看改进型高斯方向图模型的变化。\n计算器代码：\nimport React, { useState, useCallback, useEffect } from 'react'; import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'; import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'; import { Slider } from '@/components/ui/slider'; import { Label } from '@/components/ui/label'; import { Button } from '@/components/ui/button'; import { Input } from '@/components/ui/input'; import { Switch } from '@/components/ui/switch'; import { Calculator } from 'lucide-react'; const GaussianBeamCalculator = () =\u003e { // 状态管理 const [thetaB, setThetaB] = useState(10); // 波束宽度（度） const [plotRange, setPlotRange] = useState(90); // 绘图范围（度） const [resolution, setResolution] = useState(360); // 数据点数量 const [patternData, setPatternData] = useState([]); // 方向图数据 const [kMain, setKMain] = useState(0); // 主瓣k参数 const [kSide, setKSide] = useState(0); // 旁瓣k参数 const [manualK, setManualK] = useState(false); // 是否手动设置K参数 const [manualKMain, setManualKMain] = useState('0'); // 手动输入的主瓣k参数 const [manualKSide, setManualKSide] = useState('0'); // 手动输入的旁瓣k参数 // 自动计算K参数 const calculateKParameters = useCallback(() =\u003e { const thetaBRad = (thetaB * Math.PI) / 180; const newKMain = (4 * Math.log(Math.sqrt(2))) / (thetaBRad * thetaBRad); const newKSide = 1.3916 / Math.sin(0.5 * thetaBRad); return { kMain: newKMain, kSide: newKSide }; }, [thetaB]); // 更新K参数（考虑手动/自动模式） const updateKParameters = useCallback(() =\u003e { if (manualK) { setKMain(parseFloat(manualKMain) || 0); setKSide(parseFloat(manualKSide) || 0); } else { const { kMain: newKMain, kSide: newKSide } = calculateKParameters(); setKMain(newKMain); setKSide(newKSide); setManualKMain(newKMain.toFixed(4)); setManualKSide(newKSide.toFixed(4)); } }, [manualK, manualKMain, manualKSide, calculateKParameters]); // 计算方向图数据 const calculatePattern = useCallback(() =\u003e { updateKParameters(); const data = []; const step = (2 * plotRange) / (resolution - 1); const currentKMain = manualK ? parseFloat(manualKMain) : kMain; const currentKSide = manualK ? parseFloat(manualKSide) : kSide; for (let theta = -plotRange; theta \u003c= plotRange; theta += step) { const thetaRad = (theta * Math.PI) / 180; const thetaBHalf = thetaB / 2; const isMainLobe = Math.abs(theta) \u003c= thetaBHalf; let amplitude; if (isMainLobe) { amplitude = Math.exp(-currentKMain * thetaRad * thetaRad); } else { if (Math.abs(thetaRad) \u003c 1e-10) { amplitude = 1; } else { amplitude = ((1 + Math.cos(thetaRad)) * Math.sin(currentKSide * Math.sin(thetaRad))) / (2 * currentKSide * Math.sin(thetaRad)); } } const amplitudeDB = 20 * Math.log10(Math.abs(amplitude)); const normalizedDB = Math.max(amplitudeDB, -60); const r = normalizedDB + 60; data.push({ theta, amplitude: normalizedDB, r, x: r * Math.cos(thetaRad), y: r * Math.sin(thetaRad) }); } setPatternData(data); }, [thetaB, plotRange, resolution, kMain, kSide, manualK, manualKMain, manualKSide, updateKParameters]); // 首次加载时计算初始数据 useEffect(() =\u003e { calculatePattern(); }, []); // 处理手动/自动模式切换 const handleModeToggle = (checked) =\u003e { setManualK(checked); if (!checked) { const { kMain: newKMain, kSide: newKSide } = calculateKParameters(); setManualKMain(newKMain.toFixed(4)); setManualKSide(newKSide.toFixed(4)); } }; // 自定义极坐标图组件（与之前相同） const PolarPattern = ({ data }) =\u003e { if (!data || data.length === 0) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } return ( \u003csvg className=\"w-full h-full\" viewBox=\"-70 -70 140 140\"\u003e {/* 绘制同心圆 */} {[0, 15, 30, 45, 60].map((r, i) =\u003e ( \u003ccircle key={i} cx=\"0\" cy=\"0\" r={r} fill=\"none\" stroke=\"#ddd\" strokeWidth=\"0.5\" /\u003e ))} {/* 绘制角度线 */} {[0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330].map((angle) =\u003e { const radians = (angle * Math.PI) / 180; return ( \u003cline key={angle} x1=\"0\" y1=\"0\" x2={60 * Math.cos(radians)} y2={60 * Math.sin(radians)} stroke=\"#ddd\" strokeWidth=\"0.5\" /\u003e ); })} {/* 绘制方向图曲线 */} {data.length \u003e 0 \u0026\u0026 ( \u003cpath d={`M ${data[0].x} ${data[0].y} ` + data.map(p =\u003e `L ${p.x} ${p.y}`).join(' ')} fill=\"none\" stroke=\"#2563eb\" strokeWidth=\"1\" /\u003e )} {/* 添加刻度标签 */} {[0, -20, -40, -60].map((db, i) =\u003e ( \u003ctext key={i} x=\"2\" y={-15 * i - 2} fontSize=\"4\" fill=\"#666\" \u003e {db}dB \u003c/text\u003e ))} {/* 添加角度标签 */} {[0, 90, 180, 270].map((angle) =\u003e { const radians = (angle * Math.PI) / 180; return ( \u003ctext key={angle} x={65 * Math.cos(radians)} y={65 * Math.sin(radians)} fontSize=\"4\" fill=\"#666\" textAnchor=\"middle\" \u003e {angle}° \u003c/text\u003e ); })} \u003c/svg\u003e ); }; return ( \u003cCard className=\"w-full max-w-4xl\"\u003e \u003cCardHeader\u003e \u003cCardTitle\u003e改进型高斯方向图模型计算器\u003c/CardTitle\u003e \u003c/CardHeader\u003e \u003cCardContent className=\"space-y-6\"\u003e \u003cdiv className=\"space-y-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e波束宽度 θb (度)\u003c/Label\u003e \u003cdiv className=\"flex items-center space-x-4\"\u003e \u003cSlider value={[thetaB]} onValueChange={(value) =\u003e setThetaB(value[0])} min={1} max={30} step={0.5} className=\"flex-1\" /\u003e \u003cspan className=\"w-12 text-right\"\u003e{thetaB}°\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e绘图范围 (±度)\u003c/Label\u003e \u003cdiv className=\"flex items-center space-x-4\"\u003e \u003cSlider value={[plotRange]} onValueChange={(value) =\u003e setPlotRange(value[0])} min={30} max={180} step={10} className=\"flex-1\" /\u003e \u003cspan className=\"w-12 text-right\"\u003e±{plotRange}°\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cdiv className=\"flex items-center justify-between\"\u003e \u003cLabel\u003e手动设置K参数\u003c/Label\u003e \u003cSwitch checked={manualK} onCheckedChange={handleModeToggle} /\u003e \u003c/div\u003e {manualK \u0026\u0026 ( \u003cdiv className=\"grid grid-cols-2 gap-4\"\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e主瓣k参数\u003c/Label\u003e \u003cInput type=\"number\" value={manualKMain} onChange={(e) =\u003e setManualKMain(e.target.value)} step=\"0.0001\" /\u003e \u003c/div\u003e \u003cdiv className=\"space-y-2\"\u003e \u003cLabel\u003e旁瓣k参数\u003c/Label\u003e \u003cInput type=\"number\" value={manualKSide} onChange={(e) =\u003e setManualKSide(e.target.value)} step=\"0.0001\" /\u003e \u003c/div\u003e \u003c/div\u003e )} \u003c/div\u003e \u003cButton onClick={calculatePattern} className=\"w-full\" \u003e \u003cCalculator className=\"mr-2 h-4 w-4\" /\u003e 计算方向图 \u003c/Button\u003e \u003c/div\u003e \u003cdiv className=\"grid grid-cols-1 md:grid-cols-2 gap-4\"\u003e {/* 直角坐标图 */} \u003cdiv className=\"h-96\"\u003e \u003cLabel className=\"mb-2 block\"\u003e直角坐标显示\u003c/Label\u003e \u003cResponsiveContainer width=\"100%\" height=\"100%\"\u003e \u003cLineChart data={patternData}\u003e \u003cCartesianGrid strokeDasharray=\"3 3\" /\u003e \u003cXAxis dataKey=\"theta\" label={{ value: '角度 (度)', position: 'bottom' }} /\u003e \u003cYAxis domain={[-60, 5]} label={{ value: '幅度 (dB)', angle: -90, position: 'left' }} /\u003e \u003cTooltip formatter={(value) =\u003e `${value.toFixed(2)} dB`} labelFormatter={(label) =\u003e `${label}°`} /\u003e \u003cLegend /\u003e \u003cLine type=\"monotone\" dataKey=\"amplitude\" stroke=\"#2563eb\" name=\"方向图\" dot={false} /\u003e \u003c/LineChart\u003e \u003c/ResponsiveContainer\u003e \u003c/div\u003e {/* 极坐标图 */} \u003cdiv className=\"h-96\"\u003e \u003cLabel className=\"mb-2 block\"\u003e极坐标显示\u003c/Label\u003e \u003cdiv className=\"w-full h-full\"\u003e \u003cPolarPattern data={patternData} /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"text-sm space-y-2\"\u003e \u003cp\u003e主瓣k参数: {kMain.toFixed(4)}\u003c/p\u003e \u003cp\u003e旁瓣k参数: {kSide.toFixed(4)}\u003c/p\u003e \u003cp\u003e3dB波束宽度: {thetaB}°\u003c/p\u003e \u003c/div\u003e \u003c/CardContent\u003e \u003c/Card\u003e ); }; export default GaussianBeamCalculator; 这个交互式的高斯方向图模型计算器具有以下特点：\n参数控制：\n波束宽度(θb)滑块：可调范围1°-30° 绘图范围滑块：可调范围±30°到±180° 实时更新的参数显示 可视化功能：\n响应式图表显示 自动缩放的坐标轴 网格线便于读数 鼠标悬停时显示具体数值 Y轴范围限制在-60dB到5dB 计算特性：\n实时计算主瓣和旁瓣参数 自动处理临界值 平滑的曲线显示 显示关键参数值（k参数等） 使用说明：\n拖动滑块来调整波束宽度和显示范围 图表会实时更新显示新的方向图 将鼠标悬停在曲线上可以查看具体数值 底部显示当前的计算参数 这个计算器使用了现代的React组件和hooks，采用了优化的计算方法，可以流畅地进行实时计算和显示。使用了shadcn/ui组件库来提供统一的UI风格。\n主瓣和旁瓣的K参数可以手动输入，同时保持原有的自动计算功能。\nK参数控制模式：\n添加了切换开关，可以在自动计算和手动输入之间切换 在自动模式下，K参数根据波束宽度自动计算 在手动模式下，可以直接输入K参数值 新增输入界面：\n添加了主瓣和旁瓣K参数的输入框 输入框支持高精度数值（步进值为0.0001） 切换到自动模式时会自动填充计算值 计算逻辑优化：\n分离了K参数计算和方向图计算 在手动模式下使用输入的K值 在自动模式下使用计算的K值 用户界面改进：\n清晰的模式切换开关 数值输入框的合理布局 实时显示当前使用的K参数值 使用方法：\n自动模式（默认）：\nK参数根据波束宽度自动计算 调整波束宽度会影响K参数的计算值 手动模式：\n打开\"手动设置K参数\"开关 直接输入想要的主瓣和旁瓣K参数值 点击\"计算方向图\"查看效果 切换模式：\n从自动切换到手动时，保留当前计算的K值 从手动切换到自动时，恢复根据波束宽度计算的K值 需要注意的是：\n波束宽度的选择会影响both主瓣和旁瓣的形状 可以通过调整显示范围来观察不同角度范围的细节 这个工具可以更好地理解和验证改进型高斯方向图模型的特性。\n三、参考代码 Python代码 一个方便测试和验证这个改进型高斯方向图模型的Python代码。代码将包含模型的实现、可视化以及参数测试功能。\nimport numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Slider class GaussianBeamPattern: def __init__(self, theta_b_deg=10): \"\"\" 初始化改进型高斯方向图模型 参数: theta_b_deg: float, 单程半功率点波束宽度(度) \"\"\" self.set_theta_b(theta_b_deg) def set_theta_b(self, theta_b_deg): \"\"\"设置波束宽度并更新相关参数\"\"\" self.theta_b = np.deg2rad(theta_b_deg) # 转换为弧度 # 计算主瓣的k参数 self.k_main = 4 * np.log(np.sqrt(2)) / (self.theta_b**2) # 计算旁瓣的k参数 self.k_side = 1.3916 / np.sin(0.5 * self.theta_b) def main_lobe(self, theta): \"\"\"计算主瓣方向图\"\"\" return np.exp(-self.k_main * theta**2) def side_lobe(self, theta): \"\"\"计算旁瓣方向图\"\"\" # 避免除零错误 small_angles = np.abs(theta) \u003c 1e-10 result = np.zeros_like(theta, dtype=float) # 处理非零角度 non_zero = ~small_angles theta_nz = theta[non_zero] result[non_zero] = (1 + np.cos(theta_nz)) * np.sin(self.k_side * np.sin(theta_nz)) / (2 * self.k_side * np.sin(theta_nz)) # 处理接近零度的情况（使用极限值） result[small_angles] = (1 + 1) * 1 / (2) # lim(x-\u003e0) sin(kx)/x = k return result def pattern(self, theta): \"\"\"计算完整的方向图\"\"\" # 确定主瓣范围（这里取±theta_b/2） is_main_lobe = np.abs(theta) \u003c= self.theta_b/2 # 分别计算主瓣和旁瓣 pattern = np.zeros_like(theta) pattern[is_main_lobe] = self.main_lobe(theta[is_main_lobe]) pattern[~is_main_lobe] = self.side_lobe(theta[~is_main_lobe]) return pattern def plot_beam_pattern(theta_b_deg=10): \"\"\"绘制方向图并添加交互式控件\"\"\" # 创建图形和坐标轴 fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 12)) plt.subplots_adjust(bottom=0.25) # 为滑块留出空间 # 初始化模型 beam = GaussianBeamPattern(theta_b_deg) # 计算角度范围和方向图 theta_deg = np.linspace(-90, 90, 1000) theta = np.deg2rad(theta_deg) pattern = beam.pattern(theta) # 在直角坐标系中绘制 line1, = ax1.plot(theta_deg, 20*np.log10(np.abs(pattern)), 'b-', label='方向图') ax1.grid(True) ax1.set_xlabel('角度 (度)') ax1.set_ylabel('相对幅度 (dB)') ax1.set_ylim(-60, 5) ax1.set_title('方向图 (直角坐标)') ax1.legend() # 在极坐标系中绘制 ax2.set_theta_zero_location('N') # 设置0度在正上方 ax2.set_theta_direction(-1) # 设置角度增长方向为顺时针 pattern_db = 20*np.log10(np.abs(pattern)) pattern_db = np.maximum(pattern_db, -60) # 限制最小值为-60dB line2, = ax2.plot(theta, pattern_db, 'b-') ax2.set_title('方向图 (极坐标)') ax2.set_rmin(-60) ax2.set_rmax(0) ax2.grid(True) # 添加波束宽度滑块 ax_slider = plt.axes([0.2, 0.1, 0.6, 0.03]) slider = Slider(ax_slider, '波束宽度 (度)', 1, 30, valinit=theta_b_deg) def update(val): \"\"\"更新方向图\"\"\" beam.set_theta_b(slider.val) pattern = beam.pattern(theta) pattern_db = 20*np.log10(np.abs(pattern)) # 更新直角坐标图 line1.set_ydata(pattern_db) # 更新极坐标图 pattern_db_polar = np.maximum(pattern_db, -60) line2.set_ydata(pattern_db_polar) fig.canvas.draw_idle() slider.on_changed(update) plt.show() if __name__ == \"__main__\": # 测试代码 plot_beam_pattern(10) # 默认波束宽度为10度 这段代码实现了以下功能：\n模型实现：\n创建了GaussianBeamPattern类，完整实现了改进型高斯方向图模型 分别实现了主瓣和旁瓣的计算函数 处理了临界情况（如角度接近0度时的计算） 可视化功能：\n同时提供直角坐标和极坐标两种显示方式 直角坐标显示详细的幅度变化 极坐标显示更直观的方向图特性 坐标轴和网格的合理设置 交互式参数调节：\n添加了波束宽度的滑动条 实时更新方向图显示 范围设置在1-30度之间 其他特性：\ndB显示范围限制在-60dB到5dB 合理的极坐标显示设置（北向为0度，顺时针方向） 完善的注释和文档 使用方法：\n# 直接运行程序 python gaussian_beam_pattern.py # 或者在其他代码中导入使用 from gaussian_beam_pattern import GaussianBeamPattern beam = GaussianBeamPattern(theta_b_deg=10) pattern = beam.pattern(theta) # theta为弧度制的角度数组 你可以通过滑动控制条来改变波束宽度，观察方向图的变化。这对于理解参数变化对方向图形状的影响非常有帮助。\n需要注意的是，代码需要安装以下Python包：\npip install numpy matplotlib C++代码 以下是一个高斯方向图模型的C++代码模块，具有清晰的输入输出，便于嵌入实际应用程序中使用。\n功能说明\n主瓣使用高斯模型：$f(\\theta) = \\exp\\left(-k \\theta^2\\right)$ 旁瓣描述：$f(\\theta) = \\frac{(1 + \\cos \\theta) \\sin(k \\sin(\\theta))}{2k \\sin(\\theta)}$ 输入： $\\theta$（方向角，单位：弧度） $\\theta_b$（单程半功率点波束宽度，单位：弧度） 输出： 天线方向图增益 $f(\\theta)$ C++代码模块\n#include \u003ciostream\u003e #include \u003ccmath\u003e #include \u003cstdexcept\u003e // 高斯方向图模型的实现 class GaussianAntennaPattern { public: // 构造函数，传入波束宽度 GaussianAntennaPattern(double theta_b) { if (theta_b \u003c= 0) { throw std::invalid_argument(\"Beamwidth theta_b must be positive.\"); } this-\u003etheta_b = theta_b; this-\u003ek_main = 4 * std::log(std::sqrt(2)) / (theta_b * theta_b); this-\u003ek_side = 1.3916 / std::sin(0.5 * theta_b); } // 获取指定方向角上的增益值 double computeGain(double theta) const { // 主瓣模型 if (std::abs(theta) \u003c= 0.5 * theta_b) { return std::exp(-k_main * theta * theta); } // 旁瓣模型 else { double sin_theta = std::sin(theta); if (std::abs(sin_theta) \u003c 1e-6) { // 避免除零 return 0.0; } return ((1 + std::cos(theta)) * std::sin(k_side * sin_theta)) / (2 * k_side * sin_theta); } } private: double theta_b; // 半功率点波束宽度 double k_main; // 主瓣系数 double k_side; // 旁瓣系数 }; // 测试高斯方向图模型 int main() { try { // 定义波束宽度 double theta_b = 0.5; // 以弧度为单位 GaussianAntennaPattern antennaPattern(theta_b); // 输出不同方向角的增益 std::cout \u003c\u003c \"Theta (radians) | Gain\" \u003c\u003c std::endl; for (double theta = -1.0; theta \u003c= 1.0; theta += 0.1) { double gain = antennaPattern.computeGain(theta); std::cout \u003c\u003c theta \u003c\u003c \" | \" \u003c\u003c gain \u003c\u003c std::endl; } } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; } return 0; } 代码功能解析\n主类 GaussianAntennaPattern：\n构造函数接受波束宽度 $\\theta_b$ 并计算主瓣和旁瓣的系数 $k_{\\text{main}}$ 和 $k_{\\text{side}}$。 computeGain 方法根据 $\\theta$ 判断是主瓣还是旁瓣，并分别计算增益。 输入校验：\n确保 $\\theta_b \u003e 0$。 防止 $\\sin(\\theta) = 0$ 时的除零错误。 示例输出：\n主程序循环计算不同方向角 $\\theta$ 下的增益并打印。 示例输出\n假设 $\\theta_b = 0.5$，方向角 $\\theta$ 从 $-1.0$ 到 $1.0$：\nTheta (radians) | Gain -1.0 | 0.005 -0.9 | 0.010 -0.8 | 0.050 -0.7 | 0.150 -0.6 | 0.400 -0.5 | 0.707 -0.4 | 0.900 ... 适用性\n模块化设计，便于集成到现有代码中。 支持灵活的方向角计算，适合电子战仿真、雷达信号处理等应用。 可扩展性强，能够添加额外特性（如干扰建模、噪声影响等）。 示例使用场景 场景 1：快速计算特定方向的增益 可以将代码改为直接计算某个方向角的增益，而不是循环输出：\nint main() { try { // 定义波束宽度 double theta_b = 0.5; // 单程半功率点波束宽度 GaussianAntennaPattern antennaPattern(theta_b); // 计算某个角度的增益 double theta = 0.3; // 方向角 double gain = antennaPattern.computeGain(theta); std::cout \u003c\u003c \"Gain at theta = \" \u003c\u003c theta \u003c\u003c \" radians: \" \u003c\u003c gain \u003c\u003c std::endl; } catch (const std::exception\u0026 e) { std::cerr \u003c\u003c \"Error: \" \u003c\u003c e.what() \u003c\u003c std::endl; } return 0; } 运行输出：\nGain at theta = 0.3 radians: 0.9798 场景 2：与实际仿真集成 将类 GaussianAntennaPattern 作为模块嵌入到电子战仿真程序中，只需要调用 computeGain 方法传入角度即可获取对应的增益值。例如：\ndouble signalPower = 10.0; // 原始信号功率 double theta = 0.5; // 当前方向角 double gain = antennaPattern.computeGain(theta); double receivedPower = signalPower * gain; // 加权后的接收功率 优化建议\n多线程支持：可以对 computeGain 进行多线程优化，适合批量计算多个方向增益。 文件输入输出：将计算结果写入文件或从文件读取方向角。 图形化输出：将计算结果导出为数据文件，用于可视化方向图。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "高斯方向图模型",
    "uri": "/em/antenna-pattern/02.%E9%AB%98%E6%96%AF%E6%96%B9%E5%90%91%E5%9B%BE%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Log",
    "content": "12 3\n将基于运动基元的A*算法从四旋翼无人机改进适配到固定翼无人机 参考的基于运动基元的四旋翼无人机A*算法：\nhttps://github.com/HKUST-Aerial-Robotics/Fast-Planner/blob/master/fast_planner/path_searching/src/kinodynamic_astar.cpp\n总体思路\n分析四旋翼A*算法的核心部分：了解其状态表示、控制输入、运动模型和运动基元生成方式。\n理解固定翼无人机的动力学特性：明确其状态变量、控制输入、运动学/动力学模型，以及物理和操作限制。\n整合调整：在前两步的基础上，重新定义状态和控制输入，修改运动基元生成方法，调整启发式函数和代价函数，确保算法的合理性和可行性。\n1. 四旋翼A*算法概述 1.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 速度：$\\mathbf{v} = [v_x, v_y, v_z]^T$ 状态向量：$\\mathbf{s} = [\\mathbf{p}, \\mathbf{v}]^T$，共6维。 1.2 控制输入\n加速度：$\\mathbf{a} = [a_x, a_y, a_z]^T$ 控制输入集：在最大加速度范围内进行离散化，生成一系列可能的加速度向量。 1.3 运动模型\n假设加速度在时间段$\\tau$内恒定，使用匀加速运动方程进行状态转移： $$ \\begin{cases} \\mathbf{p}(t+\\tau) = \\mathbf{p}(t) + \\mathbf{v}(t) \\tau + \\frac{1}{2} \\mathbf{a} \\tau^2 \\\\ \\mathbf{v}(t+\\tau) = \\mathbf{v}(t) + \\mathbf{a} \\tau \\end{cases} $$1.4 运动基元生成\n对控制输入$\\mathbf{a}$和持续时间$\\tau$进行离散化，生成一系列可能的运动基元。 在节点扩展时，应用这些运动基元进行状态转移，生成新节点。 2. 固定翼无人机动力学特性 2.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 航向角：$\\chi$（水平面内的方向） 俯仰角（航迹角）：$\\gamma$（垂直方向的角度） 速度大小：$v$（通常假设恒定或在一定范围内） 状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$，共5维。 2.2 控制输入\n航向角变化率：$\\dot{\\chi}$ 航迹角变化率：$\\dot{\\gamma}$ 控制输入向量：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 2.3 运动学模型\n假设速度$v$恒定，固定翼无人机的运动学方程为：\n$$ \\begin{cases} \\dot{x} = v \\cos \\gamma \\cos \\chi \\\\ \\dot{y} = v \\cos \\gamma \\sin \\chi \\\\ \\dot{z} = v \\sin \\gamma \\\\ \\dot{\\chi} = \\dot{\\chi} \\\\ \\dot{\\gamma} = \\dot{\\gamma} \\end{cases} $$2.4 动力学限制\n最小速度限制：$v_{\\min}$，避免失速。 最大速度限制：$v_{\\max}$ 最大航向角变化率：$|\\dot{\\chi}| \\leq \\dot{\\chi}_{\\max}$ 最大航迹角变化率：$|\\dot{\\gamma}| \\leq \\dot{\\gamma}_{\\max}$ 3. 方案整合与调整 3.1 状态和控制输入的重新定义\n状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$ 控制输入：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 3.2 运动基元的生成\n控制输入离散化：\n航向角变化率 $\\dot{\\chi}$：\n$$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 航迹角变化率 $\\dot{\\gamma}$： $$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 组合控制输入集：\n$$ \\mathcal{U}_D = \\left\\{ (\\dot{\\chi}, \\dot{\\gamma}) \\ \\big| \\ \\dot{\\chi} \\in \\dot{\\chi}_D, \\ \\dot{\\gamma} \\in \\dot{\\gamma}_D \\right\\} $$ 时间步长的确定：设定固定的时间步长$\\tau$，或者根据无人机的速度和环境动态调整。\n状态转移：\n使用数值积分方法（如四阶Runge-Kutta方法）在时间步长$\\tau$内对运动学方程进行积分，计算新状态$\\mathbf{s}(t+\\tau)$。\n状态更新函数：\nvoid stateTransit(const Eigen::VectorXd\u0026 state0, Eigen::VectorXd\u0026 state1, const Eigen::Vector2d\u0026 control_input, double tau) { double v = speed_; // 固定翼无人机的速度 double chi0 = state0(3); double gamma0 = state0(4); double dot_chi = control_input(0); double dot_gamma = control_input(1); // 更新航向角和航迹角 double chi1 = chi0 + dot_chi * tau; double gamma1 = gamma0 + dot_gamma * tau; // 使用平均值近似或数值积分计算位置更新 double avg_chi = (chi0 + chi1) / 2; double avg_gamma = (gamma0 + gamma1) / 2; double x1 = state0(0) + v * cos(avg_gamma) * cos(avg_chi) * tau; double y1 = state0(1) + v * cos(avg_gamma) * sin(avg_chi) * tau; double z1 = state0(2) + v * sin(avg_gamma) * tau; state1.resize(5); state1 \u003c\u003c x1, y1, z1, chi1, gamma1; } 3.3 节点扩展\n扩展函数：\nvoid expandNode(PathNodePtr current_node, std::vector\u003cPathNodePtr\u003e\u0026 successors) { // 获取当前状态 Eigen::VectorXd state0 = current_node-\u003estate; // 遍历所有可能的控制输入 for (const auto\u0026 dot_chi : dot_chi_values) { for (const auto\u0026 dot_gamma : dot_gamma_values) { Eigen::Vector2d control_input(dot_chi, dot_gamma); Eigen::VectorXd state1; // 状态转移 stateTransit(state0, state1, control_input, tau); // 检查速度限制（如果速度可变） // 检查物理可行性，如最小转弯半径 // 碰撞检测 if (!isCollisionFree(state0, state1)) { continue; } // 创建新节点 PathNodePtr new_node = new PathNode(); new_node-\u003estate = state1; new_node-\u003einput = control_input; new_node-\u003eduration = tau; new_node-\u003eparent = current_node; // 计算代价 new_node-\u003eg_score = current_node-\u003eg_score + costFunction(state0, state1, control_input, tau); new_node-\u003ef_score = new_node-\u003eg_score + heuristic(state1); // 加入后继节点列表 successors.push_back(new_node); } } } 3.4 代价函数和启发式函数\n代价函数：考虑航向角和航迹角变化率的代价，以及时间代价。 $$ \\text{Cost} = w_{\\chi} |\\dot{\\chi}| + w_{\\gamma} |\\dot{\\gamma}| + w_t \\tau $$ 启发式函数：使用三维Dubins路径的长度作为启发式估计。\nDubins路径：在已知最小转弯半径的情况下，计算从当前状态到目标状态的最短路径长度。\n启发式函数实现：\ndouble heuristic(const Eigen::VectorXd\u0026 state) { // 计算当前状态到目标状态的Dubins路径长度 double h = computeDubinsPathLength(state, goal_state_, min_turn_radius_); return h; } 3.5 碰撞检测\n离散采样：在状态转移过程中，对轨迹进行离散采样，检查每个采样点是否与障碍物发生碰撞。\n碰撞检测函数：\nbool isCollisionFree(const Eigen::VectorXd\u0026 state0, const Eigen::VectorXd\u0026 state1) { int num_checks = 10; // 采样点数量 for (int i = 1; i \u003c= num_checks; ++i) { double t = (double)i / num_checks * tau; Eigen::VectorXd intermediate_state; stateTransit(state0, intermediate_state, state1.segment(3,2) - state0.segment(3,2), t); Eigen::Vector3d position = intermediate_state.head(3); if (!isPositionValid(position)) { return false; } } return true; } 3.6 节点结构调整\n节点结构：根据新的状态和控制输入，调整节点的定义。\nclass PathNode { public: Eigen::Vector3i index; // 栅格索引 Eigen::VectorXd state; // 状态向量 [x, y, z, chi, gamma] double g_score, f_score; Eigen::Vector2d input; // 控制输入 [dot_chi, dot_gamma] double duration; PathNode* parent; char node_state; // 构造函数和析构函数 }; 3.7 A*算法流程\n搜索主循环：与传统A*算法类似，使用开启集和关闭集管理节点，按照 $f = g + h$ 的代价进行节点扩展和选择。\n算法步骤：\n初始化开启集，将起始节点加入开启集。 当开启集非空时： 从开启集中取出 $f$ 值最小的节点作为当前节点。 如果当前节点达到目标状态（或在容忍范围内），则回溯路径，结束搜索。 将当前节点加入关闭集。 扩展当前节点，生成后继节点。 对于每个后继节点： 如果节点在关闭集中，跳过。 如果节点不在开启集中，或找到更优路径，更新节点信息并加入开启集。 4. 方案可行性分析 4.1 动力学合理性\n重新定义的状态和控制输入符合固定翼无人机的动力学特性。 运动基元的生成考虑了固定翼的物理限制，如最小转弯半径和速度限制。 4.2 算法有效性\n通过使用合适的启发式函数（Dubins路径长度），保证算法的效率和最优性。 在节点扩展时进行碰撞检测，确保路径的可行性和安全性。 4.3 实际应用性\n方案中各部分的实现细节，如状态转移函数、碰撞检测和启发式函数，都可以在实际代码中具体实现。 方案兼顾了计算效率和规划质量，可以适用于实时路径规划。 5. 示例参数设置 速度：$v = 15 \\ \\text{m/s}$\n最大航向角变化率：$\\dot{\\chi}_{\\max} = \\frac{\\pi}{6} \\ \\text{rad/s}$（30度/秒）\n最大航迹角变化率：$\\dot{\\gamma}_{\\max} = \\frac{\\pi}{18} \\ \\text{rad/s}$（10度/秒）\n时间步长：$\\tau = 1 \\ \\text{s}$\n控制输入离散化步长：\n$\\Delta_{\\chi} = \\frac{\\dot{\\chi}_{\\max}}{2}$ $\\Delta_{\\gamma} = \\frac{\\dot{\\gamma}_{\\max}}{2}$ 控制输入集合：\nstd::vector\u003cdouble\u003e dot_chi_values = {-dot_chi_max, -dot_chi_max/2, 0, dot_chi_max/2, dot_chi_max}; std::vector\u003cdouble\u003e dot_gamma_values = {-dot_gamma_max, -dot_gamma_max/2, 0, dot_gamma_max/2, dot_gamma_max}; 代价函数权重：\n$w_{\\chi} = 1.0$ $w_{\\gamma} = 1.0$ $w_t = 0.1$ 最小转弯半径：\n$$ R_{\\min} = \\frac{v}{\\dot{\\chi}_{\\max}} $$ 6. 实现注意事项 6.1 数值积分方法\n由于航向角和航迹角在时间内线性变化，可以使用解析积分或简单的数值积分方法。 6.2 速度的可变性\n如果需要考虑速度的变化，可以将速度作为状态变量，并引入油门控制输入。 6.3 启发式函数的一致性\n确保启发式函数不超过实际代价，保持算法的可完备性和最优性。 6.4 碰撞检测的精度\n根据环境的复杂程度，调整采样点数量，以在精度和计算效率之间取得平衡。 总结 通过综合以上方案，我们成功地将基于四旋翼运动基元的A*算法调整为适用于固定翼无人机的版本。关键的调整在于：\n重新定义状态和控制输入：符合固定翼无人机的动力学特性。\n修改运动基元生成方式：基于固定翼的运动学模型，生成物理可行的运动基元。\n调整代价函数和启发式函数：考虑固定翼的运动特性，使用Dubins路径作为启发式估计。\n确保算法的可行性和有效性：通过碰撞检测和合理的参数设置，生成安全可行的路径。\n该方案兼顾了理论合理性和实际可行性，可用于固定翼无人机的路径规划，实现自主导航和避障功能。",
    "description": "This summary is independent of the content.",
    "tags": [],
    "title": "基于运动基元的A*算法",
    "uri": "/log/page1/index.html"
  }
]
