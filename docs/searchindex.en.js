var relearn_searchindex = [
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "UAV flight simulation",
    "description": "UAV flight simulation",
    "tags": [],
    "title": "UAV",
    "uri": "/uas/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "electromagnetic",
    "description": "electromagnetic",
    "tags": [],
    "title": "EM",
    "uri": "/em/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "AGI",
    "uri": "/agi/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Gaming",
    "uri": "/gaming/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "C2",
    "uri": "/c2/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Simulation",
    "uri": "/simu/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Visualization",
    "uri": "/visual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs",
    "content": "This is a new chapter.",
    "description": "This is a new chapter.",
    "tags": [],
    "title": "Log",
    "uri": "/log/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Simulation",
    "content": "用户手册 https://jsbsim-team.github.io/jsbsim-reference-manual/\n本部分解释了如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim 软件提供了许多现成可用的飞行器模型示例。一旦用户熟悉了进行模拟所需的所有步骤和设置，可能会希望查看这些示例，并详细了解更有经验的 JSBSim 用户是如何实现某些特定模型的。\n该项目和发行版中包含的飞行器模型不包含任何专有、敏感或机密数据。所有数据均来源于教材（如 Stevens 和 Lewis 的《Aircraft Control and Simulation》以及 Sutton 的《Rocket Propulsion Elements》）、公开的技术报告（见：NASA技术报告网站和AIAA网站），或其他公开数据（如FAA网站）。JSBSim 发行版中包含的飞行器模型，以及与现有商业或军事飞行器名称相对应的模型，都是基于公开信息制作的近似模型，仅供教育或娱乐使用。\n概述 什么是 JSBSim？ 从应用程序编程的角度来看，JSBSim 是一个主要用 C++ 编程语言编写的程序代码集合（其中包括一些 C 语言例程）。组成 JSBSim 的一些 C++ 类用于建模物理实体，如大气、飞行控制系统或引擎。某些类封装了诸如运动方程、矩阵、四元数或向量等概念或数学构造。一些类管理其他对象的集合。总的来说，JSBSim 应用程序接受控制输入，计算并汇总来自这些控制输入和环境的力矩，并在离散时间步中推进飞行器的状态（速度、方位、位置等）。\nJSBSim 已经在各种平台上构建和运行，如 Windows 或 Linux 系统上的 PC、苹果 Macintosh 以及硅谷图形公司的 IRIX 操作系统。自由的 GNU g++ 编译器可以轻松编译 JSBSim，其他如 Borland 和 Microsoft 的编译器也能很好地工作。更多信息请参见《程序员指南》。\n从最终用户的角度来看（例如进行研究的学生），JSBSim 可以被视为一个“黑箱”，它通过 XML 格式的输入文件进行提供。这些 XML 文件包含了航天器、引擎、脚本等的描述。当这些文件被加载到 JSBSim 中时，它们指示 JSBSim 模拟该飞行器的飞行情况，作为更大仿真框架的一部分（例如 FlightGear 或 OpenEaagles），或者在批处理模式下以比实际时间更快的速度运行。每次运行 JSBSim 都会生成包含模拟飞行器性能和动态数据的文件。\n从软件集成者的角度来看（例如将 JSBSim 集成到更大仿真框架中的人员），JSBSim 是一个可以被调用的库，提供输入（如飞行员的控制输入），并返回输出（描述飞行器在某一时刻的位置）。\n它适合谁，如何使用？ JSBSim 飞行动力学模型（FDM）软件库旨在易于理解，特别适合高年级航空航天工程学生。由于其配置简便，它也已被业界专业人士用于多种场景。它已经被集成到更大、更全面的飞行模拟应用程序和架构中（例如 FlightGear、Outerra 和 OpenEaagles），并且已被用作工业和学术界的批量模拟工具。\n使用示例 Aerocross Echo Hawk JSBSim 被用于 Aerocross Echo Hawk UAV 的硬件在环（HITL）测试。编写了自定义代码以通过 RS-232/422/485、模拟模拟输入/输出、离散输入/输出和套接字与飞行硬件（基于 PC/104 的系统）接口，但核心仿真代码仍为未经修改的 JSBSim 代码。飞行员/操作员培训也依赖于 JSBSim 作为六自由度（6-DoF）仿真模型。\nDuPont Aerospace 公司 JSBSim 曾在 DuPont Aerospace 公司与 Matlab 一起用于实时 HITL 仿真和飞行员/操作员培训。DuPont Aerospace 公司的 Rex duPont 解释了该项目：\n在 1990 年代，DuPont Aerospace 公司正在研发一种飞机，测试其垂直起降风扇喷气运输机的概念。我们开发了一个基于 Microsoft Windows 的飞行模拟器，用于测试拟议飞行器的飞行特性。然而，我们需要一个可以在实时中使用的仿真系统，以便能够在操作飞行执行器的全尺寸模型上测试飞行特性。我们最终选择了 FlightGear 模拟器，并使用了 JSBSim 飞行动力学模型，因为我们可以获得完整的代码，它的组织方式很好，使我们能够创建新的子程序来匹配我们的飞机，同时也有可用的支持。\n我们同时开发了一个 Matlab 模拟器，用于开发更有效的自动驾驶仪引导系统，因为我们的主要任务是仅使用自动驾驶仪起飞并保持悬停 30 秒。这将明确显示控制系统是否足够强大。因此，我们在 Matlab 模拟器和 JSBSim 派生模拟器的每个相关模块中内建了一系列单元测试，提供一系列输入以交叉验证，确保两个系统同步。\n我们使用 JSBSim 系统测试了一些 Matlab 模型难以测试的动态问题，尤其是涉及飞行员感受和过渡至悬停过程中的可控性问题。这些问题在纯控制系统领域（如 Matlab 中）很难评估，因为过渡过程中，基础的力结构随着空气动力学力量的增强和纯推力控制力的减少而不断变化。\n我们还对气动仿真中关键参数的估算误差敏感度进行了参数研究。这些研究通过让飞行员执行一系列标准机动来完成，目的是测试当一个或多个参数降低 50% 时飞机的响应（飞行员不知道是哪一个参数被改变）。\n我们也对伺服带宽进行了模拟，测试飞行特性在何种情况下变得不可接受。这有助于定义所需的特性。飞行员对控制系统的需求几乎总是与理论上最佳的参数不同。\n此外，我们开发了多种 HUD 显示系统，以便在悬停过程中操作时提供帮助，在这种情况下需要非常精确的地面速度控制。最终我们实现了一个系统，允许一个甚至没有飞行员执照的年轻工程师起飞并保持悬停在恒定高度 30 秒以上，偏差不超过 1 英尺。\n我们最终于 2007 年 9 月 30 日成功实现了自动驾驶仪控制的起飞和悬停，两次飞行的持续时间大约为 45 秒。两次飞行都因为其中一台发动机燃料耗尽而终止，而不是因为控制问题。\nMITRE 空中交通研究 JSBSim 在 MITRE 用于开发一个 6-DoF 模拟系统，模拟飞行管理系统（FMS）在连续下降进场（CDA）和优化下降进场（OPD）过程中的行为。MITRE 使用了 JSBSim 的独立版本（用于批量运行）和与 FlightGear 集成的版本。此外，还创建了附加的控制系统组件，以支持特定的横向和纵向导航研究。\nJSBSim 还被扩展为通过套接字向 MITRE 的其他应用程序输出消息，该应用程序提供了类似于空中交通管制员所看到的视图。\n美国交通部 在与美国交通部合作的项目中，开发了一个使用 JSBSim 作为六自由度（6-DoF）仿真核心的人类飞行员数学模型。\n意大利那不勒斯大学 Federico II 那不勒斯大学拥有一个基于 FlightGear 和 JSBSim 的运动座舱飞行/驾驶模拟器。该模拟器具有三屏视觉显示，提供 190 度的视场。JSBSim 源代码经过修改，提供了力反馈能力。\nJSBSim 在那不勒斯大学被用作支持近地飞行操作风险评估的工具。考虑到碰撞风险研究中的实际问题之一是评估在机场区域内新增障碍物（如建筑物或雷达塔）对飞行操作的威胁。风险评估是通过改变障碍物的几何形状和位置来进行的。评估程序基于对飞机轨迹与“正常”飞行路径的统计偏差分析，评估某一轨迹穿越给定的“保护”区域的概率。为此框架，操作场景被正式描述和实现，以便运行多个计算机模拟。\n弗劳恩霍夫风能系统研究所 在与意大利那不勒斯大学 Federico II 合作的研究中，弗劳恩霍夫风能系统研究所（IWES）的研究人员研究了轻型飞机飞行通过或接近风力涡轮机尾流时的尾流相遇问题。\n为了这项研究，开发了一个软件应用程序框架，用于生成和控制在指定风场和湍流场下的飞行仿真场景。JSBSim 被用作该框架中的飞行动力学模型，并通过调整其自动驾驶仪系统来模拟飞行员在导航过程中的真实行为。风力涡轮机尾流中的风分布是通过 OpenFOAM 计算的，并作为输入提供给动态模型。\n南非试飞学院（TFASA） 南非试飞学院使用 JSBSim 作为地面可变稳定系统（VSS）模拟器的基础，用于飞行员训练。基础飞行器模型的空气动力学稳定性和控制系数被修改，以展示它们对飞行任务的影响。还对执行器进行了建模，以展示它们在不同延迟、滞后和速率限制条件下对飞行员输入输出（PIO）的潜在影响。\n模拟的飞行器包括固定翼飞机和旋翼飞机，并配有可编程的力反馈控制装置，用于展示飞行控制机械特性（FCMC）的影响。\nJSBSim 与 Prepar3D 集成，利用 Prepar3D 的外部视觉系统，渲染到三块大型 LCD 屏幕或通过三投影仪系统呈现 180 度视图。\n仿真 虽然 JSBSim 用户不需要了解飞行模拟器操作的所有细节，但理解其基本工作原理是有帮助的。以下是一些重要的概念。\n参考坐标系用于描述飞行器模型中各种项目的位置和布局。 在定义飞行器模型时，单位的指定具有灵活性——支持英制单位和公制单位。 使用“属性”使得 JSBSim 成为一个通用模拟器，提供了一种通过参数（或变量）接口与各种系统进行交互的方法。属性广泛用于描述飞机和发动机特性配置文件中。 数学在飞行物理建模中发挥着重要作用。JSBSim 使用数据表格，因为飞行动力学特性通常存储在表格中。JSBSim 还允许设置任意代数函数，从而广泛自由地描述气动和飞行控制特性。 用户至少需要具备基本的飞行器飞行力学知识，了解飞机飞行时的常规力和力矩。 理解飞行控制和系统建模方法是成功和有效仿真的关键。 参考坐标系 在描述对象的位置、飞机的姿态和方向，或为给定的飞行条件指定输入时，需要理解一些基本的参考坐标系。以下是对这些坐标系的简要介绍：\n结构坐标系，或“构造坐标系” 该坐标系是常见的制造商参考坐标系，用于定义飞机上的各个点，例如重心位置、所有轮子的位置信息、飞行员视点、点质量、推进器等。JSBSim 飞机配置文件中的项目就是使用此坐标系来定位的。\n在结构坐标系中，X 轴沿着机身长度方向延伸，指向飞机尾部，Y 轴指向飞机右翼，Z 轴则朝上。通常，这个坐标系的原点 $O_C$ 位于飞机前部（例如机头尖端、单发动机飞机的机头防火墙处，或者位于机头前方的一段距离）。这个坐标系通常被命名为 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$.。\n结构（或构造）坐标系的飞机参考坐标系，原点 $O_C$。除了结构坐标系轴 $x_C$, $y_C$, zC 外，还展示了标准机体坐标系轴 $x_B$, $y_B$, $z_B$，它们的原点在重心 G 处。飞行员的视点位于 PEP。\nX 轴通常与机身中心线重合，并且通常与推力轴重合（例如在单发动机螺旋桨飞机中，它通过螺旋桨轴心）。沿 $x_C$ 轴的位置称为站位，沿 zC 轴的位置称为水线位置，沿 $y_C$ 轴的位置称为尾线位置。\n这是从 3D 建模软件 Blender 中截取的屏幕截图，展示了 Cessna 172 的模型及其结构坐标系 $\\mathcal{F}_{\\mathrm{C}}=\\left\\{O_{\\mathrm{C}}, x_{\\mathrm{C}}, y_{\\mathrm{C}}, z_{\\mathrm{C}}\\right\\}$。在这个例子中，原点 $O_C$ 位于驾驶舱内，靠近仪表盘。\n注意，JSBSim 模拟的飞机的原点可以位于任意位置，因为 JSBSim 内部仅使用重心（CG）与各个物体之间的相对距离——而不是物体的绝对位置。\n在结构坐标系中确定的重心位置（CG）为点 G。\n根据结构坐标系位置定义的地面接触点。\n结构坐标系中的两个关键点位置 $P_{\\mathrm{ARP}}$ 和 $P_{\\mathrm{CG}, \\mathrm{EW}}$ ，分别为气动力矩的极点和空重 CG（空机重心）。机翼根部的形状和弦长也被勾画出来。\n除了 $P_{\\mathrm{CG}, \\mathrm{EW}}$，还展示了两个重要的位置，$P_{\\text {Pilot }}$ 和 $P_{\\text {Right Pass }}$ ，分别代表飞行员和右侧乘客的质量集中点。\n机体坐标系 在 JSBSim 中，机体坐标系类似于结构坐标系，但沿 $y_C$ 轴旋转 180 度，原点与重心（CG）重合。通常，机体坐标系是通过已知飞机重心 G 位置和纵向结构轴 $x_C$ 方向来定义的。$x_B$ 轴应选择与 $x_C$ 轴平行，且从 G 指向机头的正方向。\n机体轴坐标系通常命名为$\\mathcal{F}_{\\mathrm{B}}=\\left\\{G, x_{\\mathrm{B}}, y_{\\mathrm{B}}, z_{\\mathrm{B}}\\right\\}$。$x_B$ 轴称为滚转轴，指向前方，$y_B$ 轴称为俯仰轴，指向右翼，$z_B$ 轴称为偏航轴，指向飞机腹部。\n标准的飞机机体轴坐标系，原点在重心 G 处。\n在机体坐标系中，飞机的力和力矩被相加，结果加速度被积分以得到速度。\n稳定坐标系，或“气动坐标系” 这个坐标系是根据相对风矢量相对于机体的瞬时方向来定义的。如果为了简化假设空气相对于地球静止（无风），且 $\\boldsymbol{V}$ 是飞机质心相对于地球固定观察者的速度矢量（也称为 $\\boldsymbol{V}_{\\mathrm{CM} / \\mathrm{E}}$，以强调相对运动），那么 $-\\boldsymbol{V}$ 就是相对风速，$V=\\|V\\|$是空速。\n该坐标系命名为 $\\mathcal{F}_{\\mathrm{A}}=\\left\\{G, x_{\\mathrm{A}}, y_{\\mathrm{A}}, z_{\\mathrm{A}}\\right\\}$，其中轴 $x_{\\mathrm{A}}$ 指向相对风矢量投影到飞机对称平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的方向。轴 $y_{\\mathrm{A}}$ 仍然指向右翼，并与机体轴 $y_{\\mathrm{B}}$ 重合，轴 $z_{\\mathrm{A}}$ 完成右手坐标系。\n气动坐标系，定义了气动角度 $\\alpha_{\\mathrm{B}}$ 和 $\\beta$.\n这两个轴 $x_{\\mathrm{A}}$ 和 $z_{\\mathrm{A}}$ 根据定义属于飞机的对称面，但它们在飞行过程中可能会旋转，因为相对风速矢量 $V$ 相对于飞行器的方向可能会发生变化。上图展示了如何构建气动坐标系。两个轴 $x_{\\mathrm{A}}$ 和 $x_{\\mathrm{B}}$ 之间的夹角是飞机的迎角 $\\alpha_{\\mathrm{B}}$。相对风的瞬时方向 $\\boldsymbol{V}$ 与其在平面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$ 上的投影之间形成的夹角是侧滑角 $\\beta$。\n这个坐标系，在一些手册中被称为稳定坐标系，在此也称为“气动坐标系”，因为瞬时气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 在 $z_{\\mathrm{A}}$ 轴上的投影 $Z_{\\mathrm{A}}$ 定义了气动升力。具体来说，升力 $L$ 是这样定义的：$-L$ 是气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 沿 $z_{\\mathrm{A}}$ 轴的分量，即 $Z_{\\mathrm{A}}=-L$。\n为了更好地理解上述描述，考虑一个在飞行力学中常见的典型动作：零侧滑（或“协调”）、保持恒定高度的匀速转弯。在这种情况下，机翼会倾斜，升力也会倾斜。在这种转弯中，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 是倾斜的，而 $x_{\\mathrm{A}}$ 轴保持水平。一般来说，升力作为一个矢量总是定义在飞机的对称面内。\n在恒定高度的匀速协调转弯中，倾斜升力的情况。倾斜角 $\\phi_{\\mathrm{W}}$ 是绕相对风速矢量的旋转。当速度矢量与北方对齐时，运动被定格在时间上。协调转弯意味着 $\\beta=0$，恒定高度意味着 $x_{\\mathrm{A}}$ 轴保持水平。\n备注 —— 在动态稳定性研究中，“稳定坐标系”与上述的气动坐标系略有不同：飞机飞行力学和稳定性约定中的稳定坐标系不过是一个特定的机体固定坐标系，定义是基于初始的对称、稳定、机翼水平、恒定高度的飞行状态。该状态给出了 $x_S$ 的方向（在该特定飞行姿态下与 $x_A$ 重合）。因此，在动态稳定性研究中，稳定坐标系与气动坐标系不同，是固定在飞行器上的。\n在 JSBSim 中，稳定坐标系 $\\mathcal{F}_{\\mathrm{S}}=\\left\\{G, x_{\\mathrm{S}}, y_{\\mathrm{S}}, z_{\\mathrm{S}}\\right\\}$ 代表了气动坐标系。\n地心惯性坐标系（ECI）和地心固定坐标系（ECEF） 地心惯性坐标系（或简称“惯性坐标系”）$\\mathcal{F}_{\\mathrm{ECI}}=\\left\\{O_{\\mathrm{ECI}}, x_{\\mathrm{ECI}}, y_{\\mathrm{ECI}}, z_{\\mathrm{ECI}}\\right\\}$固定，其原点位于地球中心。其笛卡尔坐标轴相对于恒星保持固定，为飞机（或航天器）运动方程提供最简洁的参考坐标系。正 $z_{\\mathrm{ECI}}$ 轴穿过地球的地理北极。$x_{\\mathrm{ECI}}$ 和 $y_{\\mathrm{ECI}}$ 轴位于赤道平面内。$x_{\\mathrm{ECI}}$ 轴始终与从太阳质心到地球在春分时的轨道位置的连线平行。下图展示了 ECI 系统。\n地心惯性（ECI）坐标系和地心固定（ECEF）坐标系。\n地心地固参考系（ECEF）的坐标轴，如 $x_{\\mathrm{ECEF}}$、$y_{\\mathrm{ECEF}}$ 和 $z_{\\mathrm{ECEF}}$，也如上图所示。ECEF 坐标轴相对于地球保持固定。这个笛卡尔系统的原点 $O_{\\mathrm{ECEF}}$，与惯性坐标系一样，位于地球的质心。$z_{\\mathrm{ECEF}}$ 轴也沿着地球的自转轴，并与 $z_{\\mathrm{ECI}}$ 轴重合。$x_{\\mathrm{ECEF}}$ 和 $y_{\\mathrm{ECEF}}$ 轴都位于赤道平面内，且正 $x_{\\mathrm{ECEF}}$ 轴通过本初子午线（格林威治子午线）。ECEF 坐标系绕惯性坐标系的 $z_{\\mathrm{ECI}}$ 轴以角速度 $\\omega_{\\mathrm{E}}$ 逆时针旋转。地球的角速度 $\\omega_{\\mathrm{E}}$ 近似等于 $2 \\pi / 24$ 弧度/小时。\n北向切平面坐标系 当假设地球表面有数学表示（如椭球体或近似球体）时，可以定义一个切平面坐标系。选取与地表某一点 $O_{\\mathrm{E}}$ 相切的平面作为参考。一个叫做“北向切平面坐标系”的地理坐标系 $\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 具有固定原点 $O_{\\mathrm{E}}$，其平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与切平面重合。轴 $x_{\\mathrm{E}}$ 指向地理北方，轴 $y_{\\mathrm{E}}$ 指向东方，最后，轴 $z_{\\mathrm{E}}$ 指向地面，平行于椭球体的法线（如果使用近似球体代替椭球体，则该轴指向地球中心）。因此，坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 也被称为切平面 NED 坐标系（North-East-Down）。\n地心固定（ECEF）坐标系、地理坐标、切平面坐标系和局部垂直坐标系。\n局部垂直局部水平坐标系，或局部 NED 坐标系 局部垂直坐标系$\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$ 与飞机在空间中的朝向无关，而仅由其重心相对于某个便捷的地球固定观察者的位置定义。如果 $G_{\\mathrm{GT}}$ 是重心在地面上的投影（即“地面跟踪”），则坐标平面 $x_{\\mathrm{V}} y_{\\mathrm{V}}$ 平行于在 $G_{\\mathrm{GT}}$ 处与地球表面局部切平面的平面——即平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$，其中 $O_{\\mathrm{E}} \\equiv G_{\\mathrm{GT}}$。然后，轴 $x_{\\mathrm{V}}$ 指向地理北方，轴 $y_{\\mathrm{V}}$ 指向东，最后，轴 $z_V$ 指向地球中心的下方。因此，坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 也被称为局部NED（载机）坐标系。\n飞机体坐标系和局部垂直坐标系（NED坐标系）。图中还展示了飞机的欧拉角：航向角 $\\psi$（图中为负），俯仰角 $\\theta$，和滚转角 $\\phi$。\nNED惯例确保飞机的重量是一个力，在坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 中的分量为 $(0,0, m g)$，其中 $m$ 是飞机的质量，$g$ 是重力加速度。\n上述图展示了一个包含两个坐标系 $\\mathcal{F}_{\\mathrm{V}}$ 和 $\\mathcal{F}_{\\mathrm{B}}$ 的飞机。定义机体坐标系相对于局部NED坐标系的朝向的欧拉角是飞机的欧拉角。对于大气飞行器，定义欧拉角时使用的旋转序列是“3-2-1”。这定义了相对于固定在地球上的观察者的航向角 $\\psi$、俯仰角 $\\theta$ 和滚转角 $\\phi$。\n飞机的欧拉角旋转序列。坐标系$\\mathcal{F}_{\\mathrm{E}}=\\left\\{O_{\\mathrm{E}}, x_{\\mathrm{E}}, y_{\\mathrm{E}}, z_{\\mathrm{E}}\\right\\}$ 是一个地球固定的 NED 坐标系，原点 $O_{\\mathrm{E}}$ 位于地面某处（或海平面），且平面 $x_{\\mathrm{E}} y_{\\mathrm{E}}$ 与地球表面相切。如果地面跟踪点 $G_{\\mathrm{GT}}$ 离 $O_{\\mathrm{E}}$ 不远，则地球坐标系 $\\mathcal{F}_{\\mathrm{E}}$ 的轴线与局部 NED 坐标系 $\\mathcal{F}_{\\mathrm{V}}=\\left\\{G, x_{\\mathrm{V}}, y_{\\mathrm{V}}, z_{\\mathrm{V}}\\right\\}$的轴线平行。\n风坐标系 除了升力，瞬时气动合力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 在参考系中还有两个分量，其中 $z_{\\mathrm{A}}$ 是第三轴。该参考系称为风参考系 $\\mathcal{F}_{\\mathrm{W}}=\\left\\{G, x_{\\mathrm{W}}, y_{\\mathrm{W}}, z_{\\mathrm{W}}\\right\\}$。\n风参考系的定义是将 $x_W$ 轴沿相对风的方向，并且其正方向与运动方向一致。这意味着 $x_{\\mathrm{W}}$ 与向量 $\\boldsymbol{V}$ 重合。风参考系的第三轴沿升力作用线定义，即 $z_{\\mathrm{W}} \\equiv z_{\\mathrm{A}}$。最后，第二轴 $y_{\\mathrm{W}}$ 被选择以完成右手坐标系。风参考系的第三轴始终处于机体对称面（也叫“参考面”）内。由于飞机的姿态随着相对风 $-\\boldsymbol{V}$ 的变化而变化，所有三个风轴会相对于机体轴旋转。\n力矢量 $\\mathcal{F}_{\\mathrm{A}}$ 沿着 $\\boldsymbol{V}$ 方向的分量 $X_{\\mathrm{W}}$ 定义了气动阻力：气动阻力 $D$ 满足 $X_{\\mathrm{W}}=-D$。在存在非零侧滑角 $\\beta$ 的情况下，气动合力 $\\mathcal{F}_{\\mathrm{A}}$ 会沿横向轴 $y_{\\mathrm{W}}$ 产生第三个非零分量，即侧向力分量 $Y_{\\mathrm{W}}$。\n当侧滑角 $\\beta$ 为零时，风参考系和气动参考系重合。仅在这种情况下，$y_{\\mathrm{W}}$ 与 $y_{\\mathrm{A}}$ 和 $y_{\\mathrm{B}}$ 重合，且垂直于参考面 $x_{\\mathrm{B}} z_{\\mathrm{B}}$。\n下图显示了飞机在平稳空气中的爬升飞行的标准参考系。当围绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$ 时，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以与气动参考系 $\\mathcal{F}_{\\mathrm{A}}$ 重合。\n标准参考系和飞机在平稳空气中的爬升飞行。质心速度矢量 $\\boldsymbol{V}$ 与水平面形成飞行路径角 $\\gamma$。标准的三个气动合力分量 $D$、$L$ 和 $Y_{\\mathrm{A}}$ 也已显示。\n因此，风参考系 $\\mathcal{F}_{\\mathrm{W}}$ 可以通过先绕 $z_{\\mathrm{W}}$ 轴旋转角度 $-\\beta$，再绕 $y_{\\mathrm{A}}$ 轴旋转角度 $\\alpha_{\\mathrm{B}}$，与机体参考系 $\\mathcal{F}_{\\mathrm{B}}$ 重合。 $$ \\mathcal{F}_{\\mathrm{W}} \\xrightarrow{-\\beta \\curvearrowright z_{\\mathrm{W}}} \\mathcal{F}_{\\mathrm{A}} \\xrightarrow{\\alpha_{\\mathrm{B}} \\curvearrowright y_{\\mathrm{A}}} \\mathcal{F}_{\\mathrm{B}} \\tag{1} $$气动结果力在机体轴上的分量则表示如下：\n$$ \\left\\{\\begin{array}{c} X_{\\mathrm{B}} \\\\ Y_{\\mathrm{B}} \\\\ Z_{\\mathrm{B}} \\end{array}\\right\\}=\\left[\\begin{array}{ccc} \\cos \\alpha_{\\mathrm{B}} \u0026 0 \u0026 -\\sin \\alpha_{\\mathrm{B}} \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin \\alpha_{\\mathrm{B}} \u0026 0 \u0026 \\cos \\alpha_{\\mathrm{B}} \\end{array}\\right]\\left[\\begin{array}{ccc} \\cos \\beta \u0026 \\sin (-\\beta) \u0026 0 \\\\ -\\sin (-\\beta) \u0026 \\cos \\beta \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{array}\\right]\\left\\{\\begin{array}{c} -D \\\\ Y_{\\mathrm{W}} \\\\ -L \\end{array}\\right\\} \\tag{2} $$这些表示了气动阻力、侧向力和升力。\n单位 JSBSim 在内部计算中几乎 exclusively 使用英制单位。然而，也可以在配置文件中输入一些参数时使用不同的单位。为了避免混淆，建议总是指定单位。单位使用 unit 属性进行指定。例如，翼展的规格如下所示：\n\u003cwingspan unit=\"FT\"\u003e 35.8 \u003c/wingspan\u003e 上述声明指定了一个 35.8 英尺的翼展。以下声明将翼展指定为米单位，这将导致翼展在读取时转换为 35.8 英尺：\n\u003cwingspan unit=\"M\"\u003e 10.91 \u003c/wingspan\u003e 这两条关于翼展的声明实际上是等效的。\nJSBSim 目前支持以下单位：\n长度\nunit= 单位 FT 英尺 IN 英寸 M 米 KM 千米 面积\nunit= 单位 M2 平方米 FT2 平方英尺 体积\nunit= 单位 FT3 立方英尺 CC 立方厘米 M3 立方米 LTR 升 质量和重量\nunit= 单位 LBS 磅（质量） KG 千克 惯性矩\nunit= 单位 SLUG*FT2 磅*英尺² KG*M2 千克*米² 角度\nunit= 单位 RAD 弧度 DEG 度 弹簧力\nunit= 单位 N/M 牛顿/米 LBS/FT 磅/英尺 阻尼力\nunit= 单位 N/M/SEC 牛顿/(米·秒) LBS/FT/SEC 磅/(英尺·秒) 功率\nunit= 单位 WATTS 瓦特 HP 马力 力\nunit= 单位 LBS 磅 N 牛顿 速度\nunit= 单位 KTS 节 FT/SEC 英尺/秒 M/S 米/秒 扭矩\nunit= 单位 N*M 牛顿·米 FT*LBS 磅·英尺 压力\nunit= 单位 PSF 磅/平方英尺 PSI 磅/平方英寸 ATM 大气压 PA 牛顿/平方米 INHG 英寸汞柱 属性系统 仿真程序需要管理大量的状态信息。对于特别庞大的程序，数据管理任务可能会引发一些问题：\n贡献者越来越难以掌握所需的多个接口，以进行任何有用的程序扩展，因此贡献进展变慢。 运行时的可配置性变得越来越困难，因为不同的模块使用不同的机制（环境变量、自定义规范文件、命令行选项等）。 模块初始化的顺序变得复杂且脆弱，因为一个模块的初始化例程可能需要从未初始化的模块设置或获取状态信息。 通过附加脚本、规范文件等进行扩展的能力仅限于程序提供的状态信息，且非编码开发人员往往要等待较长时间才能获得开发人员添加新变量的支持。 属性管理器系统提供了一个单一的接口，用于选择程序的状态信息，并允许在运行时动态创建新的用户指定的变量。后一种能力对于 JSBSim 控制系统模型尤其重要，因为组成飞机控制律的各个控制系统组件（PID 控制器、开关、加法器、增益等）仅在配置文件中存在。在运行时——在解析组件定义之后——这些组件将被实例化，属性管理器将创建一个属性来存储每个组件的输出值。\n属性本身类似于具有选择性限制可见性（只读或读写）的全局变量，它们被分类到一个层次结构的树形结构中，类似于 Unix 文件系统的结构。属性树的结构包括根节点、子节点（类似子目录）和终端节点（属性）。类似于 Unix 文件系统，属性可以相对于当前节点或根节点进行引用。节点可以像符号链接文件或目录到其他文件或目录一样，附加到其他节点上。属性在整个 JSBSim 和 FlightGear 中用于引用程序代码中的特定参数。属性名称的形式如下：position/h-sl-ft 和 aero/qbar-psf。\n为了说明使用属性和配置文件的强大功能，考虑一下高性能喷气式飞机模型的案例。假设在示例飞机的控制面板上添加了一个新的开关，允许飞行员在飞行控制系统（FCS）中覆盖俯仰限制。对于 FlightGear，仪表面板是在配置文件中定义的，开关也在那里定义以进行视觉显示。该开关定义还会分配一个属性名称。在 JSBSim 飞机规范文件中的飞行控制部分，分配给仪表面板定义中俯仰覆盖开关的相同属性名称可以用于根据开关位置引导控制律通过所需路径。无需修改任何代码。\n特定的仿真参数可以通过属性在 JSBSim 和配置文件规范中进行访问和设置。如前所述，“属性”是我们用来描述可以从配置文件或命令行中访问或设置的参数的术语。\n许多属性是标准属性——即所有飞行器始终存在的属性。气动系数、发动机、推进器以及飞行控制/自动驾驶模型也会具有动态定义的属性。这是因为，直到读取相关的飞行器配置文件后，整个气动系数、发动机等的集合才会被确定。要访问这些参数，必须知道使用的属性命名约定。例如，X-15 模型的飞行控制系统包括以下组件：\n\u003cflight_control name=\"X-15\"\u003e \u003cchannel name=\"Pitch\"\u003e \u003csummer name=\"fcs/pitch-trim-sum\"\u003e \u003cinput\u003e fcs/elevator-cmd-norm \u003c/input\u003e \u003cinput\u003e fcs/pitch-trim-cmd-norm \u003c/input\u003e \u003cclipto\u003e \u003cmin\u003e -1 \u003c/min\u003e \u003cmax\u003e 1 \u003c/max\u003e \u003c/clipto\u003e \u003c/summer\u003e \u003caerosurface_scale name=\"fcs/pitch-command-scale\"\u003e \u003cinput\u003e fcs/pitch-trim-sum \u003c/input\u003e \u003crange\u003e \u003cmin\u003e -50 \u003c/min\u003e \u003cmax\u003e 50 \u003c/max\u003e \u003c/range\u003e \u003c/aerosurface_scale\u003e \u003cpure_gain name=\"fcs/pitch-gain-1\"\u003e \u003cinput\u003e fcs/pitch-command-scale \u003c/input\u003e \u003cgain\u003e -0.36 \u003c/gain\u003e \u003c/pure_gain\u003e \u003c/channel\u003e \u003c/flight_control\u003e 在上面的例子中，第一个组件（fcs/pitch-trim-sum）接收来自两个地方的输入，即已知的静态属性 fcs/elevator-cmd-norm 和 fcs/pitch-trim-cmd-norm。接下来的组件将接收第一个组件的输出作为输入。第二个组件列出的输入属性为 fcs/pitch-trim-sum。继续上述示例，最后一个组件 fcs/pitch-gain-1 接收前一个组件的输出 fcs/pitch-command-scale，该属性名为 fcs/pitch-command-scale。\n因此，现在我们已经可以访问 JSBSim 内部的许多参数，并且我们知道如何组装 JSBSim 中的飞行控制系统（FCS）。在 FCS 中使用的相同组件，也可以用来构建自动驾驶系统或其他系统。\n数学 函数 JSBSim 中的函数规范是一个强大且多功能的资源，允许在 JSBSim 配置文件中定义代数函数。函数的语法在概念上类似于 MathML（数学标记语言，http://www.w3.org/Math/），但它更加简洁和紧凑。\n一个函数定义由一个操作、一个值、一个表格或一个属性（评估为值）组成。当前支持的操作有：\nsum（接受 n 个参数） difference（接受 n 个参数） product（接受 n 个参数） quotient（接受 2 个参数） pow（接受 2 个参数） exp（接受 2 个参数） abs（接受 n 个参数） sin（接受 1 个参数） cos（接受 1 个参数） tan（接受 1 个参数） asin（接受 1 个参数） acos（接受 1 个参数） atan（接受 1 个参数） atan2（接受 2 个参数） min（接受 n 个参数） max（接受 n 个参数） avg（接受 n 个参数） fraction（接受 1 个参数） mod（接受 2 个参数） lt（小于，接受 2 个参数） le（小于等于，接受 2 个参数） gt（大于，接受 2 个参数） ge（大于等于，接受 2 个参数） eq（等于，接受 2 个参数） nq（不等于，接受 2 个参数） and（接受 n 个参数） or（接受 n 个参数） not（接受 1 个参数） if-then（接受 2-3 个参数） switch（接受 2 个或更多参数） random（高斯随机数，无参数） integer（接受 1 个参数） 一个操作在配置文件中的定义示例如下：\n\u003csum\u003e \u003cvalue\u003e 3.14159 \u003c/value\u003e \u003cproperty\u003e velocities/qbar \u003c/property\u003e \u003cproduct\u003e \u003cvalue\u003e 0.125 \u003c/value\u003e \u003cproperty\u003e metrics/wingarea \u003c/property\u003e \u003c/product\u003e \u003c/sum\u003e 在上述例子中，sum 元素包含了其他三个项。它的计算过程可以用代数表达式表示为： $$ 3.14159+\\text { qbar }+(0.125 \\cdot \\text { wingarea }) $$ 一个完整的函数定义（例如在气动部分的配置文件中使用的）包括 function 元素和其他元素。需要注意的是，函数定义中只能有一个非可选（非文档）元素——即一个操作元素。该元素不能包含多个直接子操作、property、table 或 value 元素。几乎总是，函数元素中的第一个操作将是乘积（product）或和（sum）。例如：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003e Roll moment due to yaw rate \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-area \u003c/property\u003e \u003cproperty\u003e metrics/bw-ft \u003c/property\u003e \u003cproperty\u003e velocities/r-aero-rad_sec \u003c/property\u003e \u003cproperty\u003e aero/bi2vel \u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在函数定义中，最“底层”的元素总是一个值或一个属性，它本身不能包含其他元素。如所示，操作可以包含值、属性、表格或其他操作。\n在 JSBSim 中，某些操作仅接受一个参数。然而，这个参数可以是一个操作（例如 sum），而该操作可以包含其他项。需要记住的一点是，任何此类包含的操作都将计算出一个单一的值 —— 这正是三角函数所要求的（除了 atan2，它接受两个参数）。\n最后，在函数定义中，有一些简写别名可以用来代替标准的元素标签，从而使得表达式更加简洁。属性、值和表格通常用 \u003cproperty\u003e、\u003cvalue\u003e 和 \u003ctable\u003e 标签来引用。但是，在函数定义中，以上这些元素可以使用 \u003cp\u003e、\u003cv\u003e 和 \u003ct\u003e 标签来代替。因此，之前的示例可以简化为以下格式：\n\u003cfunction name=\"aero/moment/roll_moment_due_to_yaw_rate\"\u003e \u003cdescription\u003eRoll moment due to yaw rate\u003c/description\u003e \u003cproduct\u003e \u003cp\u003e aero/qbar-area \u003c/p\u003e \u003cp\u003e metrics/bw-ft \u003c/p\u003e \u003cp\u003e aero/bi2vel \u003c/p\u003e \u003cp\u003e velocities/r-aero-rad_sec \u003c/p\u003e \u003ct\u003e \u003cindependentVar\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e 0.000 0.08 0.094 0.19 ... ... \u003c/tableData\u003e \u003c/t\u003e \u003c/product\u003e \u003c/function\u003e 在气动建模中，表格函数可以用来表示影响升力和阻力的地面效应因子。下图解释了地面效应：\n为了了解如何在 JSBSim 中建模地面效应，我们可以查看 Cessna 172 Skyhawk 模型。这一模型在文件 \u003cJSBSim-root-dir\u003e/aircraft/c172p/c172p.xml 中实现。在该 XML 文件的 \u003caerodynamics/\u003e 块中，建模了两个无量纲因子, $K_{C_{D, \\mathrm{ge}}}$ 和 $K_{C_L, \\mathrm{ge}}$,它们是无量纲地面高度的函数，并被视为升力和阻力的乘数。这些因子如下所示：\n\u003cfunction name=\"aero/function/kCDge\"\u003e \u003cdescription\u003eChange in drag due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 0.4800 0.1000 0.5150 0.1500 0.6290 0.2000 0.7090 0.3000 0.8150 0.4000 0.8820 0.5000 0.9280 0.6000 0.9620 0.7000 0.9880 0.8000 1.0000 0.9000 1.0000 1.0000 1.0000 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e \u003cfunction name=\"aero/function/kCLge\"\u003e \u003cdescription\u003eChange in lift due to ground effect\u003c/description\u003e \u003cproduct\u003e \u003cvalue\u003e1.0\u003c/value\u003e \u003ctable\u003e \u003cindependentVar\u003e aero/h_b-mac-ft \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.2030 0.1000 1.1270 0.1500 1.0900 0.2000 1.0730 0.3000 1.0460 0.4000 1.0550 0.5000 1.0190 0.6000 1.0130 0.7000 1.0080 0.8000 1.0060 0.9000 1.0030 1.0000 1.0020 1.1000 1.0000 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 下图展示了表示因子 $K_{C_{D, \\text{ ge}}}$ 和 $K_{C_{L, \\text{ ge}}}$ 的表格函数 aero/function/kCDge 和 aero/function/kCLge ，分别表示因地面效应引起的阻力和升力的变化。它们的图形化表示如下，显示了相对于无量纲地面高度 $h/(b/2)$ 的变化。在飞机离地面高度小于机翼半个翼展 $b/2$ 时，可以观察到地面效应；而在更高的高度时，这两个因子值趋于 1。\n以上图表展示了无量纲地面高度 $h/(b/2)$ 的函数，定义了 c172p 飞机气动模型中的 aero/function/kCLge 和 aero/function/kCDge 属性。\n表格 在 JSBSim 中，可以定义一维、二维或三维查找表，用于气动学和函数定义。对于一个单一的“向量”查找表，格式如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003ctableData\u003e key_1 value_1 key_2 value_2 ... ... key_n value_n \u003c/tableData\u003e \u003c/table\u003e 在这个例子中，\u003cindependentVar/\u003e 元素的 lookup=\"row\" 属性是可选的；默认假设 independentVar 是行变量。一个实际的示例如下：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003ctableData\u003e -1.57 1.500 -0.26 0.033 0.00 0.025 0.26 0.033 1.57 1.500 \u003c/tableData\u003e \u003c/table\u003e 数据表格中的第一列代表查找索引（或 断点，或键）。在这个例子中，查找索引是 aero/alpha-rad（迎角，以弧度为单位）。如果 aero/alpha-rad 的值为 0.26 弧度，则查找表返回的值为 0.033。\n二维表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003ctableData\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 数据是以网格格式呈现的。以下是一个实际示例，其中 aero/alpha-rad 是行查找（迎角的断点排列在第一列），fcs/flap-pos-deg 是列查找（襟翼位置的角度，分别为 0、10、20 和 30 度）：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/flap-pos-deg \u003c/independentVar\u003e \u003ctableData\u003e 0.0 10.0 20.0 30.0 -0.0523599 8.96747e-05 0.00231942 0.0059252 0.00835082 -0.0349066 0.000313268 0.00567451 0.0108461 0.0140545 -0.0174533 0.00201318 0.0105059 0.0172432 0.0212346 0.0 0.0051894 0.0168137 0.0251167 0.0298909 0.0174533 0.00993967 0.0247521 0.0346492 0.0402205 0.0349066 0.0162201 0.0342207 0.0457119 0.0520802 0.0523599 0.0240308 0.0452195 0.0583047 0.0654701 0.0698132 0.0333717 0.0577485 0.0724278 0.0803902 0.0872664 0.0442427 0.0718077 0.088081 0.0968405 \u003c/tableData\u003e \u003c/table\u003e 三维查找表的定义如下：\n\u003ctable name=\"property_name_0\"\u003e \u003cindependentVar lookup=\"row\"\u003e property_name_1 \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e property_name_2 \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e property_name_3 \u003c/independentVar\u003e \u003ctableData breakpoint=\"table_1_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003ctableData breakpoint=\"table_2_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e ... \u003ctableData breakpoint=\"table_n_key\"\u003e {col_1_key col_2_key ... col_n_key } {row_1_key} {col_1_data col_2_data ... col_n_data} {row_2_key} {... ... ... ... } { ... } {... ... ... ... } {row_n_key} {... ... ... ... } \u003c/tableData\u003e \u003c/table\u003e 请注意 \u003ctableData/\u003e 元素中的 breakpoint 属性。以下是一个示例：\n\u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e fcs/row-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e fcs/column-value \u003c/independentVar\u003e \u003cindependentVar lookup=\"table\"\u003e fcs/table-value \u003c/independentVar\u003e \u003ctableData breakPoint=\"-1.0\"\u003e -1.0 1.0 0.0 1.0000 2.0000 1.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"0.0000\"\u003e 0.0 10.0 2.0 1.0000 2.0000 3.0 3.0000 4.0000 \u003c/tableData\u003e \u003ctableData breakPoint=\"1.0\"\u003e 0.0 10.0 20.0 2.0 1.0000 2.0000 3.0000 3.0 4.0000 5.0000 6.0000 10.0 7.0000 8.0000 9.0000 \u003c/tableData\u003e \u003c/table\u003e 插值：表格中的值是线性插值的，且不会在表格的限制值之外进行外推。表格返回的最大值是已定义的最大值。 一维插值 一些仿真中的查找表——尤其是气动数据——可能是四维、五维、六维，甚至更多维度的。Interpolate1d 返回通过对提供的值进行一维插值的结果，其中第一个直接子元素的值表示查找表中的查找值，后续的值对表示自变量和因变量。第一个提供的子元素预期是一个属性。插值不会进行外推，如果提供的查找值超出了定义的范围，则返回最高值。其格式如下：\n\u003cinterpolate1d\u003e {property, value, table, function} {property, value, table, function} {property, value, table, function} ... \u003c/interpolate1d\u003e 示例：如果 mach 为 0.4，插值将返回 0.375。如果 mach 为 1.5，插值将返回 0.60。\n\u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cv\u003e 0.25 \u003c/v\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003cv\u003e 0.50 \u003c/v\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003cv\u003e 0.60 \u003c/v\u003e \u003c/interpolate1d\u003e 上面的示例非常简单。一个更复杂的示例可能会在任何参数（除了第一个）中使用函数。这意味着断点向量可能是变量——尽管这并不常见——但更重要的是，查找向量（第二列）中的值可能是 1、2 或 3 维度的函数表元素。参数甚至可以是嵌套的 interpolate1d 元素。例如：\n\u003cfunction name=\"whatever\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 进一步扩展：\n\u003cfunction name=\"bigWhatever1\"\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003c/function\u003e 上面的结构实际上提供了一个五维查找表。在实践中，这会非常庞大且混乱，但这就是实现方式。 :-)\n不过，这里还有更多。对于非常非常大的气动数据库，有时某些气动系数可能不需要计算。例如，地面效应气动系数只在接近地面时才需要计算。当地面效应不对气动力和力矩产生影响时，为什么还要浪费 CPU 循环呢？我们可以使用 ifthen 元素来跳过昂贵的计算。ifthen 元素的工作方式如下：\n如果第一个直接子元素的值为 1，则返回第二个直接子元素的值，否则返回第三个子元素的值。\n\u003cifthen\u003e {property, value, table, or other function element} {property, value, table, or other function element} {property, value, table, or other function element} \u003c/ifthen\u003e 示例：如果 flight-mode 大于 2，则返回 0.00，否则返回属性 control/pitch-lag 的值。\n\u003cifthen\u003e \u003cgt\u003e \u003cp\u003e executive/flight-mode \u003c/p\u003e \u003cv\u003e 2 \u003c/v\u003e \u003c/gt\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003cp\u003e control/pitch-lag \u003c/p\u003e \u003c/ifthen\u003e 在我们的例子中，可以如下编写五维查找表查询，除非起落架已放下，否则返回零：\n\u003cfunction name=\"propertyname\"\u003e \u003cifthen\u003e \u003clt\u003e \u003cp\u003e position/altitudeMSL \u003c/p\u003e \u003cv\u003e 90 \u003c/v\u003e \u003c/lt\u003e \u003cinterpolate1d\u003e \u003cp\u003e aero/qbar-psf \u003c/p\u003e \u003cv\u003e 0 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 65 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003cv\u003e 90 \u003c/v\u003e \u003cinterpolate1d\u003e \u003cp\u003e velocities/mach \u003c/p\u003e \u003cv\u003e 0.00 \u003c/v\u003e \u003ctable\u003e ... table 1 definition ... \u003c/table\u003e \u003cv\u003e 0.80 \u003c/v\u003e \u003ctable\u003e ... table 2 definition ... \u003c/table\u003e \u003cv\u003e 0.90 \u003c/v\u003e \u003ctable\u003e ... table 3 definition ... \u003c/table\u003e \u003c/interpolate1d\u003e \u003c/interpolate1d\u003e \u003cv\u003e 0 \u003c/v\u003e \u003c/ifthen\u003e \u003c/function\u003e 上面的例子在某种程度上是没有实际意义的，但格式是正确的。从性能角度来看，这是有效的，因为表格只有在查找时确实需要时才会被执行。\n力与力矩 空气动力学 有几种方法可以模拟作用在飞机上的空气动力学力和力矩（扭矩）。JSBSim 最初采用的是系数积累法。在系数积累法中，升力（例如）是通过将所有升力贡献相加来确定的。贡献的具体内容根据飞机的不同和模型的精度而有所不同，但升力的贡献可以包括来自以下方面的贡献：\n机翼 升降舵 襟翼 空气动力学系数是一些数字，这些数字在乘以某些其他值（如动态压力和机翼面积）后，结果就是一个力或力矩。这些系数可以来自飞行试验报告或教科书，或者可以通过软件（如 Digital DATCOM 或其他商业软件）或手工计算来得出。最终，JSBSim 增加了对作为函数指定的空气动力学属性的支持。在配置文件的 \u003caerodynamics\u003e 部分中，有六个子部分，分别代表 3 个力轴和 3 个力矩轴（总共六个自由度）。空气动力学部分的基本布局如下：\n\u003caerodynamics\u003e \u003caxis name=\"DRAG\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"SIDE\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"LIFT\"\u003e { 力的贡献 } \u003c/axis\u003e \u003caxis name=\"ROLL\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"PITCH\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003caxis name=\"YAW\"\u003e { 力矩的贡献 } \u003c/axis\u003e \u003c/aerodynamics\u003e 并非所有单独的轴都是必需的。JSBSim 支持几组标准的轴系统：\n\"DRAG\"、\"SIDE\"、\"LIFT\"（风轴） \"X\"、\"Y\"、\"Z\"（机体轴） \"AXIAL\"、\"SIDE\"、\"NORMAL\"（机体轴） 所有三个系统都接受 \"ROLL\"、\"PITCH\"、\"YAW\" 轴的定义。轴系统不能混合使用。在轴元素中，函数用于定义对该轴总力或力矩的各个贡献。在 JSBSim 中，函数是被广泛使用的。在定义力或力矩时，函数可以使用表格、常数、三角函数或其他标准 C 库函数。仿真参数通过属性进行引用。以下是一个例子：\n\u003cfunction name=\"aero/force/lift_due_to_flap_deflection\"\u003e \u003cdescription\u003e襟翼偏转引起的升力贡献\u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003eaero/function/ground-effect-factor-lift\u003c/property\u003e \u003cproperty\u003eaero/qbar-area\u003c/property\u003e \u003ctable\u003e \u003cindependentVar\u003efcs/flap-pos-deg\u003c/independentVar\u003e \u003ctableData\u003e 0.0 0.0 10.0 0.20 20.0 0.30 30.0 0.35 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 在此例中，以上内容的文字描述如下：该函数的值是 ground-effect-factor-lift、qbar-area 和通过表格确定的值的乘积，表格根据襟翼位置（以度为单位）进行索引。\n在 \u003caxis/\u003e 部分中的所有函数都会相加，并以适当的方式应用于飞机。然而，这种格式具有一定的灵活性。那些在任何 \u003caxis/\u003e 部分之外指定的函数会被创建和计算，但它们本身并不会直接贡献到任何力或力矩的总值中。然而，它们可以被引用到位于 \u003caxis/\u003e 部分内的其他函数中。这种技术允许将可能应用于多个单独函数的计算一次性执行，并多次使用。这个技术还可以进一步扩展，实际上，空气动力学系数可以在 \u003caxis/\u003e 定义外计算出来，然后在函数定义内通过乘以各种因子（属性）将它们转换为力和力矩，并最终在 \u003caxis/\u003e 定义中应用。\n力与力矩的例子：瞬时升力 作为一个例子，我们来分析瞬时升力 $L(t)$。它可以通过以下积累公式表示：\n$$ L=L_{\\text {basic }}\\left(\\alpha_{\\mathrm{B}}, \\phi_{\\text {hyst }}\\right)+\\Delta L\\left(\\delta_{\\text {flap }}\\right)+\\Delta L\\left(\\delta_{\\mathrm{e}}\\right)+\\Delta L\\left(\\dot{\\alpha}_{\\mathrm{B}}\\right)+\\Delta L(q) \\tag{1} $$其中，$\\alpha_B$、$\\delta_{\\text{flap}}$、$\\delta_e$、$\\dot{\\alpha}_B$ 和 $q$ 是常见的飞机状态变量。无量纲标量 $\\phi_{\\text{hyst}}$ 通常等于 0，当攻角较大时（接近失速情况，当空气动力学滞后效应被建模时），它的值为 1。\n公式 (1) 中的项 $L_{\\text{basic}}\\left(\\alpha_B, \\phi_{\\text{hyst}}\\right)$ 被称为“基本”贡献，它依赖于攻角。我们知道，增加攻角会增加升力——直到某个点为止。升力通常被定义为飞行动态压力（“qbar”，$\\bar{q}$，或者对于空气动力学家而言是 $\\bar{q}_{\\infty}$）与机翼面积（$S_W$ 或简写为 $S$）和升力系数（$C_L$）的乘积。在本例中，升力系数通过查找表来确定，使用 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 作为查找表的索引：\n\u003cfunction name=\"aero/force/lift_from_alpha\"\u003e \u003cdescription\u003e 升力由于攻角 \u003c/description\u003e \u003cproduct\u003e \u003cproperty\u003e aero/qbar-psf \u003c/property\u003e \u003cproperty\u003e metrics/Sw-sqft \u003c/property\u003e \u003cproperty\u003e aero/function/kCLge \u003c/property\u003e \u003ctable\u003e \u003cindependentVar lookup=\"row\"\u003e aero/alpha-rad \u003c/independentVar\u003e \u003cindependentVar lookup=\"column\"\u003e aero/stall-hyst-norm \u003c/independentVar\u003e \u003ctableData\u003e 0.0000 1.0000 -0.0900 -0.2200 -0.2200 0.0000 0.2500 0.2500 0.0900 0.7300 0.7300 0.1000 0.8300 0.7800 0.1200 0.9200 0.7900 0.1400 1.0200 0.8100 0.1600 1.0800 0.8200 0.1700 1.1300 0.8300 0.1900 1.1900 0.8500 0.2100 1.2500 0.8600 0.2400 1.3500 0.8800 0.2600 1.4400 0.9000 0.2800 1.4700 0.9200 0.3000 1.4300 0.9500 0.3200 1.3800 0.9900 0.3400 1.3000 1.0500 0.3600 1.1500 1.1500 \u003c/tableData\u003e \u003c/table\u003e \u003c/product\u003e \u003c/function\u003e 基本升力系数\n$$ C_{L, \\text{ basic }}=\\frac{L_{\\text{ basic }}\\left(\\alpha_B, \\phi_{\\text{hyst }}\\right)}{\\bar{q} S} \\tag{2} $$下面是根据攻角 $\\alpha_B$ 和 $\\phi_{\\text{hyst}}$ 绘制的基本升力系数 $C_{L,\\text{basic}}$ 的曲线。\n上图显示了与 c172p 空气动力学模型中名为 aero/coefficient/CLwbh 的查找表相对应的二元函数 $C_{L,\\text{basic}}(\\alpha_B, \\phi_{\\text{hyst}})$。\nTODO 完成本小节内容。\n该图表示了与 c172p 空气动力学模型中名为 aero/coefficient/CDwbh 的查找表相对应的二元函数 $C_{D,\\text{basic}}(\\alpha_B, \\delta_{\\text{flap}})$。\nTODO 完成本小节内容。\n推力 (Propulsion) 推力部分通常涉及发动机的性能以及与之相关的空气动力学效应。在 JSBSim 中，推力系统通常通过对发动机的建模来实现，这包括计算气流、转速、油门设置和其他影响推力的因素。推力的计算需要依赖于多种因素，比如油门位置、发动机转速、飞行状态等。\n\u003cpropulsion\u003e \u003cengine name=\"engine1\"\u003e \u003cthrustModel\u003egeneric\u003c/thrustModel\u003e \u003crpm\u003e2000\u003c/rpm\u003e \u003cpower\u003e180\u003c/power\u003e \u003cfuelFlow\u003e50\u003c/fuelFlow\u003e \u003cthrust\u003e \u003cfunction\u003ethrust_from_rpm\u003c/function\u003e \u003c/thrust\u003e \u003c/engine\u003e \u003c/propulsion\u003e 在此示例中，我们定义了一个名为 engine1 的发动机，使用了 generic 的推力模型，并为其指定了转速、功率和油耗等参数。推力是通过某个特定的函数来计算的，比如根据发动机转速来推算。\n重量 (Weight) 飞机的重量是影响飞行的关键因素，它包括飞机的自重、载荷以及油料的质量等。重量的变化直接影响到升力、飞行速度以及燃料消耗等参数。在 JSBSim 中，重量可以通过以下方式进行建模：\n\u003cweight\u003e \u003cemptyWeight\u003e1500\u003c/emptyWeight\u003e \u003cmaxTakeoffWeight\u003e2500\u003c/maxTakeoffWeight\u003e \u003cfuelWeight\u003e \u003cproperty\u003efuel/weight\u003c/property\u003e \u003c/fuelWeight\u003e \u003c/weight\u003e 在此示例中，定义了飞机的空重、最大起飞重量以及燃料重量。燃料的重量由 fuel/weight 属性控制，表示当前燃料的质量。\n地面接触 (Ground Contact) 地面接触模型用于模拟飞机与地面之间的交互力和接触点。这些交互力包括着陆、起飞时的冲击力，以及滑行时的摩擦力。在 JSBSim 中，地面接触模型通常包括以下几个部分：\n摩擦力：模拟飞机与地面之间的摩擦。 起落架：描述起落架的刚度、阻尼和承载能力。 接触力：模拟飞机与地面接触时产生的垂直力和水平力。 \u003cgroundContact\u003e \u003ccontact\u003e \u003csurfaceType\u003easphalt\u003c/surfaceType\u003e \u003cfrictionCoefficient\u003e0.8\u003c/frictionCoefficient\u003e \u003clandingGear\u003e \u003cmodel\u003ebasic\u003c/model\u003e \u003cstiffness\u003e2000\u003c/stiffness\u003e \u003cdamping\u003e100\u003c/damping\u003e \u003c/landingGear\u003e \u003c/contact\u003e \u003c/groundContact\u003e 在此示例中，定义了地面接触的表面类型（如沥青）、摩擦系数，以及起落架的刚度和阻尼特性。\n飞行控制与系统建模 将飞机视为一般的动力学系统，它受控制输入向量 $\\boldsymbol{u}$ 的作用。输入的数量和类型可能取决于具体考虑的飞机类型。对于常规配置的飞机，输入的最小配置通常为： $$ \\boldsymbol{u}=\\left[\\delta_{\\mathrm{T}}, \\delta_{\\mathrm{a}}, \\delta_{\\mathrm{e}}, \\delta_{\\mathrm{r}}\\right] \\tag{1} $$ 其中，$\\delta_{\\mathrm{T}}$ 是油门设定，$\\delta_{\\mathrm{a}}$、$\\delta_{\\mathrm{e}}$ 和 $\\delta_{\\mathrm{r}}$ 分别是右副翼、升降舵和方向舵的角度偏转。这些量有标准符号，且它们的范围可能会根据具体的飞机设计有所不同。在飞行仿真中，它们的变化通常与驾驶舱中相应控制的归一化设置相关。\n通常油门的设定范围从 0（空闲）到 +1（最大功率）。从概念上讲，$\\delta_{\\mathrm{T}}$ 可视为实际飞行速度和高度下最大推力输出的当前分数。\n操纵杆的偏转范围通常从 −1 到 +1。\n这些映射通常取决于控制律的存在，这些控制律可能会改变飞行员操作对实际效应器偏转和推力输出的最终影响。\n从数学的角度看，无论是考虑实际的气动表面偏转和推力输出，还是归一化的命令范围，它们都被视为控制变量 $\\boldsymbol{u}$ 的一组边界。\n必须再次强调，控制输入的数量和类型是特定飞机的特征。即使在相同的广泛类别中，两种飞机设计也可能呈现出本质上不同的控制配置和数量。但一般来说，它们至少有相同的“主要”控制：一对副翼，一个主要的纵向控制，即一对对称运动的升降舵，以及一个方向舵。在许多情况下，水平尾翼也具有相对于机身参考线的可变安装角度，这个角度通常称为 $i_{\\mathrm{H}}$，大多数飞行力学教材中都有涉及。\n约定 标准飞机气动控制表面。\n气动建模概述 线性化的迎角系数： $$ C_m=C_{m 0}+C_{m \\alpha} \\alpha_{\\mathrm{B}}+C_{m \\delta_{\\mathrm{e}}} \\delta_{\\mathrm{e}}+C_{m i_{\\mathrm{H}}} i_{\\mathrm{H}}+\\left(C_{m q} q+C_{m \\dot{\\alpha}} \\dot{\\alpha}_{\\mathrm{B}}\\right) \\frac{\\bar{c}}{2 V} \\tag{2} $$ 在 c172p 模型中，升降舵通道的命令与偏转逻辑。操纵杆的移动与迎角调整杆的调节组合，归一化并映射到区间 [−1,1]。该通道的输出是一个实数变量 fcs/elevator-pos-rad，表示一个等效的升降舵偏转 $\\delta_{\\mathrm{e}}^\\star = \\delta_{\\mathrm{e}} + \\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$。其中，$\\delta_{\\mathrm{e}, \\mathrm{tab}}^\\star$ 是等效于实际升降舵调整角度 $\\delta_{\\mathrm{e}, \\mathrm{tab}}$ 的偏转角度。$\\delta_{\\mathrm{e}}$ 的范围是 [$\\delta_{\\mathrm{e}, \\mathrm{min}}$, $\\delta_{\\mathrm{e}, \\mathrm{max}}$]。尾部以移动的表面偏转来表示，既有等效条件下（上方）也有实际条件下（下方）的偏转。\n推力建模概述 一架双引擎螺旋桨飞机。在机体坐标系中，推进器、推力应用点和推力矢量的方向位置。\n与 c172p 的 FDM 中的实体 “推进器” 和 “油箱” 相关的位置。",
    "description": "用户手册 https://jsbsim-team.github.io/jsbsim-reference-manual/\n本部分解释了如何使用 JSBSim 进行模拟运行、创建飞行器模型、编写脚本，以及如何执行其他不涉及对 JSBSim 程序代码进行更改的任务。\nJSBSim 软件提供了许多现成可用的飞行器模型示例。一旦用户熟悉了进行模拟所需的所有步骤和设置，可能会希望查看这些示例，并详细了解更有经验的 JSBSim 用户是如何实现某些特定模型的。\n该项目和发行版中包含的飞行器模型不包含任何专有、敏感或机密数据。所有数据均来源于教材（如 Stevens 和 Lewis 的《Aircraft Control and Simulation》以及 Sutton 的《Rocket Propulsion Elements》）、公开的技术报告（见：NASA技术报告网站和AIAA网站），或其他公开数据（如FAA网站）。JSBSim 发行版中包含的飞行器模型，以及与现有商业或军事飞行器名称相对应的模型，都是基于公开信息制作的近似模型，仅供教育或娱乐使用。\n概述 什么是 JSBSim？ 从应用程序编程的角度来看，JSBSim 是一个主要用 C++ 编程语言编写的程序代码集合（其中包括一些 C 语言例程）。组成 JSBSim 的一些 C++ 类用于建模物理实体，如大气、飞行控制系统或引擎。某些类封装了诸如运动方程、矩阵、四元数或向量等概念或数学构造。一些类管理其他对象的集合。总的来说，JSBSim 应用程序接受控制输入，计算并汇总来自这些控制输入和环境的力矩，并在离散时间步中推进飞行器的状态（速度、方位、位置等）。\nJSBSim 已经在各种平台上构建和运行，如 Windows 或 Linux 系统上的 PC、苹果 Macintosh 以及硅谷图形公司的 IRIX 操作系统。自由的 GNU g++ 编译器可以轻松编译 JSBSim，其他如 Borland 和 Microsoft 的编译器也能很好地工作。更多信息请参见《程序员指南》。\n从最终用户的角度来看（例如进行研究的学生），JSBSim 可以被视为一个“黑箱”，它通过 XML 格式的输入文件进行提供。这些 XML 文件包含了航天器、引擎、脚本等的描述。当这些文件被加载到 JSBSim 中时，它们指示 JSBSim 模拟该飞行器的飞行情况，作为更大仿真框架的一部分（例如 FlightGear 或 OpenEaagles），或者在批处理模式下以比实际时间更快的速度运行。每次运行 JSBSim 都会生成包含模拟飞行器性能和动态数据的文件。",
    "tags": [],
    "title": "JSBSim User manual",
    "uri": "/simu/jsbsim_user_manual/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Simulation",
    "content": "JSBSim Quickstart https://jsbsim-team.github.io/jsbsim-reference-manual/\nJSBSim 是一个轻量级的数据驱动型非线性六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本在线参考手册是一个社区合作项目，旨在让用户和开发者了解软件的所有功能。\n许可证： JSBSim 根据 GNU 较宽通用公共许可证（LGPL）授权。\nAcknowledgements 这款软件是许多人多年来共同努力的成果。\nTony Peden 几乎从 JSBSim 的第一天起就开始为其发展做出贡献。他负责初始化和修剪代码。Tony 还将 David Megginson 的属性系统集成到了 JSBSim 中。Tony 来自俄亥俄州立大学，拥有航空与航天工程学位。\nDavid Culp 为 JSBSim 开发了涡轮发动机模型，并设计了多个使用该模型的飞机，包括 T-38。David 拥有多种军用和民用飞机的飞行经验，包括 T-38、波音 707、727、737、757、767、SGS 2-32 和 OV-10。David 是一名航空航天工程师，毕业于美国空军学院。\nDavid Megginson 曾长期参与 FlightGear 的核心开发工作。David 将我们的飞行动力学与他的一般航空飞行经验相结合，以帮助实现最大程度的真实感，除此之外，他还设计了 FlightGear 和 JSBSim 所使用的属性系统。他以对 XML 技术的贡献而闻名，并编写了 FlightGear 和 JSBSim 使用的 easyXML 解析器。\nErik Hofman 做了多方面的工作，包括寻找飞机数据、创建飞行模型（如 F-16），并进行一些编程工作。他还测试了 IRIX 兼容性。Erik 拥有计算机科学学位。\nMathias Frölich 增加了一个多功能的每个起落架的地面高度能力，并做了许多其他贡献。Mathias 是一位来自德国的数学家。\nAgostino De Marco 为 JSBSim 创建了一个广泛适用的成本/惩罚修剪分析功能，并曾在那不勒斯大学单独使用 JSBSim 或与 FlightGear 一起使用 JSBSim。\n来自英国的 David Luff 提供了最初的活塞发动机模型，Ron Jensen 对其进行了不断的改进。\n拥有多年仿真经验的工程师 Lee Duke 和 Bill Galbraith 提出了许多建议和想法，帮助改进了 JSBSim。\n来自 NASA 兰利研究中心的 Bruce Jackson，参与了多种仿真系统的开发与应用，长期以来一直给予支持和帮助，他许多年前用 C 语言编写的仿真代码（“LaRCSim”）对 JSBSim 的早期开发具有启发意义。\nCurt Olson 协调 FlightGear 及其一些构成部分（SimGear）的开发，多年来在仿真、控制理论和其他许多话题的讨论中给予了极大的帮助。与 FlightGear 社区的合作使 JSBSim 成为一个更好的工具。\n最后，用户和开发者社区的努力使 JSBSim 达到了今天的水平。感谢所有曾经花时间报告 bug 或请求新功能的人。\n前言 JSBSim 于 1996 年构思，作为一个轻量级、数据驱动型、非线性的六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本手册简介 本在线文档分为多个部分。这是因为 JSBSim 可以从不同的角度进行查看：作为飞行器模型开发者的视角，作为将 JSBSim 集成到完整飞行仿真架构中并配有视觉效果的集成者视角，或者作为希望通过添加额外功能来适配或增强 JSBSim 的软件开发者视角。\n文档的 快速入门 部分（第零部分）解释了如何快速开始使用 JSBSim。\n接下来的第一部分是 用户手册，它解释了如何使用 JSBSim 进行仿真运行、创建飞机模型、编写脚本，并执行其他不涉及更改 JSBSim 程序代码的任务。\n第二部分是 程序员手册，解释了 JSBSim 的架构——代码是如何组织的，如何工作。\n第三部分是 公式手册，其中包含了 JSBSim 中存在的数学模型和算法的描述。\n第四部分是一些示例和案例研究，展示了 JSBSim 的使用情况。\n本文档不包含的内容 本文档不是关于推导运动方程和飞行动力学的详尽参考书。有关此类内容，请参阅 (Stevens:Lewis:Johnson:2015) 和 (Zipfel:2003)。然而，本文档旨在成为 JSBSim 的权威文档。\n快速入门 要高效使用 JSBSim，您可能需要采用 程序员的态度。这意味着您需要自行下载源代码并在您的平台上进行编译。只要您的计算机上安装了正确的工具，这其实是一个简单的过程。\n对于急于使用的人，提供了自动远程构建过程，能够交付最新的库二进制文件。您可以通过以下链接找到这些二进制文件：\nFlightGear 项目开发者提供的构建版本 (Jenkins 服务器) Linux 版 JSBSim 构建（Linux CentOS 7 虚拟机） 前往工作区 build.flightgear.org:8080/job/JSBSim/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim/build/src/ 文件夹，您会找到：可执行文件 JSBSim 和静态库文件 libJSBSim.a。\nWindows 版 JSBSim 构建 前往工作区 build.flightgear.org:8080/job/JSBSim-win/ws，下载所有文件为 Zip 压缩包。解压文件，进入 /JSBSim-win/build/src/Debug/ 文件夹，您会找到：可执行文件 JSBSim.exe 和静态库文件 JSBSim.lib。\n提供预编译 JSBSim 二进制文件的工作是 FlightGear 项目的 持续集成与交付服务 的一部分。如需了解有关 Jenkins 持续集成的更多信息，您可以 访问此链接。\nJSBSim 团队提供的构建版本 (Travis 服务器 和 AppVeyor 服务器) JSBSim 团队提供了自己的持续集成服务，交付适用于 Ubuntu 14.04.5 LTS（Trusty Tahr）和 MS Windows 的 x64 二进制文件。发布版本标记为 v2018a（或更高版本），可以从 GitHub 仓库的 发布区 下载。\n要查看最新构建的当前状态，可以访问以下链接：\nUbuntu 版 Travis 构建（包括 Python 2.7 和 3.6 的测试） Windows 版 AppVeyor 构建（无测试） 那么，您想要模拟这架飞机的飞行吗？\n获取源代码 JSBSim 的 GitHub 仓库可以通过以下链接访问：github.com/JSBSim-Team/jsbsim。该仓库镜像了 SourceForge 上的原始仓库：sourceforge.net/projects/jsbsim。\n下载源代码所需的工具 您需要安装 Git 软件。Git 是一个 版本控制软件，用于记录文件或文件集随时间的变化，以便您可以随时回溯到特定版本。JSBSim 的软件源代码文件是通过 Git 进行版本控制的。\n要安装 Git，请 访问下载页面，并选择适合您平台的版本。您可以通过两种方式在本地使用 Git：通过 GUI 客户端，或通过命令行（例如在 Linux 或 Windows 上使用 Bash shell）。\n安装完 Git 后，假设您将通过命令行使用 Git，您可以从以下两个位置之一 克隆 JSBSim 的公开源代码仓库。\n从 SourceForge 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://git.code.sf.net/p/jsbsim/code jsbsim-code 或者（SSH 模式）\n\u003e git clone git://git.code.sf.net/p/jsbsim/code jsbsim-code 从 GitHub 下载 在这种情况下，克隆仓库的 Git 命令是（HTTPS 模式）\n\u003e git clone https://github.com/JSBSim-Team/jsbsim.git jsbsim-code 或者（SSH 模式）\n\u003e git clone git@github.com:JSBSim-Team/jsbsim.git jsbsim-code 那么，您想要模拟这架飞机的飞行吗？\n构建程序和库 JSBSim 可以通过 CMake 或 Microsoft Visual Studio 进行构建。如果您使用的是 Mac OSX 或 Linux 平台，必须使用 CMake。如果您是 Windows 用户，可以选择任意一种工具。\nJSBSim 使用标准 C++98/C99 编写，并且没有外部依赖，因此您只需要在您的平台上安装 C/C++ 编译器即可。\n使用 CMake 构建 CMake 是一个跨平台的构建和测试软件的工具。它可以生成用于使用 GNU make 或 Microsoft Visual Studio 构建 JSBSim 的文件。为了将构建文件与源代码分开，最好在单独的目录中构建 JSBSim。\n\u003e cd jsbsim-code \u003e mkdir build \u003e cd build CMake 不构建 软件，它生成文件 供 多种构建工具使用。以下命令假定您使用 GNU make 来构建 JSBSim。\n首先，您应该调用 CMake 然后执行 make\n\u003e cmake .. \u003e make 这将编译各种类并构建 JSBSim 应用程序，最终文件将位于 build/src 目录下。\n传递给 CMake 的选项 CMake 可以使用多个参数来调整 JSBSim 的构建。以下是不同的选项，您可以根据需要独立使用它们或任意组合。\n传递参数给编译器 如果您想设置编译器选项，可以通过传递标志给 CMake 来构建 JSBSim 的 Debug 版本。JSBSim 也使用 C 语言编写了一些代码，您可以为 C++ 和 C 编译器设置选项。\n\u003e cmake -DCMAKE_CXX_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_C_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_BUILD_TYPE=Debug .. \u003e make 或者，您也可以构建 JSBSim 的发布版本，并请求 GNU Make 使用 4 核心来加速可执行文件的构建。\n\u003e cmake -DCMAKE_CXX_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_C_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_BUILD_TYPE=Release .. \u003e make -j4 构建 Expat 或使用系统库 JSBSim 使用 Expat 库 来读取 XML 文件。Expat 源代码与 JSBSim 源代码一起提供，并在构建过程中与 JSBSim 一起编译。然而，如果 Expat 已经安装在您的平台上，您可能更倾向于使用系统的 Expat 库，以避免重复。在这种情况下，您应该将 SYSTEM_EXPAT 标志传递给 CMake：\n\u003e cmake -DSYSTEM_EXPAT=ON .. \u003e make 构建 JSBSim 的 Python 模块 JSBSim 的 Python 模块也可以通过 CMake 来构建。为此，您需要在您的平台上安装 Cython。CMake 将自动检测到 Cython 并构建 Python 模块。\n使用 Microsoft Visual Studio 构建 在 Visual Studio 中，您可以打开项目文件 JSBSim.vcxproj 来加载 JSBSim 项目。该项目文件将配置 Visual Studio 来构建 JSBSim 可执行文件。\n注意 1： JSBSim 的官方构建工具是 CMake。Visual Studio 项目文件作为一种便利工具提供，并不保证始终与代码保持同步。\n注意 2： 从 Visual Studio 2017 开始，Microsoft 已将 CMake 包含在内，因此您应该能够直接从 CMake 文件在 VS2017 中构建 JSBSim。\n测试 JSBSim JSBSim 附带了一个测试套件，用于自动检查构建是否正确。该测试套件位于 tests 目录中，并使用 Python 编写，因此您需要先构建 JSBSim 的 Python 模块。\n测试套件可以在 build 目录中使用 ctest 运行。可以使用 -j 选项在多个核心上并行运行测试（例如，以下示例中使用 4 核心）。\n\u003e ctest -j4 安装 JSBSim 一旦 JSBSim 被构建和测试完成，您可以将 C++ 头文件和库安装到平台范围内。为此，您可以在 build 目录中调用 GNU make：\n\u003e make install 安装 Python 模块 如果您除了 C++ 头文件和库外，还计划安装 JSBSim 的 Python 模块，那么必须将 INSTALL_PYTHON_MODULE 标志传递给 CMake：\n\u003e cmake -DINSTALL_PYTHON_MODULE=ON .. \u003e make \u003e make install 另外，您也可以通过在 build 目录中执行以下命令手动安装 Python 模块：\n\u003e cd tests \u003e python setup.py install 那么，您想模拟这架飞机的飞行吗？\n使用 Visual Studio 构建 随着 Visual Studio 2017 开始支持 CMake，现在有两种方法可以使用 Visual Studio 2017 构建 JSBSim 及其各种组件。一种是使用标准的 Visual Studio 项目文件（*.vcxproj），用于构建 JSBSim 主程序、Aeromatic++ 等组件，另一种是通过 Visual Studio 使用 CMake 来构建 JSBSim 及其各种组件。\n使用 git 检出 JSBSim 源代码。在这些示例中，源代码已检出到：\nC:\\source\\JSBSim 使用 VS 2017 项目文件构建 选择 文件 → 打开 → 项目/解决方案 … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 JSBSim.sln 文件，在本例中是：\nC:\\source\\JSBSim\\JSBSim.sln 项目文件已配置为将编译器和链接器的中间文件以及最终输出文件存储在 JSBSim 源代码树之外的目录中，即存储在 C:\\source\\JSBSim\\src 外部。\n例如，JSBSim 和 Aeromatic 的中间文件将存储在以下目录中：\nC:\\source\\JSBSim\\Debug\\x64\\JSBSim C:\\source\\JSBSim\\Debug\\x64\\aeromatic 输出文件将位于：\nC:\\source\\JSBSim\\Debug 使用 VS 2017 CMake 支持构建 选择 文件 → 打开 → CMake … 菜单选项。\n浏览到 JSBSim 源代码所在的位置，选择根目录下的 CMakeLists.txt 文件，在本例中是：\nC:\\source\\JSBSim\\CMakeLists.txt 共有 4 种构建配置：x86、x64 以及每种版本的 Debug 和 Release。选择您想要构建的配置。\n然后使用 CMake 菜单选项选择您想要构建的组件。\n默认情况下，Visual Studio 将配置 CMake 构建到源代码树之外，默认使用用户主目录中的一个构建目录，并且将 GUID（全球唯一标识符）作为目录路径的一部分。您将在 Visual Studio 的输出窗口中看到生成的路径，例如：\n工作目录：C:\\Users\\Sean\\CMakeBuilds\\3f00c6d9-d323-5a32-8a90-665138817fd4\\build\\x64-Release 例如，如果您不想将 CMake 构建文件放在主目录中，可以通过 CMake → 更改 CMake 设置 菜单选项生成一个 CMakeSettings.json 文件，并编辑 buildRoot 和 installRoot 属性。\n最后，Visual Studio 还支持执行 JSBSim 测试。\n运行程序 这里所指的 JSBSim 仓库所在的路径将被称为 \u003cJSBSim-root-dir\u003e。如果您是从源代码构建了 JSBSim，您将在 \u003cJSBSim-root-dir\u003e/src/ 子目录下找到可执行文件（在 Linux 上为 JSBSim，在 Windows 上为 JSBSim.exe）。这是 JSBSim 独立应用程序，您可能希望将其复制到根目录中：\n\u003cJSBSim-root-dir\u003e$ cp src/JSBSim . 运行独立 JSBSim 应用程序时，可能会指定多个选项。\n\u003cJSBSim-root-dir\u003e$ JSBSim 用法（方括号中的项是可选的）： JSBSim [脚本名称] [输出指令文件名称] \u003c选项\u003e 选项： --help 返回使用信息 --version 返回版本号 --outputlogfile=\u003c文件名\u003e 设置/替换数据日志文件的名称 --logdirectivefile=\u003c文件名\u003e 设置数据日志指令文件的名称 --root=\u003c路径\u003e 设置 JSBSim 根目录（即 `src/` 所在目录） --aircraft=\u003c文件名\u003e 设置要模拟的飞机名称 --script=\u003c文件名\u003e 指定要运行的脚本 --realtime 指定按实际世界时间运行 --nice 指示 JSBSim 以低 CPU 使用率运行 --suspend 指定在初始化后暂停仿真 --initfile=\u003c文件名\u003e 指定要使用的初始化文件 --catalog 指示 JSBSim 列出该模型的所有属性 （--catalog 可以与 --aircraft 选项一起在命令行中指定， 或单独指定，同时指定飞机名称，例如 --catalog=c172） --end-time=\u003c时间\u003e 指定仿真结束时间（例如，time=20.5） --property=\u003cname=value\u003e 设置属性的值。 例如：--property=simulation/integrator/rate/rotational=1 注意：选项后跟文件名时，等号两边不能有空格 您可以通过提供脚本名称来运行 JSBSim：\n\u003cJSBSim-root-dir\u003e$ JSBSim --script=scripts/c1723.xml TODO\n完善页面内容。\n那么，您想模拟这架飞机的飞行吗？\n获取支持 获取 JSBSim 支持的最佳方式是注册 GitHub 账户并 关注 JSBSim 仓库：github.com/JSBSim-Team/jsbsim。您可以订阅单独的对话，包括问题（issues）、拉取请求（pull requests）和团队讨论，即使您没有关注该仓库或不是讨论所在团队的成员。如果您不再对某个对话感兴趣，可以随时取消订阅未来的通知。\n要了解更多信息，请阅读此指南。",
    "description": "JSBSim Quickstart https://jsbsim-team.github.io/jsbsim-reference-manual/\nJSBSim 是一个轻量级的数据驱动型非线性六自由度（6DoF）批处理仿真应用，旨在建模飞机的飞行动力学与控制。从最早的版本开始，JSBSim 就受益于其成长过程中的开源开发环境，以及众多用户对其持续改进所提出的各种想法。\n本在线参考手册是一个社区合作项目，旨在让用户和开发者了解软件的所有功能。\n许可证： JSBSim 根据 GNU 较宽通用公共许可证（LGPL）授权。\nAcknowledgements 这款软件是许多人多年来共同努力的成果。\nTony Peden 几乎从 JSBSim 的第一天起就开始为其发展做出贡献。他负责初始化和修剪代码。Tony 还将 David Megginson 的属性系统集成到了 JSBSim 中。Tony 来自俄亥俄州立大学，拥有航空与航天工程学位。\nDavid Culp 为 JSBSim 开发了涡轮发动机模型，并设计了多个使用该模型的飞机，包括 T-38。David 拥有多种军用和民用飞机的飞行经验，包括 T-38、波音 707、727、737、757、767、SGS 2-32 和 OV-10。David 是一名航空航天工程师，毕业于美国空军学院。\nDavid Megginson 曾长期参与 FlightGear 的核心开发工作。David 将我们的飞行动力学与他的一般航空飞行经验相结合，以帮助实现最大程度的真实感，除此之外，他还设计了 FlightGear 和 JSBSim 所使用的属性系统。他以对 XML 技术的贡献而闻名，并编写了 FlightGear 和 JSBSim 使用的 easyXML 解析器。\nErik Hofman 做了多方面的工作，包括寻找飞机数据、创建飞行模型（如 F-16），并进行一些编程工作。他还测试了 IRIX 兼容性。Erik 拥有计算机科学学位。",
    "tags": [],
    "title": "JSBSim Quickstart",
    "uri": "/simu/jsbsim_quickstart/index.html"
  },
  {
    "breadcrumb": "FlitSoft Docs \u003e  Log",
    "content": "12 3\n将基于运动基元的A*算法从四旋翼无人机改进适配到固定翼无人机 参考的基于运动基元的四旋翼无人机A*算法：\nhttps://github.com/HKUST-Aerial-Robotics/Fast-Planner/blob/master/fast_planner/path_searching/src/kinodynamic_astar.cpp\n总体思路\n分析四旋翼A*算法的核心部分：了解其状态表示、控制输入、运动模型和运动基元生成方式。\n理解固定翼无人机的动力学特性：明确其状态变量、控制输入、运动学/动力学模型，以及物理和操作限制。\n整合调整：在前两步的基础上，重新定义状态和控制输入，修改运动基元生成方法，调整启发式函数和代价函数，确保算法的合理性和可行性。\n1. 四旋翼A*算法概述 1.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 速度：$\\mathbf{v} = [v_x, v_y, v_z]^T$ 状态向量：$\\mathbf{s} = [\\mathbf{p}, \\mathbf{v}]^T$，共6维。 1.2 控制输入\n加速度：$\\mathbf{a} = [a_x, a_y, a_z]^T$ 控制输入集：在最大加速度范围内进行离散化，生成一系列可能的加速度向量。 1.3 运动模型\n假设加速度在时间段$\\tau$内恒定，使用匀加速运动方程进行状态转移： $$ \\begin{cases} \\mathbf{p}(t+\\tau) = \\mathbf{p}(t) + \\mathbf{v}(t) \\tau + \\frac{1}{2} \\mathbf{a} \\tau^2 \\\\ \\mathbf{v}(t+\\tau) = \\mathbf{v}(t) + \\mathbf{a} \\tau \\end{cases} $$1.4 运动基元生成\n对控制输入$\\mathbf{a}$和持续时间$\\tau$进行离散化，生成一系列可能的运动基元。 在节点扩展时，应用这些运动基元进行状态转移，生成新节点。 2. 固定翼无人机动力学特性 2.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 航向角：$\\chi$（水平面内的方向） 俯仰角（航迹角）：$\\gamma$（垂直方向的角度） 速度大小：$v$（通常假设恒定或在一定范围内） 状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$，共5维。 2.2 控制输入\n航向角变化率：$\\dot{\\chi}$ 航迹角变化率：$\\dot{\\gamma}$ 控制输入向量：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 2.3 运动学模型\n假设速度$v$恒定，固定翼无人机的运动学方程为：\n$$ \\begin{cases} \\dot{x} = v \\cos \\gamma \\cos \\chi \\\\ \\dot{y} = v \\cos \\gamma \\sin \\chi \\\\ \\dot{z} = v \\sin \\gamma \\\\ \\dot{\\chi} = \\dot{\\chi} \\\\ \\dot{\\gamma} = \\dot{\\gamma} \\end{cases} $$2.4 动力学限制\n最小速度限制：$v_{\\min}$，避免失速。 最大速度限制：$v_{\\max}$ 最大航向角变化率：$|\\dot{\\chi}| \\leq \\dot{\\chi}_{\\max}$ 最大航迹角变化率：$|\\dot{\\gamma}| \\leq \\dot{\\gamma}_{\\max}$ 3. 方案整合与调整 3.1 状态和控制输入的重新定义\n状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$ 控制输入：$\\mathbf{u} = [\\dot{\\chi}, \\dot{\\gamma}]^T$ 3.2 运动基元的生成\n控制输入离散化：\n航向角变化率 $\\dot{\\chi}$：\n$$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 航迹角变化率 $\\dot{\\gamma}$： $$ \\dot{\\gamma}_D = \\left\\{ -\\dot{\\gamma}_{\\max}, -\\dot{\\gamma}_{\\max} + \\Delta_{\\gamma}, \\ldots, 0, \\ldots, \\dot{\\gamma}_{\\max} - \\Delta_{\\gamma}, \\dot{\\gamma}_{\\max} \\right\\} $$ 组合控制输入集：\n$$ \\mathcal{U}_D = \\left\\{ (\\dot{\\chi}, \\dot{\\gamma}) \\ \\big| \\ \\dot{\\chi} \\in \\dot{\\chi}_D, \\ \\dot{\\gamma} \\in \\dot{\\gamma}_D \\right\\} $$ 时间步长的确定：设定固定的时间步长$\\tau$，或者根据无人机的速度和环境动态调整。\n状态转移：\n使用数值积分方法（如四阶Runge-Kutta方法）在时间步长$\\tau$内对运动学方程进行积分，计算新状态$\\mathbf{s}(t+\\tau)$。\n状态更新函数：\nvoid stateTransit(const Eigen::VectorXd\u0026 state0, Eigen::VectorXd\u0026 state1, const Eigen::Vector2d\u0026 control_input, double tau) { double v = speed_; // 固定翼无人机的速度 double chi0 = state0(3); double gamma0 = state0(4); double dot_chi = control_input(0); double dot_gamma = control_input(1); // 更新航向角和航迹角 double chi1 = chi0 + dot_chi * tau; double gamma1 = gamma0 + dot_gamma * tau; // 使用平均值近似或数值积分计算位置更新 double avg_chi = (chi0 + chi1) / 2; double avg_gamma = (gamma0 + gamma1) / 2; double x1 = state0(0) + v * cos(avg_gamma) * cos(avg_chi) * tau; double y1 = state0(1) + v * cos(avg_gamma) * sin(avg_chi) * tau; double z1 = state0(2) + v * sin(avg_gamma) * tau; state1.resize(5); state1 \u003c\u003c x1, y1, z1, chi1, gamma1; } 3.3 节点扩展\n扩展函数：\nvoid expandNode(PathNodePtr current_node, std::vector\u003cPathNodePtr\u003e\u0026 successors) { // 获取当前状态 Eigen::VectorXd state0 = current_node-\u003estate; // 遍历所有可能的控制输入 for (const auto\u0026 dot_chi : dot_chi_values) { for (const auto\u0026 dot_gamma : dot_gamma_values) { Eigen::Vector2d control_input(dot_chi, dot_gamma); Eigen::VectorXd state1; // 状态转移 stateTransit(state0, state1, control_input, tau); // 检查速度限制（如果速度可变） // 检查物理可行性，如最小转弯半径 // 碰撞检测 if (!isCollisionFree(state0, state1)) { continue; } // 创建新节点 PathNodePtr new_node = new PathNode(); new_node-\u003estate = state1; new_node-\u003einput = control_input; new_node-\u003eduration = tau; new_node-\u003eparent = current_node; // 计算代价 new_node-\u003eg_score = current_node-\u003eg_score + costFunction(state0, state1, control_input, tau); new_node-\u003ef_score = new_node-\u003eg_score + heuristic(state1); // 加入后继节点列表 successors.push_back(new_node); } } } 3.4 代价函数和启发式函数\n代价函数：考虑航向角和航迹角变化率的代价，以及时间代价。 $$ \\text{Cost} = w_{\\chi} |\\dot{\\chi}| + w_{\\gamma} |\\dot{\\gamma}| + w_t \\tau $$ 启发式函数：使用三维Dubins路径的长度作为启发式估计。\nDubins路径：在已知最小转弯半径的情况下，计算从当前状态到目标状态的最短路径长度。\n启发式函数实现：\ndouble heuristic(const Eigen::VectorXd\u0026 state) { // 计算当前状态到目标状态的Dubins路径长度 double h = computeDubinsPathLength(state, goal_state_, min_turn_radius_); return h; } 3.5 碰撞检测\n离散采样：在状态转移过程中，对轨迹进行离散采样，检查每个采样点是否与障碍物发生碰撞。\n碰撞检测函数：\nbool isCollisionFree(const Eigen::VectorXd\u0026 state0, const Eigen::VectorXd\u0026 state1) { int num_checks = 10; // 采样点数量 for (int i = 1; i \u003c= num_checks; ++i) { double t = (double)i / num_checks * tau; Eigen::VectorXd intermediate_state; stateTransit(state0, intermediate_state, state1.segment(3,2) - state0.segment(3,2), t); Eigen::Vector3d position = intermediate_state.head(3); if (!isPositionValid(position)) { return false; } } return true; } 3.6 节点结构调整\n节点结构：根据新的状态和控制输入，调整节点的定义。\nclass PathNode { public: Eigen::Vector3i index; // 栅格索引 Eigen::VectorXd state; // 状态向量 [x, y, z, chi, gamma] double g_score, f_score; Eigen::Vector2d input; // 控制输入 [dot_chi, dot_gamma] double duration; PathNode* parent; char node_state; // 构造函数和析构函数 }; 3.7 A*算法流程\n搜索主循环：与传统A*算法类似，使用开启集和关闭集管理节点，按照 $f = g + h$ 的代价进行节点扩展和选择。\n算法步骤：\n初始化开启集，将起始节点加入开启集。 当开启集非空时： 从开启集中取出 $f$ 值最小的节点作为当前节点。 如果当前节点达到目标状态（或在容忍范围内），则回溯路径，结束搜索。 将当前节点加入关闭集。 扩展当前节点，生成后继节点。 对于每个后继节点： 如果节点在关闭集中，跳过。 如果节点不在开启集中，或找到更优路径，更新节点信息并加入开启集。 4. 方案可行性分析 4.1 动力学合理性\n重新定义的状态和控制输入符合固定翼无人机的动力学特性。 运动基元的生成考虑了固定翼的物理限制，如最小转弯半径和速度限制。 4.2 算法有效性\n通过使用合适的启发式函数（Dubins路径长度），保证算法的效率和最优性。 在节点扩展时进行碰撞检测，确保路径的可行性和安全性。 4.3 实际应用性\n方案中各部分的实现细节，如状态转移函数、碰撞检测和启发式函数，都可以在实际代码中具体实现。 方案兼顾了计算效率和规划质量，可以适用于实时路径规划。 5. 示例参数设置 速度：$v = 15 \\ \\text{m/s}$\n最大航向角变化率：$\\dot{\\chi}_{\\max} = \\frac{\\pi}{6} \\ \\text{rad/s}$（30度/秒）\n最大航迹角变化率：$\\dot{\\gamma}_{\\max} = \\frac{\\pi}{18} \\ \\text{rad/s}$（10度/秒）\n时间步长：$\\tau = 1 \\ \\text{s}$\n控制输入离散化步长：\n$\\Delta_{\\chi} = \\frac{\\dot{\\chi}_{\\max}}{2}$ $\\Delta_{\\gamma} = \\frac{\\dot{\\gamma}_{\\max}}{2}$ 控制输入集合：\nstd::vector\u003cdouble\u003e dot_chi_values = {-dot_chi_max, -dot_chi_max/2, 0, dot_chi_max/2, dot_chi_max}; std::vector\u003cdouble\u003e dot_gamma_values = {-dot_gamma_max, -dot_gamma_max/2, 0, dot_gamma_max/2, dot_gamma_max}; 代价函数权重：\n$w_{\\chi} = 1.0$ $w_{\\gamma} = 1.0$ $w_t = 0.1$ 最小转弯半径：\n$$ R_{\\min} = \\frac{v}{\\dot{\\chi}_{\\max}} $$ 6. 实现注意事项 6.1 数值积分方法\n由于航向角和航迹角在时间内线性变化，可以使用解析积分或简单的数值积分方法。 6.2 速度的可变性\n如果需要考虑速度的变化，可以将速度作为状态变量，并引入油门控制输入。 6.3 启发式函数的一致性\n确保启发式函数不超过实际代价，保持算法的可完备性和最优性。 6.4 碰撞检测的精度\n根据环境的复杂程度，调整采样点数量，以在精度和计算效率之间取得平衡。 总结 通过综合以上方案，我们成功地将基于四旋翼运动基元的A*算法调整为适用于固定翼无人机的版本。关键的调整在于：\n重新定义状态和控制输入：符合固定翼无人机的动力学特性。\n修改运动基元生成方式：基于固定翼的运动学模型，生成物理可行的运动基元。\n调整代价函数和启发式函数：考虑固定翼的运动特性，使用Dubins路径作为启发式估计。\n确保算法的可行性和有效性：通过碰撞检测和合理的参数设置，生成安全可行的路径。\n该方案兼顾了理论合理性和实际可行性，可用于固定翼无人机的路径规划，实现自主导航和避障功能。",
    "description": "12 3\n将基于运动基元的A*算法从四旋翼无人机改进适配到固定翼无人机 参考的基于运动基元的四旋翼无人机A*算法：\nhttps://github.com/HKUST-Aerial-Robotics/Fast-Planner/blob/master/fast_planner/path_searching/src/kinodynamic_astar.cpp\n总体思路\n分析四旋翼A*算法的核心部分：了解其状态表示、控制输入、运动模型和运动基元生成方式。\n理解固定翼无人机的动力学特性：明确其状态变量、控制输入、运动学/动力学模型，以及物理和操作限制。\n整合调整：在前两步的基础上，重新定义状态和控制输入，修改运动基元生成方法，调整启发式函数和代价函数，确保算法的合理性和可行性。\n1. 四旋翼A*算法概述 1.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 速度：$\\mathbf{v} = [v_x, v_y, v_z]^T$ 状态向量：$\\mathbf{s} = [\\mathbf{p}, \\mathbf{v}]^T$，共6维。 1.2 控制输入\n加速度：$\\mathbf{a} = [a_x, a_y, a_z]^T$ 控制输入集：在最大加速度范围内进行离散化，生成一系列可能的加速度向量。 1.3 运动模型\n假设加速度在时间段$\\tau$内恒定，使用匀加速运动方程进行状态转移： $$ \\begin{cases} \\mathbf{p}(t+\\tau) = \\mathbf{p}(t) + \\mathbf{v}(t) \\tau + \\frac{1}{2} \\mathbf{a} \\tau^2 \\\\ \\mathbf{v}(t+\\tau) = \\mathbf{v}(t) + \\mathbf{a} \\tau \\end{cases} $$1.4 运动基元生成\n对控制输入$\\mathbf{a}$和持续时间$\\tau$进行离散化，生成一系列可能的运动基元。 在节点扩展时，应用这些运动基元进行状态转移，生成新节点。 2. 固定翼无人机动力学特性 2.1 状态表示\n位置：$\\mathbf{p} = [x, y, z]^T$ 航向角：$\\chi$（水平面内的方向） 俯仰角（航迹角）：$\\gamma$（垂直方向的角度） 速度大小：$v$（通常假设恒定或在一定范围内） 状态向量：$\\mathbf{s} = [x, y, z, \\chi, \\gamma]^T$，共5维。 2.2 控制输入",
    "tags": [],
    "title": "基于运动基元的A*算法",
    "uri": "/log/page1/index.html"
  }
]
